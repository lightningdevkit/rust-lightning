//! The logic to monitor for on-chain transactions and create the relevant claim responses lives
//! here.
//!
//! ChannelMonitor objects are generated by ChannelManager in response to relevant
//! messages/actions, and MUST be persisted to disk (and, preferably, remotely) before progress can
//! be made in responding to certain messages, see ManyChannelMonitor for more.
//!
//! Note that ChannelMonitors are an important part of the lightning trust model and a copy of the
//! latest ChannelMonitor must always be actively monitoring for chain updates (and no out-of-date
//! ChannelMonitors should do so). Thus, if you're building rust-lightning into an HSM or other
//! security-domain-separated system design, you should consider having multiple paths for
//! ChannelMonitors to get out of the HSM and onto monitoring devices.

use bitcoin::blockdata::block::BlockHeader;
use bitcoin::blockdata::transaction::{TxIn,TxOut,SigHashType,Transaction};
use bitcoin::blockdata::transaction::OutPoint as BitcoinOutPoint;
use bitcoin::blockdata::script::{Script, Builder};
use bitcoin::blockdata::opcodes;
use bitcoin::consensus::encode::{self, Decodable, Encodable};
use bitcoin::util::hash::{Hash160, BitcoinHash,Sha256dHash};
use bitcoin::util::bip143;

use crypto::digest::Digest;

use secp256k1::{Secp256k1,Message,Signature};
use secp256k1::key::{SecretKey,PublicKey};
use secp256k1;

use ln::msgs::{DecodeError, HandleError};
use ln::chan_utils;
use ln::chan_utils::HTLCOutputInCommitment;
use chain::chaininterface::{ChainListener, ChainWatchInterface, BroadcasterInterface};
use chain::transaction::OutPoint;
use chain::keysinterface::SpendableOutputDescriptor;
use util::logger::Logger;
use util::ser::{ReadableArgs, Readable, Writer, Writeable, WriterWriteAdaptor, U48};
use util::sha2::Sha256;
use util::{byte_utils, events};

use std::collections::HashMap;
use std::sync::{Arc,Mutex};
use std::{hash,cmp, mem};

/// An error enum representing a failure to persist a channel monitor update.
#[derive(Clone)]
pub enum ChannelMonitorUpdateErr {
	/// Used to indicate a temporary failure (eg connection to a watchtower failed, but is expected
	/// to succeed at some point in the future).
	///
	/// Such a failure will "freeze" a channel, preventing us from revoking old states or
	/// submitting new commitment transactions to the remote party.
	/// ChannelManager::test_restore_channel_monitor can be used to retry the update(s) and restore
	/// the channel to an operational state.
	///
	/// Note that continuing to operate when no copy of the updated ChannelMonitor could be
	/// persisted is unsafe - if you failed to store the update on your own local disk you should
	/// instead return PermanentFailure to force closure of the channel ASAP.
	///
	/// Even when a channel has been "frozen" updates to the ChannelMonitor can continue to occur
	/// (eg if an inbound HTLC which we forwarded was claimed upstream resulting in us attempting
	/// to claim it on this channel) and those updates must be applied wherever they can be. At
	/// least one such updated ChannelMonitor must be persisted otherwise PermanentFailure should
	/// be returned to get things on-chain ASAP using only the in-memory copy. Obviously updates to
	/// the channel which would invalidate previous ChannelMonitors are not made when a channel has
	/// been "frozen".
	///
	/// Note that even if updates made after TemporaryFailure succeed you must still call
	/// test_restore_channel_monitor to ensure you have the latest monitor and re-enable normal
	/// channel operation.
	TemporaryFailure,
	/// Used to indicate no further channel monitor updates will be allowed (eg we've moved on to a
	/// different watchtower and cannot update with all watchtowers that were previously informed
	/// of this channel). This will force-close the channel in question.
	PermanentFailure,
}

/// Simple trait indicating ability to track a set of ChannelMonitors and multiplex events between
/// them. Generally should be implemented by keeping a local SimpleManyChannelMonitor and passing
/// events to it, while also taking any add_update_monitor events and passing them to some remote
/// server(s).
///
/// Note that any updates to a channel's monitor *must* be applied to each instance of the
/// channel's monitor everywhere (including remote watchtowers) *before* this function returns. If
/// an update occurs and a remote watchtower is left with old state, it may broadcast transactions
/// which we have revoked, allowing our counterparty to claim all funds in the channel!
pub trait ManyChannelMonitor: Send + Sync {
	/// Adds or updates a monitor for the given `funding_txo`.
	///
	/// Implementor must also ensure that the funding_txo outpoint is registered with any relevant
	/// ChainWatchInterfaces such that the provided monitor receives block_connected callbacks with
	/// any spends of it.
	fn add_update_monitor(&self, funding_txo: OutPoint, monitor: ChannelMonitor) -> Result<(), ChannelMonitorUpdateErr>;
}

/// A simple implementation of a ManyChannelMonitor and ChainListener. Can be used to create a
/// watchtower or watch our own channels.
///
/// Note that you must provide your own key by which to refer to channels.
///
/// If you're accepting remote monitors (ie are implementing a watchtower), you must verify that
/// users cannot overwrite a given channel by providing a duplicate key. ie you should probably
/// index by a PublicKey which is required to sign any updates.
///
/// If you're using this for local monitoring of your own channels, you probably want to use
/// `OutPoint` as the key, which will give you a ManyChannelMonitor implementation.
pub struct SimpleManyChannelMonitor<Key> {
	#[cfg(test)] // Used in ChannelManager tests to manipulate channels directly
	pub monitors: Mutex<HashMap<Key, ChannelMonitor>>,
	#[cfg(not(test))]
	monitors: Mutex<HashMap<Key, ChannelMonitor>>,
	chain_monitor: Arc<ChainWatchInterface>,
	broadcaster: Arc<BroadcasterInterface>,
	pending_events: Mutex<Vec<events::Event>>,
	logger: Arc<Logger>,
}

impl<Key : Send + cmp::Eq + hash::Hash> ChainListener for SimpleManyChannelMonitor<Key> {
	fn block_connected(&self, header: &BlockHeader, height: u32, txn_matched: &[&Transaction], _indexes_of_txn_matched: &[u32]) {
		let block_hash = header.bitcoin_hash();
		let mut new_events: Vec<events::Event> = Vec::with_capacity(0);
		{
			let mut monitors = self.monitors.lock().unwrap();
			for monitor in monitors.values_mut() {
				let (txn_outputs, spendable_outputs) = monitor.block_connected(txn_matched, height, &block_hash, &*self.broadcaster);
				if spendable_outputs.len() > 0 {
					new_events.push(events::Event::SpendableOutputs {
						outputs: spendable_outputs,
					});
				}
				for (ref txid, ref outputs) in txn_outputs {
					for (idx, output) in outputs.iter().enumerate() {
						self.chain_monitor.install_watch_outpoint((txid.clone(), idx as u32), &output.script_pubkey);
					}
				}
			}
		}
		let mut pending_events = self.pending_events.lock().unwrap();
		pending_events.append(&mut new_events);
	}

	fn block_disconnected(&self, _: &BlockHeader) { }
}

impl<Key : Send + cmp::Eq + hash::Hash + 'static> SimpleManyChannelMonitor<Key> {
	/// Creates a new object which can be used to monitor several channels given the chain
	/// interface with which to register to receive notifications.
	pub fn new(chain_monitor: Arc<ChainWatchInterface>, broadcaster: Arc<BroadcasterInterface>, logger: Arc<Logger>) -> Arc<SimpleManyChannelMonitor<Key>> {
		let res = Arc::new(SimpleManyChannelMonitor {
			monitors: Mutex::new(HashMap::new()),
			chain_monitor,
			broadcaster,
			pending_events: Mutex::new(Vec::new()),
			logger,
		});
		let weak_res = Arc::downgrade(&res);
		res.chain_monitor.register_listener(weak_res);
		res
	}

	/// Adds or udpates the monitor which monitors the channel referred to by the given key.
	pub fn add_update_monitor_by_key(&self, key: Key, monitor: ChannelMonitor) -> Result<(), HandleError> {
		let mut monitors = self.monitors.lock().unwrap();
		match monitors.get_mut(&key) {
			Some(orig_monitor) => {
				log_trace!(self, "Updating Channel Monitor for channel {}", log_funding_option!(monitor.funding_txo));
				return orig_monitor.insert_combine(monitor);
			},
			None => {}
		};
		match &monitor.funding_txo {
			&None => {
				log_trace!(self, "Got new Channel Monitor for no-funding-set channel (monitoring all txn!)");
				self.chain_monitor.watch_all_txn()
			},
			&Some((ref outpoint, ref script)) => {
				log_trace!(self, "Got new Channel Monitor for channel {}", log_bytes!(outpoint.to_channel_id()[..]));
				self.chain_monitor.install_watch_tx(&outpoint.txid, script);
				self.chain_monitor.install_watch_outpoint((outpoint.txid, outpoint.index as u32), script);
			},
		}
		monitors.insert(key, monitor);
		Ok(())
	}
}

impl ManyChannelMonitor for SimpleManyChannelMonitor<OutPoint> {
	fn add_update_monitor(&self, funding_txo: OutPoint, monitor: ChannelMonitor) -> Result<(), ChannelMonitorUpdateErr> {
		match self.add_update_monitor_by_key(funding_txo, monitor) {
			Ok(_) => Ok(()),
			Err(_) => Err(ChannelMonitorUpdateErr::PermanentFailure),
		}
	}
}

impl<Key : Send + cmp::Eq + hash::Hash> events::EventsProvider for SimpleManyChannelMonitor<Key> {
	fn get_and_clear_pending_events(&self) -> Vec<events::Event> {
		let mut pending_events = self.pending_events.lock().unwrap();
		let mut ret = Vec::new();
		mem::swap(&mut ret, &mut *pending_events);
		ret
	}
}

/// If an HTLC expires within this many blocks, don't try to claim it in a shared transaction,
/// instead claiming it in its own individual transaction.
const CLTV_SHARED_CLAIM_BUFFER: u32 = 12;
/// If an HTLC expires within this many blocks, force-close the channel to broadcast the
/// HTLC-Success transaction.
/// In other words, this is an upper bound on how many blocks we think it can take us to get a
/// transaction confirmed (and we use it in a few more, equivalent, places).
pub(crate) const CLTV_CLAIM_BUFFER: u32 = 6;
/// Number of blocks by which point we expect our counterparty to have seen new blocks on the
/// network and done a full update_fail_htlc/commitment_signed dance (+ we've updated all our
/// copies of ChannelMonitors, including watchtowers).
pub(crate) const HTLC_FAIL_TIMEOUT_BLOCKS: u32 = 3;

#[derive(Clone, PartialEq)]
enum KeyStorage {
	PrivMode {
		revocation_base_key: SecretKey,
		htlc_base_key: SecretKey,
		delayed_payment_base_key: SecretKey,
		payment_base_key: SecretKey,
		shutdown_pubkey: PublicKey,
		prev_latest_per_commitment_point: Option<PublicKey>,
		latest_per_commitment_point: Option<PublicKey>,
	},
	SigsMode {
		revocation_base_key: PublicKey,
		htlc_base_key: PublicKey,
		sigs: HashMap<Sha256dHash, Signature>,
	}
}

#[derive(Clone, PartialEq)]
struct LocalSignedTx {
	/// txid of the transaction in tx, just used to make comparison faster
	txid: Sha256dHash,
	tx: Transaction,
	revocation_key: PublicKey,
	a_htlc_key: PublicKey,
	b_htlc_key: PublicKey,
	delayed_payment_key: PublicKey,
	feerate_per_kw: u64,
	htlc_outputs: Vec<(HTLCOutputInCommitment, Signature, Signature)>,
}

const SERIALIZATION_VERSION: u8 = 1;
const MIN_SERIALIZATION_VERSION: u8 = 1;

/// A ChannelMonitor handles chain events (blocks connected and disconnected) and generates
/// on-chain transactions to ensure no loss of funds occurs.
///
/// You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date
/// information and are actively monitoring the chain.
#[derive(Clone)]
pub struct ChannelMonitor {
	funding_txo: Option<(OutPoint, Script)>,
	commitment_transaction_number_obscure_factor: u64,

	key_storage: KeyStorage,
	their_htlc_base_key: Option<PublicKey>,
	their_delayed_payment_base_key: Option<PublicKey>,
	// first is the idx of the first of the two revocation points
	their_cur_revocation_points: Option<(u64, PublicKey, Option<PublicKey>)>,

	our_to_self_delay: u16,
	their_to_self_delay: Option<u16>,

	old_secrets: [([u8; 32], u64); 49],
	remote_claimable_outpoints: HashMap<Sha256dHash, Vec<HTLCOutputInCommitment>>,
	/// We cannot identify HTLC-Success or HTLC-Timeout transactions by themselves on the chain.
	/// Nor can we figure out their commitment numbers without the commitment transaction they are
	/// spending. Thus, in order to claim them via revocation key, we track all the remote
	/// commitment transactions which we find on-chain, mapping them to the commitment number which
	/// can be used to derive the revocation key and claim the transactions.
	remote_commitment_txn_on_chain: HashMap<Sha256dHash, (u64, Vec<Script>)>,
	/// Cache used to make pruning of payment_preimages faster.
	/// Maps payment_hash values to commitment numbers for remote transactions for non-revoked
	/// remote transactions (ie should remain pretty small).
	/// Serialized to disk but should generally not be sent to Watchtowers.
	remote_hash_commitment_number: HashMap<[u8; 32], u64>,

	// We store two local commitment transactions to avoid any race conditions where we may update
	// some monitors (potentially on watchtowers) but then fail to update others, resulting in the
	// various monitors for one channel being out of sync, and us broadcasting a local
	// transaction for which we have deleted claim information on some watchtowers.
	prev_local_signed_commitment_tx: Option<LocalSignedTx>,
	current_local_signed_commitment_tx: Option<LocalSignedTx>,

	// Used just for ChannelManager to make sure it has the latest channel data during
	// deserialization
	current_remote_commitment_number: u64,

	payment_preimages: HashMap<[u8; 32], [u8; 32]>,

	destination_script: Script,

	// We simply modify last_block_hash in Channel's block_connected so that serialization is
	// consistent but hopefully the users' copy handles block_connected in a consistent way.
	// (we do *not*, however, update them in insert_combine to ensure any local user copies keep
	// their last_block_hash from its state and not based on updated copies that didn't run through
	// the full block_connected).
	pub(crate) last_block_hash: Sha256dHash,
	secp_ctx: Secp256k1<secp256k1::All>, //TODO: dedup this a bit...
	logger: Arc<Logger>,
}

#[cfg(any(test, feature = "fuzztarget"))]
/// Used only in testing and fuzztarget to check serialization roundtrips don't change the
/// underlying object
impl PartialEq for ChannelMonitor {
	fn eq(&self, other: &Self) -> bool {
		if self.funding_txo != other.funding_txo ||
			self.commitment_transaction_number_obscure_factor != other.commitment_transaction_number_obscure_factor ||
			self.key_storage != other.key_storage ||
			self.their_htlc_base_key != other.their_htlc_base_key ||
			self.their_delayed_payment_base_key != other.their_delayed_payment_base_key ||
			self.their_cur_revocation_points != other.their_cur_revocation_points ||
			self.our_to_self_delay != other.our_to_self_delay ||
			self.their_to_self_delay != other.their_to_self_delay ||
			self.remote_claimable_outpoints != other.remote_claimable_outpoints ||
			self.remote_commitment_txn_on_chain != other.remote_commitment_txn_on_chain ||
			self.remote_hash_commitment_number != other.remote_hash_commitment_number ||
			self.prev_local_signed_commitment_tx != other.prev_local_signed_commitment_tx ||
			self.current_remote_commitment_number != other.current_remote_commitment_number ||
			self.current_local_signed_commitment_tx != other.current_local_signed_commitment_tx ||
			self.payment_preimages != other.payment_preimages ||
			self.destination_script != other.destination_script
		{
			false
		} else {
			for (&(ref secret, ref idx), &(ref o_secret, ref o_idx)) in self.old_secrets.iter().zip(other.old_secrets.iter()) {
				if secret != o_secret || idx != o_idx {
					return false
				}
			}
			true
		}
	}
}

impl ChannelMonitor {
	pub(super) fn new(revocation_base_key: &SecretKey, delayed_payment_base_key: &SecretKey, htlc_base_key: &SecretKey, payment_base_key: &SecretKey, shutdown_pubkey: &PublicKey, our_to_self_delay: u16, destination_script: Script, logger: Arc<Logger>) -> ChannelMonitor {
		ChannelMonitor {
			funding_txo: None,
			commitment_transaction_number_obscure_factor: 0,

			key_storage: KeyStorage::PrivMode {
				revocation_base_key: revocation_base_key.clone(),
				htlc_base_key: htlc_base_key.clone(),
				delayed_payment_base_key: delayed_payment_base_key.clone(),
				payment_base_key: payment_base_key.clone(),
				shutdown_pubkey: shutdown_pubkey.clone(),
				prev_latest_per_commitment_point: None,
				latest_per_commitment_point: None,
			},
			their_htlc_base_key: None,
			their_delayed_payment_base_key: None,
			their_cur_revocation_points: None,

			our_to_self_delay: our_to_self_delay,
			their_to_self_delay: None,

			old_secrets: [([0; 32], 1 << 48); 49],
			remote_claimable_outpoints: HashMap::new(),
			remote_commitment_txn_on_chain: HashMap::new(),
			remote_hash_commitment_number: HashMap::new(),

			prev_local_signed_commitment_tx: None,
			current_local_signed_commitment_tx: None,
			current_remote_commitment_number: 1 << 48,

			payment_preimages: HashMap::new(),
			destination_script: destination_script,

			last_block_hash: Default::default(),
			secp_ctx: Secp256k1::new(),
			logger,
		}
	}

	#[inline]
	fn place_secret(idx: u64) -> u8 {
		for i in 0..48 {
			if idx & (1 << i) == (1 << i) {
				return i
			}
		}
		48
	}

	#[inline]
	fn derive_secret(secret: [u8; 32], bits: u8, idx: u64) -> [u8; 32] {
		let mut res: [u8; 32] = secret;
		for i in 0..bits {
			let bitpos = bits - 1 - i;
			if idx & (1 << bitpos) == (1 << bitpos) {
				res[(bitpos / 8) as usize] ^= 1 << (bitpos & 7);
				let mut sha = Sha256::new();
				sha.input(&res);
				sha.result(&mut res);
			}
		}
		res
	}

	/// Inserts a revocation secret into this channel monitor. Prunes old preimages if neither
	/// needed by local commitment transactions HTCLs nor by remote ones. Unless we haven't already seen remote
	/// commitment transaction's secret, they are de facto pruned (we can use revocation key).
	pub(super) fn provide_secret(&mut self, idx: u64, secret: [u8; 32]) -> Result<(), HandleError> {
		let pos = ChannelMonitor::place_secret(idx);
		for i in 0..pos {
			let (old_secret, old_idx) = self.old_secrets[i as usize];
			if ChannelMonitor::derive_secret(secret, pos, old_idx) != old_secret {
				return Err(HandleError{err: "Previous secret did not match new one", action: None})
			}
		}
		self.old_secrets[pos as usize] = (secret, idx);

		if !self.payment_preimages.is_empty() {
			let local_signed_commitment_tx = self.current_local_signed_commitment_tx.as_ref().expect("Channel needs at least an initial commitment tx !");
			let prev_local_signed_commitment_tx = self.prev_local_signed_commitment_tx.as_ref();
			let min_idx = self.get_min_seen_secret();
			let remote_hash_commitment_number = &mut self.remote_hash_commitment_number;

			self.payment_preimages.retain(|&k, _| {
				for &(ref htlc, _, _) in &local_signed_commitment_tx.htlc_outputs {
					if k == htlc.payment_hash {
						return true
					}
				}
				if let Some(prev_local_commitment_tx) = prev_local_signed_commitment_tx {
					for &(ref htlc, _, _) in prev_local_commitment_tx.htlc_outputs.iter() {
						if k == htlc.payment_hash {
							return true
						}
					}
				}
				let contains = if let Some(cn) = remote_hash_commitment_number.get(&k) {
					if *cn < min_idx {
						return true
					}
					true
				} else { false };
				if contains {
					remote_hash_commitment_number.remove(&k);
				}
				false
			});
		}

		Ok(())
	}

	/// Tracks the next revocation point which may be required to claim HTLC outputs which we know
	/// the preimage of in case the remote end force-closes using their latest state. When called at
	/// channel opening revocation point is the CURRENT one used for first commitment tx. Needed in case of sizeable push_msat.
	pub(super) fn provide_their_next_revocation_point(&mut self, their_next_revocation_point: Option<(u64, PublicKey)>) {
		if let Some(new_revocation_point) = their_next_revocation_point {
			match self.their_cur_revocation_points {
				Some(old_points) => {
					if old_points.0 == new_revocation_point.0 + 1 {
						self.their_cur_revocation_points = Some((old_points.0, old_points.1, Some(new_revocation_point.1)));
					} else if old_points.0 == new_revocation_point.0 + 2 {
						if let Some(old_second_point) = old_points.2 {
							self.their_cur_revocation_points = Some((old_points.0 - 1, old_second_point, Some(new_revocation_point.1)));
						} else {
							self.their_cur_revocation_points = Some((new_revocation_point.0, new_revocation_point.1, None));
						}
					} else {
						self.their_cur_revocation_points = Some((new_revocation_point.0, new_revocation_point.1, None));
					}
				},
				None => {
					self.their_cur_revocation_points = Some((new_revocation_point.0, new_revocation_point.1, None));
				}
			}
		}
	}

	/// Informs this monitor of the latest remote (ie non-broadcastable) commitment transaction.
	/// The monitor watches for it to be broadcasted and then uses the HTLC information (and
	/// possibly future revocation/preimage information) to claim outputs where possible.
	/// We cache also the mapping hash:commitment number to lighten pruning of old preimages by watchtowers.
	pub(super) fn provide_latest_remote_commitment_tx_info(&mut self, unsigned_commitment_tx: &Transaction, htlc_outputs: Vec<HTLCOutputInCommitment>, commitment_number: u64) {
		// TODO: Encrypt the htlc_outputs data with the single-hash of the commitment transaction
		// so that a remote monitor doesn't learn anything unless there is a malicious close.
		// (only maybe, sadly we cant do the same for local info, as we need to be aware of
		// timeouts)
		for htlc in &htlc_outputs {
			self.remote_hash_commitment_number.insert(htlc.payment_hash, commitment_number);
		}
		self.remote_claimable_outpoints.insert(unsigned_commitment_tx.txid(), htlc_outputs);
		self.current_remote_commitment_number = commitment_number;
	}

	/// Informs this monitor of the latest local (ie broadcastable) commitment transaction. The
	/// monitor watches for timeouts and may broadcast it if we approach such a timeout. Thus, it
	/// is important that any clones of this channel monitor (including remote clones) by kept
	/// up-to-date as our local commitment transaction is updated.
	/// Panics if set_their_to_self_delay has never been called.
	/// Also update KeyStorage with latest local per_commitment_point to derive local_delayedkey in
	/// case of onchain HTLC tx
	pub(super) fn provide_latest_local_commitment_tx_info(&mut self, signed_commitment_tx: Transaction, local_keys: chan_utils::TxCreationKeys, feerate_per_kw: u64, htlc_outputs: Vec<(HTLCOutputInCommitment, Signature, Signature)>) {
		assert!(self.their_to_self_delay.is_some());
		self.prev_local_signed_commitment_tx = self.current_local_signed_commitment_tx.take();
		self.current_local_signed_commitment_tx = Some(LocalSignedTx {
			txid: signed_commitment_tx.txid(),
			tx: signed_commitment_tx,
			revocation_key: local_keys.revocation_key,
			a_htlc_key: local_keys.a_htlc_key,
			b_htlc_key: local_keys.b_htlc_key,
			delayed_payment_key: local_keys.a_delayed_payment_key,
			feerate_per_kw,
			htlc_outputs,
		});
		self.key_storage = if let KeyStorage::PrivMode { ref revocation_base_key, ref htlc_base_key, ref delayed_payment_base_key, ref payment_base_key, ref shutdown_pubkey, ref latest_per_commitment_point, .. } = self.key_storage {
			KeyStorage::PrivMode {
				revocation_base_key: *revocation_base_key,
				htlc_base_key: *htlc_base_key,
				delayed_payment_base_key: *delayed_payment_base_key,
				payment_base_key: *payment_base_key,
				shutdown_pubkey: *shutdown_pubkey,
				prev_latest_per_commitment_point: *latest_per_commitment_point,
				latest_per_commitment_point: Some(local_keys.per_commitment_point),
			}
		} else { unimplemented!(); };
	}

	/// Provides a payment_hash->payment_preimage mapping. Will be automatically pruned when all
	/// commitment_tx_infos which contain the payment hash have been revoked.
	pub(super) fn provide_payment_preimage(&mut self, payment_hash: &[u8; 32], payment_preimage: &[u8; 32]) {
		self.payment_preimages.insert(payment_hash.clone(), payment_preimage.clone());
	}

	/// Combines this ChannelMonitor with the information contained in the other ChannelMonitor.
	/// After a successful call this ChannelMonitor is up-to-date and is safe to use to monitor the
	/// chain for new blocks/transactions.
	pub fn insert_combine(&mut self, mut other: ChannelMonitor) -> Result<(), HandleError> {
		if self.funding_txo.is_some() {
			// We should be able to compare the entire funding_txo, but in fuzztarget its trivially
			// easy to collide the funding_txo hash and have a different scriptPubKey.
			if other.funding_txo.is_some() && other.funding_txo.as_ref().unwrap().0 != self.funding_txo.as_ref().unwrap().0 {
				return Err(HandleError{err: "Funding transaction outputs are not identical!", action: None});
			}
		} else {
			self.funding_txo = other.funding_txo.take();
		}
		let other_min_secret = other.get_min_seen_secret();
		let our_min_secret = self.get_min_seen_secret();
		if our_min_secret > other_min_secret {
			self.provide_secret(other_min_secret, other.get_secret(other_min_secret).unwrap())?;
		}
		// TODO: We should use current_remote_commitment_number and the commitment number out of
		// local transactions to decide how to merge
		if our_min_secret >= other_min_secret {
			self.their_cur_revocation_points = other.their_cur_revocation_points;
			for (txid, htlcs) in other.remote_claimable_outpoints.drain() {
				self.remote_claimable_outpoints.insert(txid, htlcs);
			}
			if let Some(local_tx) = other.prev_local_signed_commitment_tx {
				self.prev_local_signed_commitment_tx = Some(local_tx);
			}
			if let Some(local_tx) = other.current_local_signed_commitment_tx {
				self.current_local_signed_commitment_tx = Some(local_tx);
			}
			self.payment_preimages = other.payment_preimages;
		}
		self.current_remote_commitment_number = cmp::min(self.current_remote_commitment_number, other.current_remote_commitment_number);
		Ok(())
	}

	/// Panics if commitment_transaction_number_obscure_factor doesn't fit in 48 bits
	pub(super) fn set_commitment_obscure_factor(&mut self, commitment_transaction_number_obscure_factor: u64) {
		assert!(commitment_transaction_number_obscure_factor < (1 << 48));
		self.commitment_transaction_number_obscure_factor = commitment_transaction_number_obscure_factor;
	}

	/// Allows this monitor to scan only for transactions which are applicable. Note that this is
	/// optional, without it this monitor cannot be used in an SPV client, but you may wish to
	/// avoid this (or call unset_funding_info) on a monitor you wish to send to a watchtower as it
	/// provides slightly better privacy.
	/// It's the responsibility of the caller to register outpoint and script with passing the former
	/// value as key to add_update_monitor.
	pub(super) fn set_funding_info(&mut self, funding_info: (OutPoint, Script)) {
		self.funding_txo = Some(funding_info);
	}

	/// We log these base keys at channel opening to being able to rebuild redeemscript in case of leaked revoked commit tx
	pub(super) fn set_their_base_keys(&mut self, their_htlc_base_key: &PublicKey, their_delayed_payment_base_key: &PublicKey) {
		self.their_htlc_base_key = Some(their_htlc_base_key.clone());
		self.their_delayed_payment_base_key = Some(their_delayed_payment_base_key.clone());
	}

	pub(super) fn set_their_to_self_delay(&mut self, their_to_self_delay: u16) {
		self.their_to_self_delay = Some(their_to_self_delay);
	}

	pub(super) fn unset_funding_info(&mut self) {
		self.funding_txo = None;
	}

	/// Gets the funding transaction outpoint of the channel this ChannelMonitor is monitoring for.
	pub fn get_funding_txo(&self) -> Option<OutPoint> {
		match self.funding_txo {
			Some((outpoint, _)) => Some(outpoint),
			None => None
		}
	}

	/// Gets the sets of all outpoints which this ChannelMonitor expects to hear about spends of.
	/// Generally useful when deserializing as during normal operation the return values of
	/// block_connected are sufficient to ensure all relevant outpoints are being monitored (note
	/// that the get_funding_txo outpoint and transaction must also be monitored for!).
	pub fn get_monitored_outpoints(&self) -> Vec<(Sha256dHash, u32, &Script)> {
		let mut res = Vec::with_capacity(self.remote_commitment_txn_on_chain.len() * 2);
		for (ref txid, &(_, ref outputs)) in self.remote_commitment_txn_on_chain.iter() {
			for (idx, output) in outputs.iter().enumerate() {
				res.push(((*txid).clone(), idx as u32, output));
			}
		}
		res
	}

	/// Serializes into a vec, with various modes for the exposed pub fns
	fn write<W: Writer>(&self, writer: &mut W, for_local_storage: bool) -> Result<(), ::std::io::Error> {
		//TODO: We still write out all the serialization here manually instead of using the fancy
		//serialization framework we have, we should migrate things over to it.
		writer.write_all(&[SERIALIZATION_VERSION; 1])?;
		writer.write_all(&[MIN_SERIALIZATION_VERSION; 1])?;

		match &self.funding_txo {
			&Some((ref outpoint, ref script)) => {
				writer.write_all(&outpoint.txid[..])?;
				writer.write_all(&byte_utils::be16_to_array(outpoint.index))?;
				script.write(writer)?;
			},
			&None => {
				// We haven't even been initialized...not sure why anyone is serializing us, but
				// not much to give them.
				return Ok(());
			},
		}

		// Set in initial Channel-object creation, so should always be set by now:
		U48(self.commitment_transaction_number_obscure_factor).write(writer)?;

		match self.key_storage {
			KeyStorage::PrivMode { ref revocation_base_key, ref htlc_base_key, ref delayed_payment_base_key, ref payment_base_key, ref shutdown_pubkey, ref prev_latest_per_commitment_point, ref latest_per_commitment_point } => {
				writer.write_all(&[0; 1])?;
				writer.write_all(&revocation_base_key[..])?;
				writer.write_all(&htlc_base_key[..])?;
				writer.write_all(&delayed_payment_base_key[..])?;
				writer.write_all(&payment_base_key[..])?;
				writer.write_all(&shutdown_pubkey.serialize())?;
				if let Some(ref prev_latest_per_commitment_point) = *prev_latest_per_commitment_point {
					writer.write_all(&[1; 1])?;
					writer.write_all(&prev_latest_per_commitment_point.serialize())?;
				} else {
					writer.write_all(&[0; 1])?;
				}
				if let Some(ref latest_per_commitment_point) = *latest_per_commitment_point {
					writer.write_all(&[1; 1])?;
					writer.write_all(&latest_per_commitment_point.serialize())?;
				} else {
					writer.write_all(&[0; 1])?;
				}

			},
			KeyStorage::SigsMode { .. } => unimplemented!(),
		}

		writer.write_all(&self.their_htlc_base_key.as_ref().unwrap().serialize())?;
		writer.write_all(&self.their_delayed_payment_base_key.as_ref().unwrap().serialize())?;

		match self.their_cur_revocation_points {
			Some((idx, pubkey, second_option)) => {
				writer.write_all(&byte_utils::be48_to_array(idx))?;
				writer.write_all(&pubkey.serialize())?;
				match second_option {
					Some(second_pubkey) => {
						writer.write_all(&second_pubkey.serialize())?;
					},
					None => {
						writer.write_all(&[0; 33])?;
					},
				}
			},
			None => {
				writer.write_all(&byte_utils::be48_to_array(0))?;
			},
		}

		writer.write_all(&byte_utils::be16_to_array(self.our_to_self_delay))?;
		writer.write_all(&byte_utils::be16_to_array(self.their_to_self_delay.unwrap()))?;

		for &(ref secret, ref idx) in self.old_secrets.iter() {
			writer.write_all(secret)?;
			writer.write_all(&byte_utils::be64_to_array(*idx))?;
		}

		macro_rules! serialize_htlc_in_commitment {
			($htlc_output: expr) => {
				writer.write_all(&[$htlc_output.offered as u8; 1])?;
				writer.write_all(&byte_utils::be64_to_array($htlc_output.amount_msat))?;
				writer.write_all(&byte_utils::be32_to_array($htlc_output.cltv_expiry))?;
				writer.write_all(&$htlc_output.payment_hash)?;
				writer.write_all(&byte_utils::be32_to_array($htlc_output.transaction_output_index))?;
			}
		}

		writer.write_all(&byte_utils::be64_to_array(self.remote_claimable_outpoints.len() as u64))?;
		for (ref txid, ref htlc_outputs) in self.remote_claimable_outpoints.iter() {
			writer.write_all(&txid[..])?;
			writer.write_all(&byte_utils::be64_to_array(htlc_outputs.len() as u64))?;
			for htlc_output in htlc_outputs.iter() {
				serialize_htlc_in_commitment!(htlc_output);
			}
		}

		writer.write_all(&byte_utils::be64_to_array(self.remote_commitment_txn_on_chain.len() as u64))?;
		for (ref txid, &(commitment_number, ref txouts)) in self.remote_commitment_txn_on_chain.iter() {
			writer.write_all(&txid[..])?;
			writer.write_all(&byte_utils::be48_to_array(commitment_number))?;
			(txouts.len() as u64).write(writer)?;
			for script in txouts.iter() {
				script.write(writer)?;
			}
		}

		if for_local_storage {
			writer.write_all(&byte_utils::be64_to_array(self.remote_hash_commitment_number.len() as u64))?;
			for (ref payment_hash, commitment_number) in self.remote_hash_commitment_number.iter() {
				writer.write_all(*payment_hash)?;
				writer.write_all(&byte_utils::be48_to_array(*commitment_number))?;
			}
		} else {
			writer.write_all(&byte_utils::be64_to_array(0))?;
		}

		macro_rules! serialize_local_tx {
			($local_tx: expr) => {
				if let Err(e) = $local_tx.tx.consensus_encode(&mut WriterWriteAdaptor(writer)) {
					match e {
						encode::Error::Io(e) => return Err(e),
						_ => panic!("local tx must have been well-formed!"),
					}
				}

				writer.write_all(&$local_tx.revocation_key.serialize())?;
				writer.write_all(&$local_tx.a_htlc_key.serialize())?;
				writer.write_all(&$local_tx.b_htlc_key.serialize())?;
				writer.write_all(&$local_tx.delayed_payment_key.serialize())?;

				writer.write_all(&byte_utils::be64_to_array($local_tx.feerate_per_kw))?;
				writer.write_all(&byte_utils::be64_to_array($local_tx.htlc_outputs.len() as u64))?;
				for &(ref htlc_output, ref their_sig, ref our_sig) in $local_tx.htlc_outputs.iter() {
					serialize_htlc_in_commitment!(htlc_output);
					writer.write_all(&their_sig.serialize_compact(&self.secp_ctx))?;
					writer.write_all(&our_sig.serialize_compact(&self.secp_ctx))?;
				}
			}
		}

		if let Some(ref prev_local_tx) = self.prev_local_signed_commitment_tx {
			writer.write_all(&[1; 1])?;
			serialize_local_tx!(prev_local_tx);
		} else {
			writer.write_all(&[0; 1])?;
		}

		if let Some(ref cur_local_tx) = self.current_local_signed_commitment_tx {
			writer.write_all(&[1; 1])?;
			serialize_local_tx!(cur_local_tx);
		} else {
			writer.write_all(&[0; 1])?;
		}

		if for_local_storage {
			writer.write_all(&byte_utils::be48_to_array(self.current_remote_commitment_number))?;
		} else {
			writer.write_all(&byte_utils::be48_to_array(0))?;
		}

		writer.write_all(&byte_utils::be64_to_array(self.payment_preimages.len() as u64))?;
		for payment_preimage in self.payment_preimages.values() {
			writer.write_all(payment_preimage)?;
		}

		self.last_block_hash.write(writer)?;
		self.destination_script.write(writer)?;

		Ok(())
	}

	/// Writes this monitor into the given writer, suitable for writing to disk.
	///
	/// Note that the deserializer is only implemented for (Sha256dHash, ChannelMonitor), which
	/// tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
	/// the "reorg path" (ie not just starting at the same height but starting at the highest
	/// common block that appears on your best chain as well as on the chain which contains the
	/// last block hash returned) upon deserializing the object!
	pub fn write_for_disk<W: Writer>(&self, writer: &mut W) -> Result<(), ::std::io::Error> {
		self.write(writer, true)
	}

	/// Encodes this monitor into the given writer, suitable for sending to a remote watchtower
	///
	/// Note that the deserializer is only implemented for (Sha256dHash, ChannelMonitor), which
	/// tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
	/// the "reorg path" (ie not just starting at the same height but starting at the highest
	/// common block that appears on your best chain as well as on the chain which contains the
	/// last block hash returned) upon deserializing the object!
	pub fn write_for_watchtower<W: Writer>(&self, writer: &mut W) -> Result<(), ::std::io::Error> {
		self.write(writer, false)
	}

	//TODO: Functions to serialize/deserialize (with different forms depending on which information
	//we want to leave out (eg funding_txo, etc).

	/// Can only fail if idx is < get_min_seen_secret
	pub(super) fn get_secret(&self, idx: u64) -> Result<[u8; 32], HandleError> {
		for i in 0..self.old_secrets.len() {
			if (idx & (!((1 << i) - 1))) == self.old_secrets[i].1 {
				return Ok(ChannelMonitor::derive_secret(self.old_secrets[i].0, i as u8, idx))
			}
		}
		assert!(idx < self.get_min_seen_secret());
		Err(HandleError{err: "idx too low", action: None})
	}

	pub(super) fn get_min_seen_secret(&self) -> u64 {
		//TODO This can be optimized?
		let mut min = 1 << 48;
		for &(_, idx) in self.old_secrets.iter() {
			if idx < min {
				min = idx;
			}
		}
		min
	}

	pub(super) fn get_cur_remote_commitment_number(&self) -> u64 {
		self.current_remote_commitment_number
	}

	pub(super) fn get_cur_local_commitment_number(&self) -> u64 {
		if let &Some(ref local_tx) = &self.current_local_signed_commitment_tx {
			0xffff_ffff_ffff - ((((local_tx.tx.input[0].sequence as u64 & 0xffffff) << 3*8) | (local_tx.tx.lock_time as u64 & 0xffffff)) ^ self.commitment_transaction_number_obscure_factor)
		} else { 0xffff_ffff_ffff }
	}

	/// Attempts to claim a remote commitment transaction's outputs using the revocation key and
	/// data in remote_claimable_outpoints. Will directly claim any HTLC outputs which expire at a
	/// height > height + CLTV_SHARED_CLAIM_BUFFER. In any case, will install monitoring for
	/// HTLC-Success/HTLC-Timeout transactions.
	fn check_spend_remote_transaction(&mut self, tx: &Transaction, height: u32) -> (Vec<Transaction>, (Sha256dHash, Vec<TxOut>), Vec<SpendableOutputDescriptor>) {
		// Most secp and related errors trying to create keys means we have no hope of constructing
		// a spend transaction...so we return no transactions to broadcast
		let mut txn_to_broadcast = Vec::new();
		let mut watch_outputs = Vec::new();
		let mut spendable_outputs = Vec::new();

		let commitment_txid = tx.txid(); //TODO: This is gonna be a performance bottleneck for watchtowers!
		let per_commitment_option = self.remote_claimable_outpoints.get(&commitment_txid);

		macro_rules! ignore_error {
			( $thing : expr ) => {
				match $thing {
					Ok(a) => a,
					Err(_) => return (txn_to_broadcast, (commitment_txid, watch_outputs), spendable_outputs)
				}
			};
		}

		let commitment_number = 0xffffffffffff - ((((tx.input[0].sequence as u64 & 0xffffff) << 3*8) | (tx.lock_time as u64 & 0xffffff)) ^ self.commitment_transaction_number_obscure_factor);
		if commitment_number >= self.get_min_seen_secret() {
			let secret = self.get_secret(commitment_number).unwrap();
			let per_commitment_key = ignore_error!(SecretKey::from_slice(&self.secp_ctx, &secret));
			let (revocation_pubkey, b_htlc_key) = match self.key_storage {
				KeyStorage::PrivMode { ref revocation_base_key, ref htlc_base_key, .. } => {
					let per_commitment_point = PublicKey::from_secret_key(&self.secp_ctx, &per_commitment_key);
					(ignore_error!(chan_utils::derive_public_revocation_key(&self.secp_ctx, &per_commitment_point, &PublicKey::from_secret_key(&self.secp_ctx, &revocation_base_key))),
					ignore_error!(chan_utils::derive_public_key(&self.secp_ctx, &per_commitment_point, &PublicKey::from_secret_key(&self.secp_ctx, &htlc_base_key))))
				},
				KeyStorage::SigsMode { ref revocation_base_key, ref htlc_base_key, .. } => {
					let per_commitment_point = PublicKey::from_secret_key(&self.secp_ctx, &per_commitment_key);
					(ignore_error!(chan_utils::derive_public_revocation_key(&self.secp_ctx, &per_commitment_point, &revocation_base_key)),
					ignore_error!(chan_utils::derive_public_key(&self.secp_ctx, &per_commitment_point, &htlc_base_key)))
				},
			};
			let delayed_key = ignore_error!(chan_utils::derive_public_key(&self.secp_ctx, &PublicKey::from_secret_key(&self.secp_ctx, &per_commitment_key), &self.their_delayed_payment_base_key.unwrap()));
			let a_htlc_key = match self.their_htlc_base_key {
				None => return (txn_to_broadcast, (commitment_txid, watch_outputs), spendable_outputs),
				Some(their_htlc_base_key) => ignore_error!(chan_utils::derive_public_key(&self.secp_ctx, &PublicKey::from_secret_key(&self.secp_ctx, &per_commitment_key), &their_htlc_base_key)),
			};

			let revokeable_redeemscript = chan_utils::get_revokeable_redeemscript(&revocation_pubkey, self.our_to_self_delay, &delayed_key);
			let revokeable_p2wsh = revokeable_redeemscript.to_v0_p2wsh();

			let mut total_value = 0;
			let mut values = Vec::new();
			let mut inputs = Vec::new();
			let mut htlc_idxs = Vec::new();

			for (idx, outp) in tx.output.iter().enumerate() {
				if outp.script_pubkey == revokeable_p2wsh {
					inputs.push(TxIn {
						previous_output: BitcoinOutPoint {
							txid: commitment_txid,
							vout: idx as u32,
						},
						script_sig: Script::new(),
						sequence: 0xfffffffd,
						witness: Vec::new(),
					});
					htlc_idxs.push(None);
					values.push(outp.value);
					total_value += outp.value;
				} else if outp.script_pubkey.is_v0_p2wpkh() {
					match self.key_storage {
						KeyStorage::PrivMode { ref payment_base_key, .. } => {
							let per_commitment_point = PublicKey::from_secret_key(&self.secp_ctx, &per_commitment_key);
							if let Ok(local_key) = chan_utils::derive_private_key(&self.secp_ctx, &per_commitment_point, &payment_base_key) {
								spendable_outputs.push(SpendableOutputDescriptor::DynamicOutputP2WPKH {
									outpoint: BitcoinOutPoint { txid: commitment_txid, vout: idx as u32 },
									key: local_key,
									output: outp.clone(),
								});
							}
						}
						KeyStorage::SigsMode { .. } => {
							//TODO: we need to ensure an offline client will generate the event when it
							// cames back online after only the watchtower saw the transaction
						}
					}
				}
			}

			macro_rules! sign_input {
				($sighash_parts: expr, $input: expr, $htlc_idx: expr, $amount: expr) => {
					{
						let (sig, redeemscript) = match self.key_storage {
							KeyStorage::PrivMode { ref revocation_base_key, .. } => {
								let redeemscript = if $htlc_idx.is_none() { revokeable_redeemscript.clone() } else {
									let htlc = &per_commitment_option.unwrap()[$htlc_idx.unwrap()];
									chan_utils::get_htlc_redeemscript_with_explicit_keys(htlc, &a_htlc_key, &b_htlc_key, &revocation_pubkey)
								};
								let sighash = ignore_error!(Message::from_slice(&$sighash_parts.sighash_all(&$input, &redeemscript, $amount)[..]));
								let revocation_key = ignore_error!(chan_utils::derive_private_revocation_key(&self.secp_ctx, &per_commitment_key, &revocation_base_key));
								(self.secp_ctx.sign(&sighash, &revocation_key), redeemscript)
							},
							KeyStorage::SigsMode { .. } => {
								unimplemented!();
							}
						};
						$input.witness.push(sig.serialize_der(&self.secp_ctx).to_vec());
						$input.witness[0].push(SigHashType::All as u8);
						if $htlc_idx.is_none() {
							$input.witness.push(vec!(1));
						} else {
							$input.witness.push(revocation_pubkey.serialize().to_vec());
						}
						$input.witness.push(redeemscript.into_bytes());
					}
				}
			}

			if let Some(per_commitment_data) = per_commitment_option {
				inputs.reserve_exact(per_commitment_data.len());

				for (idx, htlc) in per_commitment_data.iter().enumerate() {
					let expected_script = chan_utils::get_htlc_redeemscript_with_explicit_keys(&htlc, &a_htlc_key, &b_htlc_key, &revocation_pubkey);
					if htlc.transaction_output_index as usize >= tx.output.len() ||
							tx.output[htlc.transaction_output_index as usize].value != htlc.amount_msat / 1000 ||
							tx.output[htlc.transaction_output_index as usize].script_pubkey != expected_script.to_v0_p2wsh() {
						return (txn_to_broadcast, (commitment_txid, watch_outputs), spendable_outputs); // Corrupted per_commitment_data, fuck this user
					}
					let input = TxIn {
						previous_output: BitcoinOutPoint {
							txid: commitment_txid,
							vout: htlc.transaction_output_index,
						},
						script_sig: Script::new(),
						sequence: 0xfffffffd,
						witness: Vec::new(),
					};
					if htlc.cltv_expiry > height + CLTV_SHARED_CLAIM_BUFFER {
						inputs.push(input);
						htlc_idxs.push(Some(idx));
						values.push(tx.output[htlc.transaction_output_index as usize].value);
						total_value += htlc.amount_msat / 1000;
					} else {
						let mut single_htlc_tx = Transaction {
							version: 2,
							lock_time: 0,
							input: vec![input],
							output: vec!(TxOut {
								script_pubkey: self.destination_script.clone(),
								value: htlc.amount_msat / 1000, //TODO: - fee
							}),
						};
						let sighash_parts = bip143::SighashComponents::new(&single_htlc_tx);
						sign_input!(sighash_parts, single_htlc_tx.input[0], Some(idx), htlc.amount_msat / 1000);
						txn_to_broadcast.push(single_htlc_tx);
					}
				}
			}

			if !inputs.is_empty() || !txn_to_broadcast.is_empty() { // ie we're confident this is actually ours
				// We're definitely a remote commitment transaction!
				watch_outputs.append(&mut tx.output.clone());
				self.remote_commitment_txn_on_chain.insert(commitment_txid, (commitment_number, tx.output.iter().map(|output| { output.script_pubkey.clone() }).collect()));
			}
			if inputs.is_empty() { return (txn_to_broadcast, (commitment_txid, watch_outputs), spendable_outputs); } // Nothing to be done...probably a false positive/local tx

			let outputs = vec!(TxOut {
				script_pubkey: self.destination_script.clone(),
				value: total_value, //TODO: - fee
			});
			let mut spend_tx = Transaction {
				version: 2,
				lock_time: 0,
				input: inputs,
				output: outputs,
			};

			let mut values_drain = values.drain(..);
			let sighash_parts = bip143::SighashComponents::new(&spend_tx);

			for (input, htlc_idx) in spend_tx.input.iter_mut().zip(htlc_idxs.iter()) {
				let value = values_drain.next().unwrap();
				sign_input!(sighash_parts, input, htlc_idx, value);
			}

			spendable_outputs.push(SpendableOutputDescriptor::StaticOutput {
				outpoint: BitcoinOutPoint { txid: spend_tx.txid(), vout: 0 },
				output: spend_tx.output[0].clone(),
			});
			txn_to_broadcast.push(spend_tx);
		} else if let Some(per_commitment_data) = per_commitment_option {
			// While this isn't useful yet, there is a potential race where if a counterparty
			// revokes a state at the same time as the commitment transaction for that state is
			// confirmed, and the watchtower receives the block before the user, the user could
			// upload a new ChannelMonitor with the revocation secret but the watchtower has
			// already processed the block, resulting in the remote_commitment_txn_on_chain entry
			// not being generated by the above conditional. Thus, to be safe, we go ahead and
			// insert it here.
			watch_outputs.append(&mut tx.output.clone());
			self.remote_commitment_txn_on_chain.insert(commitment_txid, (commitment_number, tx.output.iter().map(|output| { output.script_pubkey.clone() }).collect()));

			if let Some(revocation_points) = self.their_cur_revocation_points {
				let revocation_point_option =
					if revocation_points.0 == commitment_number { Some(&revocation_points.1) }
					else if let Some(point) = revocation_points.2.as_ref() {
						if revocation_points.0 == commitment_number + 1 { Some(point) } else { None }
					} else { None };
				if let Some(revocation_point) = revocation_point_option {
					let (revocation_pubkey, b_htlc_key) = match self.key_storage {
						KeyStorage::PrivMode { ref revocation_base_key, ref htlc_base_key, .. } => {
							(ignore_error!(chan_utils::derive_public_revocation_key(&self.secp_ctx, revocation_point, &PublicKey::from_secret_key(&self.secp_ctx, &revocation_base_key))),
							ignore_error!(chan_utils::derive_public_key(&self.secp_ctx, revocation_point, &PublicKey::from_secret_key(&self.secp_ctx, &htlc_base_key))))
						},
						KeyStorage::SigsMode { ref revocation_base_key, ref htlc_base_key, .. } => {
							(ignore_error!(chan_utils::derive_public_revocation_key(&self.secp_ctx, revocation_point, &revocation_base_key)),
							ignore_error!(chan_utils::derive_public_key(&self.secp_ctx, revocation_point, &htlc_base_key)))
						},
					};
					let a_htlc_key = match self.their_htlc_base_key {
						None => return (txn_to_broadcast, (commitment_txid, watch_outputs), spendable_outputs),
						Some(their_htlc_base_key) => ignore_error!(chan_utils::derive_public_key(&self.secp_ctx, revocation_point, &their_htlc_base_key)),
					};


					for (idx, outp) in tx.output.iter().enumerate() {
						if outp.script_pubkey.is_v0_p2wpkh() {
							match self.key_storage {
								KeyStorage::PrivMode { ref payment_base_key, .. } => {
									if let Ok(local_key) = chan_utils::derive_private_key(&self.secp_ctx, &revocation_point, &payment_base_key) {
										spendable_outputs.push(SpendableOutputDescriptor::DynamicOutputP2WPKH {
											outpoint: BitcoinOutPoint { txid: commitment_txid, vout: idx as u32 },
											key: local_key,
											output: outp.clone(),
										});
									}
								}
								KeyStorage::SigsMode { .. } => {
									//TODO: we need to ensure an offline client will generate the event when it
									// cames back online after only the watchtower saw the transaction
								}
							}
							break; // Only to_remote ouput is claimable
						}
					}

					let mut total_value = 0;
					let mut values = Vec::new();
					let mut inputs = Vec::new();

					macro_rules! sign_input {
						($sighash_parts: expr, $input: expr, $amount: expr, $preimage: expr) => {
							{
								let (sig, redeemscript) = match self.key_storage {
									KeyStorage::PrivMode { ref htlc_base_key, .. } => {
										let htlc = &per_commitment_option.unwrap()[$input.sequence as usize];
										let redeemscript = chan_utils::get_htlc_redeemscript_with_explicit_keys(htlc, &a_htlc_key, &b_htlc_key, &revocation_pubkey);
										let sighash = ignore_error!(Message::from_slice(&$sighash_parts.sighash_all(&$input, &redeemscript, $amount)[..]));
										let htlc_key = ignore_error!(chan_utils::derive_private_key(&self.secp_ctx, revocation_point, &htlc_base_key));
										(self.secp_ctx.sign(&sighash, &htlc_key), redeemscript)
									},
									KeyStorage::SigsMode { .. } => {
										unimplemented!();
									}
								};
								$input.witness.push(sig.serialize_der(&self.secp_ctx).to_vec());
								$input.witness[0].push(SigHashType::All as u8);
								$input.witness.push($preimage);
								$input.witness.push(redeemscript.into_bytes());
							}
						}
					}

					for (idx, htlc) in per_commitment_data.iter().enumerate() {
						if let Some(payment_preimage) = self.payment_preimages.get(&htlc.payment_hash) {
							let input = TxIn {
								previous_output: BitcoinOutPoint {
									txid: commitment_txid,
									vout: htlc.transaction_output_index,
								},
								script_sig: Script::new(),
								sequence: idx as u32, // reset to 0xfffffffd in sign_input
								witness: Vec::new(),
							};
							if htlc.cltv_expiry > height + CLTV_SHARED_CLAIM_BUFFER {
								inputs.push(input);
								values.push((tx.output[htlc.transaction_output_index as usize].value, payment_preimage));
								total_value += htlc.amount_msat / 1000;
							} else {
								let mut single_htlc_tx = Transaction {
									version: 2,
									lock_time: 0,
									input: vec![input],
									output: vec!(TxOut {
										script_pubkey: self.destination_script.clone(),
										value: htlc.amount_msat / 1000, //TODO: - fee
									}),
								};
								let sighash_parts = bip143::SighashComponents::new(&single_htlc_tx);
								sign_input!(sighash_parts, single_htlc_tx.input[0], htlc.amount_msat / 1000, payment_preimage.to_vec());
								spendable_outputs.push(SpendableOutputDescriptor::StaticOutput {
									outpoint: BitcoinOutPoint { txid: single_htlc_tx.txid(), vout: 0 },
									output: single_htlc_tx.output[0].clone(),
								});
								txn_to_broadcast.push(single_htlc_tx);
							}
						}
					}

					if inputs.is_empty() { return (txn_to_broadcast, (commitment_txid, watch_outputs), spendable_outputs); } // Nothing to be done...probably a false positive/local tx

					let outputs = vec!(TxOut {
						script_pubkey: self.destination_script.clone(),
						value: total_value, //TODO: - fee
					});
					let mut spend_tx = Transaction {
						version: 2,
						lock_time: 0,
						input: inputs,
						output: outputs,
					};

					let mut values_drain = values.drain(..);
					let sighash_parts = bip143::SighashComponents::new(&spend_tx);

					for input in spend_tx.input.iter_mut() {
						let value = values_drain.next().unwrap();
						sign_input!(sighash_parts, input, value.0, value.1.to_vec());
					}

					spendable_outputs.push(SpendableOutputDescriptor::StaticOutput {
						outpoint: BitcoinOutPoint { txid: spend_tx.txid(), vout: 0 },
						output: spend_tx.output[0].clone(),
					});
					txn_to_broadcast.push(spend_tx);
				}
			}
		}

		(txn_to_broadcast, (commitment_txid, watch_outputs), spendable_outputs)
	}

	/// Attempst to claim a remote HTLC-Success/HTLC-Timeout s outputs using the revocation key
	fn check_spend_remote_htlc(&self, tx: &Transaction, commitment_number: u64) -> (Option<Transaction>, Option<SpendableOutputDescriptor>) {
		if tx.input.len() != 1 || tx.output.len() != 1 {
			return (None, None)
		}

		macro_rules! ignore_error {
			( $thing : expr ) => {
				match $thing {
					Ok(a) => a,
					Err(_) => return (None, None)
				}
			};
		}

		let secret = ignore_error!(self.get_secret(commitment_number));
		let per_commitment_key = ignore_error!(SecretKey::from_slice(&self.secp_ctx, &secret));
		let per_commitment_point = PublicKey::from_secret_key(&self.secp_ctx, &per_commitment_key);
		let revocation_pubkey = match self.key_storage {
			KeyStorage::PrivMode { ref revocation_base_key, .. } => {
				ignore_error!(chan_utils::derive_public_revocation_key(&self.secp_ctx, &per_commitment_point, &PublicKey::from_secret_key(&self.secp_ctx, &revocation_base_key)))
			},
			KeyStorage::SigsMode { ref revocation_base_key, .. } => {
				ignore_error!(chan_utils::derive_public_revocation_key(&self.secp_ctx, &per_commitment_point, &revocation_base_key))
			},
		};
		let delayed_key = match self.their_delayed_payment_base_key {
			None => return (None, None),
			Some(their_delayed_payment_base_key) => ignore_error!(chan_utils::derive_public_key(&self.secp_ctx, &per_commitment_point, &their_delayed_payment_base_key)),
		};
		let redeemscript = chan_utils::get_revokeable_redeemscript(&revocation_pubkey, self.their_to_self_delay.unwrap(), &delayed_key);
		let revokeable_p2wsh = redeemscript.to_v0_p2wsh();
		let htlc_txid = tx.txid(); //TODO: This is gonna be a performance bottleneck for watchtowers!

		let mut inputs = Vec::new();
		let mut amount = 0;

		if tx.output[0].script_pubkey == revokeable_p2wsh { //HTLC transactions have one txin, one txout
			inputs.push(TxIn {
				previous_output: BitcoinOutPoint {
					txid: htlc_txid,
					vout: 0,
				},
				script_sig: Script::new(),
				sequence: 0xfffffffd,
				witness: Vec::new(),
			});
			amount = tx.output[0].value;
		}

		if !inputs.is_empty() {
			let outputs = vec!(TxOut {
				script_pubkey: self.destination_script.clone(),
				value: amount, //TODO: - fee
			});

			let mut spend_tx = Transaction {
				version: 2,
				lock_time: 0,
				input: inputs,
				output: outputs,
			};

			let sighash_parts = bip143::SighashComponents::new(&spend_tx);

			let sig = match self.key_storage {
				KeyStorage::PrivMode { ref revocation_base_key, .. } => {
					let sighash = ignore_error!(Message::from_slice(&sighash_parts.sighash_all(&spend_tx.input[0], &redeemscript, amount)[..]));
					let revocation_key = ignore_error!(chan_utils::derive_private_revocation_key(&self.secp_ctx, &per_commitment_key, &revocation_base_key));
					self.secp_ctx.sign(&sighash, &revocation_key)
				}
				KeyStorage::SigsMode { .. } => {
					unimplemented!();
				}
			};
			spend_tx.input[0].witness.push(sig.serialize_der(&self.secp_ctx).to_vec());
			spend_tx.input[0].witness[0].push(SigHashType::All as u8);
			spend_tx.input[0].witness.push(vec!(1));
			spend_tx.input[0].witness.push(redeemscript.into_bytes());

			let outpoint = BitcoinOutPoint { txid: spend_tx.txid(), vout: 0 };
			let output = spend_tx.output[0].clone();
			(Some(spend_tx), Some(SpendableOutputDescriptor::StaticOutput { outpoint, output }))
		} else { (None, None) }
	}

	fn broadcast_by_local_state(&self, local_tx: &LocalSignedTx, per_commitment_point: &Option<PublicKey>, delayed_payment_base_key: &Option<SecretKey>) -> (Vec<Transaction>, Vec<SpendableOutputDescriptor>) {
		let mut res = Vec::with_capacity(local_tx.htlc_outputs.len());
		let mut spendable_outputs = Vec::with_capacity(local_tx.htlc_outputs.len());

		macro_rules! add_dynamic_output {
			($father_tx: expr, $vout: expr) => {
				if let Some(ref per_commitment_point) = *per_commitment_point {
					if let Some(ref delayed_payment_base_key) = *delayed_payment_base_key {
						if let Ok(local_delayedkey) = chan_utils::derive_private_key(&self.secp_ctx, per_commitment_point, delayed_payment_base_key) {
							spendable_outputs.push(SpendableOutputDescriptor::DynamicOutputP2WSH {
								outpoint: BitcoinOutPoint { txid: $father_tx.txid(), vout: $vout },
								key: local_delayedkey,
								witness_script: chan_utils::get_revokeable_redeemscript(&local_tx.revocation_key, self.our_to_self_delay, &local_tx.delayed_payment_key),
								to_self_delay: self.our_to_self_delay,
								output: $father_tx.output[$vout as usize].clone(),
							});
						}
					}
				}
			}
		}


		let redeemscript = chan_utils::get_revokeable_redeemscript(&local_tx.revocation_key, self.their_to_self_delay.unwrap(), &local_tx.delayed_payment_key);
		let revokeable_p2wsh = redeemscript.to_v0_p2wsh();
		for (idx, output) in local_tx.tx.output.iter().enumerate() {
			if output.script_pubkey == revokeable_p2wsh {
				add_dynamic_output!(local_tx.tx, idx as u32);
				break;
			}
		}

		for &(ref htlc, ref their_sig, ref our_sig) in local_tx.htlc_outputs.iter() {
			if htlc.offered {
				let mut htlc_timeout_tx = chan_utils::build_htlc_transaction(&local_tx.txid, local_tx.feerate_per_kw, self.their_to_self_delay.unwrap(), htlc, &local_tx.delayed_payment_key, &local_tx.revocation_key);

				htlc_timeout_tx.input[0].witness.push(Vec::new()); // First is the multisig dummy

				htlc_timeout_tx.input[0].witness.push(their_sig.serialize_der(&self.secp_ctx).to_vec());
				htlc_timeout_tx.input[0].witness[1].push(SigHashType::All as u8);
				htlc_timeout_tx.input[0].witness.push(our_sig.serialize_der(&self.secp_ctx).to_vec());
				htlc_timeout_tx.input[0].witness[2].push(SigHashType::All as u8);

				htlc_timeout_tx.input[0].witness.push(Vec::new());
				htlc_timeout_tx.input[0].witness.push(chan_utils::get_htlc_redeemscript_with_explicit_keys(htlc, &local_tx.a_htlc_key, &local_tx.b_htlc_key, &local_tx.revocation_key).into_bytes());

				add_dynamic_output!(htlc_timeout_tx, 0);
				res.push(htlc_timeout_tx);
			} else {
				if let Some(payment_preimage) = self.payment_preimages.get(&htlc.payment_hash) {
					let mut htlc_success_tx = chan_utils::build_htlc_transaction(&local_tx.txid, local_tx.feerate_per_kw, self.their_to_self_delay.unwrap(), htlc, &local_tx.delayed_payment_key, &local_tx.revocation_key);

					htlc_success_tx.input[0].witness.push(Vec::new()); // First is the multisig dummy

					htlc_success_tx.input[0].witness.push(their_sig.serialize_der(&self.secp_ctx).to_vec());
					htlc_success_tx.input[0].witness[1].push(SigHashType::All as u8);
					htlc_success_tx.input[0].witness.push(our_sig.serialize_der(&self.secp_ctx).to_vec());
					htlc_success_tx.input[0].witness[2].push(SigHashType::All as u8);

					htlc_success_tx.input[0].witness.push(payment_preimage.to_vec());
					htlc_success_tx.input[0].witness.push(chan_utils::get_htlc_redeemscript_with_explicit_keys(htlc, &local_tx.a_htlc_key, &local_tx.b_htlc_key, &local_tx.revocation_key).into_bytes());

					add_dynamic_output!(htlc_success_tx, 0);
					res.push(htlc_success_tx);
				}
			}
		}

		(res, spendable_outputs)
	}

	/// Attempts to claim any claimable HTLCs in a commitment transaction which was not (yet)
	/// revoked using data in local_claimable_outpoints.
	/// Should not be used if check_spend_revoked_transaction succeeds.
	fn check_spend_local_transaction(&self, tx: &Transaction, _height: u32) -> (Vec<Transaction>, Vec<SpendableOutputDescriptor>) {
		let commitment_txid = tx.txid();
		if let &Some(ref local_tx) = &self.current_local_signed_commitment_tx {
			if local_tx.txid == commitment_txid {
				match self.key_storage {
					KeyStorage::PrivMode { ref delayed_payment_base_key, ref latest_per_commitment_point, .. } => {
						return self.broadcast_by_local_state(local_tx, latest_per_commitment_point, &Some(*delayed_payment_base_key));
					},
					KeyStorage::SigsMode { .. } => {
						return self.broadcast_by_local_state(local_tx, &None, &None);
					}
				}
			}
		}
		if let &Some(ref local_tx) = &self.prev_local_signed_commitment_tx {
			if local_tx.txid == commitment_txid {
				match self.key_storage {
					KeyStorage::PrivMode { ref delayed_payment_base_key, ref prev_latest_per_commitment_point, .. } => {
						return self.broadcast_by_local_state(local_tx, prev_latest_per_commitment_point, &Some(*delayed_payment_base_key));
					},
					KeyStorage::SigsMode { .. } => {
						return self.broadcast_by_local_state(local_tx, &None, &None);
					}
				}
			}
		}
		(Vec::new(), Vec::new())
	}

	/// Generate a spendable output event when closing_transaction get registered onchain.
	fn check_spend_closing_transaction(&self, tx: &Transaction) -> Option<SpendableOutputDescriptor> {
		if tx.input[0].sequence == 0xFFFFFFFF && tx.input[0].witness.last().unwrap().len() == 71 {
			match self.key_storage {
				KeyStorage::PrivMode { ref shutdown_pubkey, .. } =>  {
					let our_channel_close_key_hash = Hash160::from_data(&shutdown_pubkey.serialize());
					let shutdown_script = Builder::new().push_opcode(opcodes::All::OP_PUSHBYTES_0).push_slice(&our_channel_close_key_hash[..]).into_script();
					for (idx, output) in tx.output.iter().enumerate() {
						if shutdown_script == output.script_pubkey {
							return Some(SpendableOutputDescriptor::StaticOutput {
								outpoint: BitcoinOutPoint { txid: tx.txid(), vout: idx as u32 },
								output: output.clone(),
							});
						}
					}
				}
				KeyStorage::SigsMode { .. } => {
					//TODO: we need to ensure an offline client will generate the event when it
					// cames back online after only the watchtower saw the transaction
				}
			}
		}
		None
	}

	/// Used by ChannelManager deserialization to broadcast the latest local state if it's copy of
	/// the Channel was out-of-date.
	pub(super) fn get_latest_local_commitment_txn(&self) -> Vec<Transaction> {
		if let &Some(ref local_tx) = &self.current_local_signed_commitment_tx {
			let mut res = vec![local_tx.tx.clone()];
			match self.key_storage {
				KeyStorage::PrivMode { ref delayed_payment_base_key, ref prev_latest_per_commitment_point, .. } => {
					res.append(&mut self.broadcast_by_local_state(local_tx, prev_latest_per_commitment_point, &Some(*delayed_payment_base_key)).0);
				},
				_ => panic!("Can only broadcast by local channelmonitor"),
			};
			res
		} else {
			Vec::new()
		}
	}

	fn block_connected(&mut self, txn_matched: &[&Transaction], height: u32, block_hash: &Sha256dHash, broadcaster: &BroadcasterInterface)-> (Vec<(Sha256dHash, Vec<TxOut>)>, Vec<SpendableOutputDescriptor>) {
		let mut watch_outputs = Vec::new();
		let mut spendable_outputs = Vec::new();
		for tx in txn_matched {
			if tx.input.len() == 1 {
				// Assuming our keys were not leaked (in which case we're screwed no matter what),
				// commitment transactions and HTLC transactions will all only ever have one input,
				// which is an easy way to filter out any potential non-matching txn for lazy
				// filters.
				let prevout = &tx.input[0].previous_output;
				let mut txn: Vec<Transaction> = Vec::new();
				if self.funding_txo.is_none() || (prevout.txid == self.funding_txo.as_ref().unwrap().0.txid && prevout.vout == self.funding_txo.as_ref().unwrap().0.index as u32) {
					let (remote_txn, new_outputs, mut spendable_output) = self.check_spend_remote_transaction(tx, height);
					txn = remote_txn;
					spendable_outputs.append(&mut spendable_output);
					if !new_outputs.1.is_empty() {
						watch_outputs.push(new_outputs);
					}
					if txn.is_empty() {
						let (remote_txn, mut outputs) = self.check_spend_local_transaction(tx, height);
						spendable_outputs.append(&mut outputs);
						txn = remote_txn;
					}
					if !self.funding_txo.is_none() && txn.is_empty() {
						if let Some(spendable_output) = self.check_spend_closing_transaction(tx) {
							spendable_outputs.push(spendable_output);
						}
					}
				} else {
					if let Some(&(commitment_number, _)) = self.remote_commitment_txn_on_chain.get(&prevout.txid) {
						let (tx, spendable_output) = self.check_spend_remote_htlc(tx, commitment_number);
						if let Some(tx) = tx {
							txn.push(tx);
						}
						if let Some(spendable_output) = spendable_output {
							spendable_outputs.push(spendable_output);
						}
					}
				}
				for tx in txn.iter() {
					broadcaster.broadcast_transaction(tx);
				}
			}
		}
		if let Some(ref cur_local_tx) = self.current_local_signed_commitment_tx {
			if self.would_broadcast_at_height(height) {
				broadcaster.broadcast_transaction(&cur_local_tx.tx);
				match self.key_storage {
					KeyStorage::PrivMode { ref delayed_payment_base_key, ref latest_per_commitment_point, .. } => {
						let (txs, mut outputs) = self.broadcast_by_local_state(&cur_local_tx, latest_per_commitment_point, &Some(*delayed_payment_base_key));
						spendable_outputs.append(&mut outputs);
						for tx in txs {
							broadcaster.broadcast_transaction(&tx);
						}
					},
					KeyStorage::SigsMode { .. } => {
						let (txs, mut outputs) = self.broadcast_by_local_state(&cur_local_tx, &None, &None);
						spendable_outputs.append(&mut outputs);
						for tx in txs {
							broadcaster.broadcast_transaction(&tx);
						}
					}
				}
			}
		}
		self.last_block_hash = block_hash.clone();
		(watch_outputs, spendable_outputs)
	}

	pub(super) fn would_broadcast_at_height(&self, height: u32) -> bool {
		if let Some(ref cur_local_tx) = self.current_local_signed_commitment_tx {
			for &(ref htlc, _, _) in cur_local_tx.htlc_outputs.iter() {
				// For inbound HTLCs which we know the preimage for, we have to ensure we hit the
				// chain with enough room to claim the HTLC without our counterparty being able to
				// time out the HTLC first.
				// For outbound HTLCs which our counterparty hasn't failed/claimed, our primary
				// concern is being able to claim the corresponding inbound HTLC (on another
				// channel) before it expires. In fact, we don't even really care if our
				// counterparty here claims such an outbound HTLC after it expired as long as we
				// can still claim the corresponding HTLC. Thus, to avoid needlessly hitting the
				// chain when our counterparty is waiting for expiration to off-chain fail an HTLC
				// we give ourselves a few blocks of headroom after expiration before going
				// on-chain for an expired HTLC.
				// Note that, to avoid a potential attack whereby a node delays claiming an HTLC
				// from us until we've reached the point where we go on-chain with the
				// corresponding inbound HTLC, we must ensure that outbound HTLCs go on chain at
				// least CLTV_CLAIM_BUFFER blocks prior to the inbound HTLC.
				//  aka outbound_cltv + HTLC_FAIL_TIMEOUT_BLOCKS == height - CLTV_CLAIM_BUFFER
				//      inbound_cltv == height + CLTV_CLAIM_BUFFER
				//      outbound_cltv + HTLC_FAIL_TIMEOUT_BLOCKS + CLTV_CLAIM_BUFER <= inbound_cltv - CLTV_CLAIM_BUFFER
				//      HTLC_FAIL_TIMEOUT_BLOCKS + 2*CLTV_CLAIM_BUFER <= inbound_cltv - outbound_cltv
				//      HTLC_FAIL_TIMEOUT_BLOCKS + 2*CLTV_CLAIM_BUFER <= CLTV_EXPIRY_DELTA
				if ( htlc.offered && htlc.cltv_expiry + HTLC_FAIL_TIMEOUT_BLOCKS <= height) ||
				   (!htlc.offered && htlc.cltv_expiry <= height + CLTV_CLAIM_BUFFER && self.payment_preimages.contains_key(&htlc.payment_hash)) {
					return true;
				}
			}
		}
		false
	}
}

const MAX_ALLOC_SIZE: usize = 64*1024;

impl<R: ::std::io::Read> ReadableArgs<R, Arc<Logger>> for (Sha256dHash, ChannelMonitor) {
	fn read(reader: &mut R, logger: Arc<Logger>) -> Result<Self, DecodeError> {
		let secp_ctx = Secp256k1::new();
		macro_rules! unwrap_obj {
			($key: expr) => {
				match $key {
					Ok(res) => res,
					Err(_) => return Err(DecodeError::InvalidValue),
				}
			}
		}

		let _ver: u8 = Readable::read(reader)?;
		let min_ver: u8 = Readable::read(reader)?;
		if min_ver > SERIALIZATION_VERSION {
			return Err(DecodeError::UnknownVersion);
		}

		// Technically this can fail and serialize fail a round-trip, but only for serialization of
		// barely-init'd ChannelMonitors that we can't do anything with.
		let outpoint = OutPoint {
			txid: Readable::read(reader)?,
			index: Readable::read(reader)?,
		};
		let funding_txo = Some((outpoint, Readable::read(reader)?));
		let commitment_transaction_number_obscure_factor = <U48 as Readable<R>>::read(reader)?.0;

		let key_storage = match <u8 as Readable<R>>::read(reader)? {
			0 => {
				let revocation_base_key = Readable::read(reader)?;
				let htlc_base_key = Readable::read(reader)?;
				let delayed_payment_base_key = Readable::read(reader)?;
				let payment_base_key = Readable::read(reader)?;
				let shutdown_pubkey = Readable::read(reader)?;
				let prev_latest_per_commitment_point = match <u8 as Readable<R>>::read(reader)? {
					0 => None,
					1 => Some(Readable::read(reader)?),
					_ => return Err(DecodeError::InvalidValue),
				};
				let latest_per_commitment_point = match <u8 as Readable<R>>::read(reader)? {
					0 => None,
					1 => Some(Readable::read(reader)?),
					_ => return Err(DecodeError::InvalidValue),
				};
				KeyStorage::PrivMode {
					revocation_base_key,
					htlc_base_key,
					delayed_payment_base_key,
					payment_base_key,
					shutdown_pubkey,
					prev_latest_per_commitment_point,
					latest_per_commitment_point,
				}
			},
			_ => return Err(DecodeError::InvalidValue),
		};

		let their_htlc_base_key = Some(Readable::read(reader)?);
		let their_delayed_payment_base_key = Some(Readable::read(reader)?);

		let their_cur_revocation_points = {
			let first_idx = <U48 as Readable<R>>::read(reader)?.0;
			if first_idx == 0 {
				None
			} else {
				let first_point = Readable::read(reader)?;
				let second_point_slice: [u8; 33] = Readable::read(reader)?;
				if second_point_slice[0..32] == [0; 32] && second_point_slice[32] == 0 {
					Some((first_idx, first_point, None))
				} else {
					Some((first_idx, first_point, Some(unwrap_obj!(PublicKey::from_slice(&secp_ctx, &second_point_slice)))))
				}
			}
		};

		let our_to_self_delay: u16 = Readable::read(reader)?;
		let their_to_self_delay: Option<u16> = Some(Readable::read(reader)?);

		let mut old_secrets = [([0; 32], 1 << 48); 49];
		for &mut (ref mut secret, ref mut idx) in old_secrets.iter_mut() {
			*secret = Readable::read(reader)?;
			*idx = Readable::read(reader)?;
		}

		macro_rules! read_htlc_in_commitment {
			() => {
				{
					let offered: bool = Readable::read(reader)?;
					let amount_msat: u64 = Readable::read(reader)?;
					let cltv_expiry: u32 = Readable::read(reader)?;
					let payment_hash: [u8; 32] = Readable::read(reader)?;
					let transaction_output_index: u32 = Readable::read(reader)?;

					HTLCOutputInCommitment {
						offered, amount_msat, cltv_expiry, payment_hash, transaction_output_index
					}
				}
			}
		}

		let remote_claimable_outpoints_len: u64 = Readable::read(reader)?;
		let mut remote_claimable_outpoints = HashMap::with_capacity(cmp::min(remote_claimable_outpoints_len as usize, MAX_ALLOC_SIZE / 64));
		for _ in 0..remote_claimable_outpoints_len {
			let txid: Sha256dHash = Readable::read(reader)?;
			let outputs_count: u64 = Readable::read(reader)?;
			let mut outputs = Vec::with_capacity(cmp::min(outputs_count as usize, MAX_ALLOC_SIZE / 32));
			for _ in 0..outputs_count {
				outputs.push(read_htlc_in_commitment!());
			}
			if let Some(_) = remote_claimable_outpoints.insert(txid, outputs) {
				return Err(DecodeError::InvalidValue);
			}
		}

		let remote_commitment_txn_on_chain_len: u64 = Readable::read(reader)?;
		let mut remote_commitment_txn_on_chain = HashMap::with_capacity(cmp::min(remote_commitment_txn_on_chain_len as usize, MAX_ALLOC_SIZE / 32));
		for _ in 0..remote_commitment_txn_on_chain_len {
			let txid: Sha256dHash = Readable::read(reader)?;
			let commitment_number = <U48 as Readable<R>>::read(reader)?.0;
			let outputs_count = <u64 as Readable<R>>::read(reader)?;
			let mut outputs = Vec::with_capacity(cmp::min(outputs_count as usize, MAX_ALLOC_SIZE / 8));
			for _ in 0..outputs_count {
				outputs.push(Readable::read(reader)?);
			}
			if let Some(_) = remote_commitment_txn_on_chain.insert(txid, (commitment_number, outputs)) {
				return Err(DecodeError::InvalidValue);
			}
		}

		let remote_hash_commitment_number_len: u64 = Readable::read(reader)?;
		let mut remote_hash_commitment_number = HashMap::with_capacity(cmp::min(remote_hash_commitment_number_len as usize, MAX_ALLOC_SIZE / 32));
		for _ in 0..remote_hash_commitment_number_len {
			let txid: [u8; 32] = Readable::read(reader)?;
			let commitment_number = <U48 as Readable<R>>::read(reader)?.0;
			if let Some(_) = remote_hash_commitment_number.insert(txid, commitment_number) {
				return Err(DecodeError::InvalidValue);
			}
		}

		macro_rules! read_local_tx {
			() => {
				{
					let tx = match Transaction::consensus_decode(reader.by_ref()) {
						Ok(tx) => tx,
						Err(e) => match e {
							encode::Error::Io(ioe) => return Err(DecodeError::Io(ioe)),
							_ => return Err(DecodeError::InvalidValue),
						},
					};

					if tx.input.is_empty() {
						// Ensure tx didn't hit the 0-input ambiguity case.
						return Err(DecodeError::InvalidValue);
					}

					let revocation_key = Readable::read(reader)?;
					let a_htlc_key = Readable::read(reader)?;
					let b_htlc_key = Readable::read(reader)?;
					let delayed_payment_key = Readable::read(reader)?;
					let feerate_per_kw: u64 = Readable::read(reader)?;

					let htlc_outputs_len: u64 = Readable::read(reader)?;
					let mut htlc_outputs = Vec::with_capacity(cmp::min(htlc_outputs_len as usize, MAX_ALLOC_SIZE / 128));
					for _ in 0..htlc_outputs_len {
						htlc_outputs.push((read_htlc_in_commitment!(), Readable::read(reader)?, Readable::read(reader)?));
					}

					LocalSignedTx {
						txid: tx.txid(),
						tx, revocation_key, a_htlc_key, b_htlc_key, delayed_payment_key, feerate_per_kw, htlc_outputs
					}
				}
			}
		}

		let prev_local_signed_commitment_tx = match <u8 as Readable<R>>::read(reader)? {
			0 => None,
			1 => {
				Some(read_local_tx!())
			},
			_ => return Err(DecodeError::InvalidValue),
		};

		let current_local_signed_commitment_tx = match <u8 as Readable<R>>::read(reader)? {
			0 => None,
			1 => {
				Some(read_local_tx!())
			},
			_ => return Err(DecodeError::InvalidValue),
		};

		let current_remote_commitment_number = <U48 as Readable<R>>::read(reader)?.0;

		let payment_preimages_len: u64 = Readable::read(reader)?;
		let mut payment_preimages = HashMap::with_capacity(cmp::min(payment_preimages_len as usize, MAX_ALLOC_SIZE / 32));
		let mut sha = Sha256::new();
		for _ in 0..payment_preimages_len {
			let preimage: [u8; 32] = Readable::read(reader)?;
			sha.reset();
			sha.input(&preimage);
			let mut hash = [0; 32];
			sha.result(&mut hash);
			if let Some(_) = payment_preimages.insert(hash, preimage) {
				return Err(DecodeError::InvalidValue);
			}
		}

		let last_block_hash: Sha256dHash = Readable::read(reader)?;
		let destination_script = Readable::read(reader)?;

		Ok((last_block_hash.clone(), ChannelMonitor {
			funding_txo,
			commitment_transaction_number_obscure_factor,

			key_storage,
			their_htlc_base_key,
			their_delayed_payment_base_key,
			their_cur_revocation_points,

			our_to_self_delay,
			their_to_self_delay,

			old_secrets,
			remote_claimable_outpoints,
			remote_commitment_txn_on_chain,
			remote_hash_commitment_number,

			prev_local_signed_commitment_tx,
			current_local_signed_commitment_tx,
			current_remote_commitment_number,

			payment_preimages,

			destination_script,
			last_block_hash,
			secp_ctx,
			logger,
		}))
	}

}

#[cfg(test)]
mod tests {
	use bitcoin::blockdata::script::Script;
	use bitcoin::blockdata::transaction::Transaction;
	use crypto::digest::Digest;
	use hex;
	use ln::channelmonitor::ChannelMonitor;
	use ln::chan_utils::{HTLCOutputInCommitment, TxCreationKeys};
	use util::sha2::Sha256;
	use util::test_utils::TestLogger;
	use secp256k1::key::{SecretKey,PublicKey};
	use secp256k1::{Secp256k1, Signature};
	use rand::{thread_rng,Rng};
	use std::sync::Arc;

	#[test]
	fn test_per_commitment_storage() {
		// Test vectors from BOLT 3:
		let mut secrets: Vec<[u8; 32]> = Vec::new();
		let mut monitor: ChannelMonitor;
		let secp_ctx = Secp256k1::new();
		let logger = Arc::new(TestLogger::new());

		macro_rules! test_secrets {
			() => {
				let mut idx = 281474976710655;
				for secret in secrets.iter() {
					assert_eq!(monitor.get_secret(idx).unwrap(), *secret);
					idx -= 1;
				}
				assert_eq!(monitor.get_min_seen_secret(), idx + 1);
				assert!(monitor.get_secret(idx).is_err());
			};
		}

		{
			// insert_secret correct sequence
			monitor = ChannelMonitor::new(&SecretKey::from_slice(&secp_ctx, &[42; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[43; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &PublicKey::from_secret_key(&secp_ctx, &SecretKey::from_slice(&secp_ctx, &[45; 32]).unwrap()), 0, Script::new(), logger.clone());
			secrets.clear();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("7cc854b54e3e0dcdb010d7a3fee464a9687be6e8db3be6854c475621e007a5dc").unwrap());
			monitor.provide_secret(281474976710655, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("c7518c8ae4660ed02894df8976fa1a3659c1a8b4b5bec0c4b872abeba4cb8964").unwrap());
			monitor.provide_secret(281474976710654, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("2273e227a5b7449b6e70f1fb4652864038b1cbf9cd7c043a7d6456b7fc275ad8").unwrap());
			monitor.provide_secret(281474976710653, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("27cddaa5624534cb6cb9d7da077cf2b22ab21e9b506fd4998a51d54502e99116").unwrap());
			monitor.provide_secret(281474976710652, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("c65716add7aa98ba7acb236352d665cab17345fe45b55fb879ff80e6bd0c41dd").unwrap());
			monitor.provide_secret(281474976710651, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("969660042a28f32d9be17344e09374b379962d03db1574df5a8a5a47e19ce3f2").unwrap());
			monitor.provide_secret(281474976710650, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("a5a64476122ca0925fb344bdc1854c1c0a59fc614298e50a33e331980a220f32").unwrap());
			monitor.provide_secret(281474976710649, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("05cde6323d949933f7f7b78776bcc1ea6d9b31447732e3802e1f7ac44b650e17").unwrap());
			monitor.provide_secret(281474976710648, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();
		}

		{
			// insert_secret #1 incorrect
			monitor = ChannelMonitor::new(&SecretKey::from_slice(&secp_ctx, &[42; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[43; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &PublicKey::from_secret_key(&secp_ctx, &SecretKey::from_slice(&secp_ctx, &[45; 32]).unwrap()), 0, Script::new(), logger.clone());
			secrets.clear();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("02a40c85b6f28da08dfdbe0926c53fab2de6d28c10301f8f7c4073d5e42e3148").unwrap());
			monitor.provide_secret(281474976710655, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("c7518c8ae4660ed02894df8976fa1a3659c1a8b4b5bec0c4b872abeba4cb8964").unwrap());
			assert_eq!(monitor.provide_secret(281474976710654, secrets.last().unwrap().clone()).unwrap_err().err,
					"Previous secret did not match new one");
		}

		{
			// insert_secret #2 incorrect (#1 derived from incorrect)
			monitor = ChannelMonitor::new(&SecretKey::from_slice(&secp_ctx, &[42; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[43; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &PublicKey::from_secret_key(&secp_ctx, &SecretKey::from_slice(&secp_ctx, &[45; 32]).unwrap()), 0, Script::new(), logger.clone());
			secrets.clear();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("02a40c85b6f28da08dfdbe0926c53fab2de6d28c10301f8f7c4073d5e42e3148").unwrap());
			monitor.provide_secret(281474976710655, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("dddc3a8d14fddf2b68fa8c7fbad2748274937479dd0f8930d5ebb4ab6bd866a3").unwrap());
			monitor.provide_secret(281474976710654, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("2273e227a5b7449b6e70f1fb4652864038b1cbf9cd7c043a7d6456b7fc275ad8").unwrap());
			monitor.provide_secret(281474976710653, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("27cddaa5624534cb6cb9d7da077cf2b22ab21e9b506fd4998a51d54502e99116").unwrap());
			assert_eq!(monitor.provide_secret(281474976710652, secrets.last().unwrap().clone()).unwrap_err().err,
					"Previous secret did not match new one");
		}

		{
			// insert_secret #3 incorrect
			monitor = ChannelMonitor::new(&SecretKey::from_slice(&secp_ctx, &[42; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[43; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &PublicKey::from_secret_key(&secp_ctx, &SecretKey::from_slice(&secp_ctx, &[45; 32]).unwrap()), 0, Script::new(), logger.clone());
			secrets.clear();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("7cc854b54e3e0dcdb010d7a3fee464a9687be6e8db3be6854c475621e007a5dc").unwrap());
			monitor.provide_secret(281474976710655, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("c7518c8ae4660ed02894df8976fa1a3659c1a8b4b5bec0c4b872abeba4cb8964").unwrap());
			monitor.provide_secret(281474976710654, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("c51a18b13e8527e579ec56365482c62f180b7d5760b46e9477dae59e87ed423a").unwrap());
			monitor.provide_secret(281474976710653, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("27cddaa5624534cb6cb9d7da077cf2b22ab21e9b506fd4998a51d54502e99116").unwrap());
			assert_eq!(monitor.provide_secret(281474976710652, secrets.last().unwrap().clone()).unwrap_err().err,
					"Previous secret did not match new one");
		}

		{
			// insert_secret #4 incorrect (1,2,3 derived from incorrect)
			monitor = ChannelMonitor::new(&SecretKey::from_slice(&secp_ctx, &[42; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[43; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &PublicKey::from_secret_key(&secp_ctx, &SecretKey::from_slice(&secp_ctx, &[45; 32]).unwrap()), 0, Script::new(), logger.clone());
			secrets.clear();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("02a40c85b6f28da08dfdbe0926c53fab2de6d28c10301f8f7c4073d5e42e3148").unwrap());
			monitor.provide_secret(281474976710655, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("dddc3a8d14fddf2b68fa8c7fbad2748274937479dd0f8930d5ebb4ab6bd866a3").unwrap());
			monitor.provide_secret(281474976710654, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("c51a18b13e8527e579ec56365482c62f180b7d5760b46e9477dae59e87ed423a").unwrap());
			monitor.provide_secret(281474976710653, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("ba65d7b0ef55a3ba300d4e87af29868f394f8f138d78a7011669c79b37b936f4").unwrap());
			monitor.provide_secret(281474976710652, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("c65716add7aa98ba7acb236352d665cab17345fe45b55fb879ff80e6bd0c41dd").unwrap());
			monitor.provide_secret(281474976710651, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("969660042a28f32d9be17344e09374b379962d03db1574df5a8a5a47e19ce3f2").unwrap());
			monitor.provide_secret(281474976710650, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("a5a64476122ca0925fb344bdc1854c1c0a59fc614298e50a33e331980a220f32").unwrap());
			monitor.provide_secret(281474976710649, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("05cde6323d949933f7f7b78776bcc1ea6d9b31447732e3802e1f7ac44b650e17").unwrap());
			assert_eq!(monitor.provide_secret(281474976710648, secrets.last().unwrap().clone()).unwrap_err().err,
					"Previous secret did not match new one");
		}

		{
			// insert_secret #5 incorrect
			monitor = ChannelMonitor::new(&SecretKey::from_slice(&secp_ctx, &[42; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[43; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &PublicKey::from_secret_key(&secp_ctx, &SecretKey::from_slice(&secp_ctx, &[45; 32]).unwrap()), 0, Script::new(), logger.clone());
			secrets.clear();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("7cc854b54e3e0dcdb010d7a3fee464a9687be6e8db3be6854c475621e007a5dc").unwrap());
			monitor.provide_secret(281474976710655, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("c7518c8ae4660ed02894df8976fa1a3659c1a8b4b5bec0c4b872abeba4cb8964").unwrap());
			monitor.provide_secret(281474976710654, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("2273e227a5b7449b6e70f1fb4652864038b1cbf9cd7c043a7d6456b7fc275ad8").unwrap());
			monitor.provide_secret(281474976710653, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("27cddaa5624534cb6cb9d7da077cf2b22ab21e9b506fd4998a51d54502e99116").unwrap());
			monitor.provide_secret(281474976710652, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("631373ad5f9ef654bb3dade742d09504c567edd24320d2fcd68e3cc47e2ff6a6").unwrap());
			monitor.provide_secret(281474976710651, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("969660042a28f32d9be17344e09374b379962d03db1574df5a8a5a47e19ce3f2").unwrap());
			assert_eq!(monitor.provide_secret(281474976710650, secrets.last().unwrap().clone()).unwrap_err().err,
					"Previous secret did not match new one");
		}

		{
			// insert_secret #6 incorrect (5 derived from incorrect)
			monitor = ChannelMonitor::new(&SecretKey::from_slice(&secp_ctx, &[42; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[43; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &PublicKey::from_secret_key(&secp_ctx, &SecretKey::from_slice(&secp_ctx, &[45; 32]).unwrap()), 0, Script::new(), logger.clone());
			secrets.clear();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("7cc854b54e3e0dcdb010d7a3fee464a9687be6e8db3be6854c475621e007a5dc").unwrap());
			monitor.provide_secret(281474976710655, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("c7518c8ae4660ed02894df8976fa1a3659c1a8b4b5bec0c4b872abeba4cb8964").unwrap());
			monitor.provide_secret(281474976710654, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("2273e227a5b7449b6e70f1fb4652864038b1cbf9cd7c043a7d6456b7fc275ad8").unwrap());
			monitor.provide_secret(281474976710653, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("27cddaa5624534cb6cb9d7da077cf2b22ab21e9b506fd4998a51d54502e99116").unwrap());
			monitor.provide_secret(281474976710652, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("631373ad5f9ef654bb3dade742d09504c567edd24320d2fcd68e3cc47e2ff6a6").unwrap());
			monitor.provide_secret(281474976710651, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("b7e76a83668bde38b373970155c868a653304308f9896692f904a23731224bb1").unwrap());
			monitor.provide_secret(281474976710650, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("a5a64476122ca0925fb344bdc1854c1c0a59fc614298e50a33e331980a220f32").unwrap());
			monitor.provide_secret(281474976710649, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("05cde6323d949933f7f7b78776bcc1ea6d9b31447732e3802e1f7ac44b650e17").unwrap());
			assert_eq!(monitor.provide_secret(281474976710648, secrets.last().unwrap().clone()).unwrap_err().err,
					"Previous secret did not match new one");
		}

		{
			// insert_secret #7 incorrect
			monitor = ChannelMonitor::new(&SecretKey::from_slice(&secp_ctx, &[42; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[43; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &PublicKey::from_secret_key(&secp_ctx, &SecretKey::from_slice(&secp_ctx, &[45; 32]).unwrap()), 0, Script::new(), logger.clone());
			secrets.clear();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("7cc854b54e3e0dcdb010d7a3fee464a9687be6e8db3be6854c475621e007a5dc").unwrap());
			monitor.provide_secret(281474976710655, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("c7518c8ae4660ed02894df8976fa1a3659c1a8b4b5bec0c4b872abeba4cb8964").unwrap());
			monitor.provide_secret(281474976710654, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("2273e227a5b7449b6e70f1fb4652864038b1cbf9cd7c043a7d6456b7fc275ad8").unwrap());
			monitor.provide_secret(281474976710653, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("27cddaa5624534cb6cb9d7da077cf2b22ab21e9b506fd4998a51d54502e99116").unwrap());
			monitor.provide_secret(281474976710652, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("c65716add7aa98ba7acb236352d665cab17345fe45b55fb879ff80e6bd0c41dd").unwrap());
			monitor.provide_secret(281474976710651, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("969660042a28f32d9be17344e09374b379962d03db1574df5a8a5a47e19ce3f2").unwrap());
			monitor.provide_secret(281474976710650, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("e7971de736e01da8ed58b94c2fc216cb1dca9e326f3a96e7194fe8ea8af6c0a3").unwrap());
			monitor.provide_secret(281474976710649, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("05cde6323d949933f7f7b78776bcc1ea6d9b31447732e3802e1f7ac44b650e17").unwrap());
			assert_eq!(monitor.provide_secret(281474976710648, secrets.last().unwrap().clone()).unwrap_err().err,
					"Previous secret did not match new one");
		}

		{
			// insert_secret #8 incorrect
			monitor = ChannelMonitor::new(&SecretKey::from_slice(&secp_ctx, &[42; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[43; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &PublicKey::from_secret_key(&secp_ctx, &SecretKey::from_slice(&secp_ctx, &[45; 32]).unwrap()), 0, Script::new(), logger.clone());
			secrets.clear();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("7cc854b54e3e0dcdb010d7a3fee464a9687be6e8db3be6854c475621e007a5dc").unwrap());
			monitor.provide_secret(281474976710655, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("c7518c8ae4660ed02894df8976fa1a3659c1a8b4b5bec0c4b872abeba4cb8964").unwrap());
			monitor.provide_secret(281474976710654, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("2273e227a5b7449b6e70f1fb4652864038b1cbf9cd7c043a7d6456b7fc275ad8").unwrap());
			monitor.provide_secret(281474976710653, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("27cddaa5624534cb6cb9d7da077cf2b22ab21e9b506fd4998a51d54502e99116").unwrap());
			monitor.provide_secret(281474976710652, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("c65716add7aa98ba7acb236352d665cab17345fe45b55fb879ff80e6bd0c41dd").unwrap());
			monitor.provide_secret(281474976710651, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("969660042a28f32d9be17344e09374b379962d03db1574df5a8a5a47e19ce3f2").unwrap());
			monitor.provide_secret(281474976710650, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("a5a64476122ca0925fb344bdc1854c1c0a59fc614298e50a33e331980a220f32").unwrap());
			monitor.provide_secret(281474976710649, secrets.last().unwrap().clone()).unwrap();
			test_secrets!();

			secrets.push([0; 32]);
			secrets.last_mut().unwrap()[0..32].clone_from_slice(&hex::decode("a7efbc61aac46d34f77778bac22c8a20c6a46ca460addc49009bda875ec88fa4").unwrap());
			assert_eq!(monitor.provide_secret(281474976710648, secrets.last().unwrap().clone()).unwrap_err().err,
					"Previous secret did not match new one");
		}
	}

	#[test]
	fn test_prune_preimages() {
		let secp_ctx = Secp256k1::new();
		let logger = Arc::new(TestLogger::new());
		let dummy_sig = Signature::from_der(&secp_ctx, &hex::decode("3045022100fa86fa9a36a8cd6a7bb8f06a541787d51371d067951a9461d5404de6b928782e02201c8b7c334c10aed8976a3a465be9a28abff4cb23acbf00022295b378ce1fa3cd").unwrap()[..]).unwrap();

		macro_rules! dummy_keys {
			() => {
				{
					let dummy_key = PublicKey::from_secret_key(&secp_ctx, &SecretKey::from_slice(&secp_ctx, &[42; 32]).unwrap());
					TxCreationKeys {
						per_commitment_point: dummy_key.clone(),
						revocation_key: dummy_key.clone(),
						a_htlc_key: dummy_key.clone(),
						b_htlc_key: dummy_key.clone(),
						a_delayed_payment_key: dummy_key.clone(),
						b_payment_key: dummy_key.clone(),
					}
				}
			}
		}
		let dummy_tx = Transaction { version: 0, lock_time: 0, input: Vec::new(), output: Vec::new() };

		let mut preimages = Vec::new();
		{
			let mut rng  = thread_rng();
			for _ in 0..20 {
				let mut preimage = [0; 32];
				rng.fill_bytes(&mut preimage);
				let mut sha = Sha256::new();
				sha.input(&preimage);
				let mut hash = [0; 32];
				sha.result(&mut hash);
				preimages.push((preimage, hash));
			}
		}

		macro_rules! preimages_slice_to_htlc_outputs {
			($preimages_slice: expr) => {
				{
					let mut res = Vec::new();
					for (idx, preimage) in $preimages_slice.iter().enumerate() {
						res.push(HTLCOutputInCommitment {
							offered: true,
							amount_msat: 0,
							cltv_expiry: 0,
							payment_hash: preimage.1.clone(),
							transaction_output_index: idx as u32,
						});
					}
					res
				}
			}
		}
		macro_rules! preimages_to_local_htlcs {
			($preimages_slice: expr) => {
				{
					let mut inp = preimages_slice_to_htlc_outputs!($preimages_slice);
					let res: Vec<_> = inp.drain(..).map(|e| { (e, dummy_sig.clone(), dummy_sig.clone()) }).collect();
					res
				}
			}
		}

		macro_rules! test_preimages_exist {
			($preimages_slice: expr, $monitor: expr) => {
				for preimage in $preimages_slice {
					assert!($monitor.payment_preimages.contains_key(&preimage.1));
				}
			}
		}

		// Prune with one old state and a local commitment tx holding a few overlaps with the
		// old state.
		let mut monitor = ChannelMonitor::new(&SecretKey::from_slice(&secp_ctx, &[42; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[43; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &SecretKey::from_slice(&secp_ctx, &[44; 32]).unwrap(), &PublicKey::from_secret_key(&secp_ctx, &SecretKey::from_slice(&secp_ctx, &[45; 32]).unwrap()), 0, Script::new(), logger.clone());
		monitor.set_their_to_self_delay(10);

		monitor.provide_latest_local_commitment_tx_info(dummy_tx.clone(), dummy_keys!(), 0, preimages_to_local_htlcs!(preimages[0..10]));
		monitor.provide_latest_remote_commitment_tx_info(&dummy_tx, preimages_slice_to_htlc_outputs!(preimages[5..15]), 281474976710655);
		monitor.provide_latest_remote_commitment_tx_info(&dummy_tx, preimages_slice_to_htlc_outputs!(preimages[15..20]), 281474976710654);
		monitor.provide_latest_remote_commitment_tx_info(&dummy_tx, preimages_slice_to_htlc_outputs!(preimages[17..20]), 281474976710653);
		monitor.provide_latest_remote_commitment_tx_info(&dummy_tx, preimages_slice_to_htlc_outputs!(preimages[18..20]), 281474976710652);
		for &(ref preimage, ref hash) in preimages.iter() {
			monitor.provide_payment_preimage(hash, preimage);
		}

		// Now provide a secret, pruning preimages 10-15
		let mut secret = [0; 32];
		secret[0..32].clone_from_slice(&hex::decode("7cc854b54e3e0dcdb010d7a3fee464a9687be6e8db3be6854c475621e007a5dc").unwrap());
		monitor.provide_secret(281474976710655, secret.clone()).unwrap();
		assert_eq!(monitor.payment_preimages.len(), 15);
		test_preimages_exist!(&preimages[0..10], monitor);
		test_preimages_exist!(&preimages[15..20], monitor);

		// Now provide a further secret, pruning preimages 15-17
		secret[0..32].clone_from_slice(&hex::decode("c7518c8ae4660ed02894df8976fa1a3659c1a8b4b5bec0c4b872abeba4cb8964").unwrap());
		monitor.provide_secret(281474976710654, secret.clone()).unwrap();
		assert_eq!(monitor.payment_preimages.len(), 13);
		test_preimages_exist!(&preimages[0..10], monitor);
		test_preimages_exist!(&preimages[17..20], monitor);

		// Now update local commitment tx info, pruning only element 18 as we still care about the
		// previous commitment tx's preimages too
		monitor.provide_latest_local_commitment_tx_info(dummy_tx.clone(), dummy_keys!(), 0, preimages_to_local_htlcs!(preimages[0..5]));
		secret[0..32].clone_from_slice(&hex::decode("2273e227a5b7449b6e70f1fb4652864038b1cbf9cd7c043a7d6456b7fc275ad8").unwrap());
		monitor.provide_secret(281474976710653, secret.clone()).unwrap();
		assert_eq!(monitor.payment_preimages.len(), 12);
		test_preimages_exist!(&preimages[0..10], monitor);
		test_preimages_exist!(&preimages[18..20], monitor);

		// But if we do it again, we'll prune 5-10
		monitor.provide_latest_local_commitment_tx_info(dummy_tx.clone(), dummy_keys!(), 0, preimages_to_local_htlcs!(preimages[0..3]));
		secret[0..32].clone_from_slice(&hex::decode("27cddaa5624534cb6cb9d7da077cf2b22ab21e9b506fd4998a51d54502e99116").unwrap());
		monitor.provide_secret(281474976710652, secret.clone()).unwrap();
		assert_eq!(monitor.payment_preimages.len(), 5);
		test_preimages_exist!(&preimages[0..5], monitor);
	}

	// Further testing is done in the ChannelManager integration tests.
}
