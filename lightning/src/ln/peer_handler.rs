// This file is Copyright its original authors, visible in version control
// history.
//
// This file is licensed under the Apache License, Version 2.0 <LICENSE-APACHE
// or http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your option.
// You may not use this file except in accordance with one or both of these
// licenses.

//! Top level peer message handling and socket handling logic lives here.
//!
//! Instead of actually servicing sockets ourselves we require that you implement the
//! SocketDescriptor interface and use that to receive actions which you should perform on the
//! socket, and call into PeerManager with bytes read from the socket. The PeerManager will then
//! call into the provided message handlers (probably a ChannelManager and P2PGossipSync) with
//! messages they should handle, and encoding/sending response messages.

use bitcoin::constants::ChainHash;
use bitcoin::secp256k1::{self, PublicKey, Secp256k1, SecretKey};

use crate::blinded_path::message::{AsyncPaymentsContext, DNSResolverContext, OffersContext};
use crate::ln::msgs;
use crate::ln::msgs::{
	BaseMessageHandler, ChannelMessageHandler, Init, LightningError, MessageSendEvent,
	OnionMessageHandler, RoutingMessageHandler, SendOnlyMessageHandler, SocketAddress,
};
use crate::ln::peer_channel_encryptor::{
	MessageBuf, NextNoiseStep, PeerChannelEncryptor, MSG_BUF_ALLOC_SIZE,
};
use crate::ln::types::ChannelId;
use crate::ln::wire;
use crate::ln::wire::{Encode, Type};
use crate::onion_message::async_payments::{
	AsyncPaymentsMessageHandler, HeldHtlcAvailable, OfferPaths, OfferPathsRequest, ReleaseHeldHtlc,
	ServeStaticInvoice, StaticInvoicePersisted,
};
use crate::onion_message::dns_resolution::{
	DNSResolverMessage, DNSResolverMessageHandler, DNSSECProof, DNSSECQuery,
};
use crate::onion_message::messenger::{
	CustomOnionMessageHandler, MessageSendInstructions, Responder, ResponseInstruction,
};
use crate::onion_message::offers::{OffersMessage, OffersMessageHandler};
use crate::onion_message::packet::OnionMessageContents;
use crate::routing::gossip::{NodeAlias, NodeId};
use crate::sign::{NodeSigner, Recipient};
use crate::types::features::{InitFeatures, NodeFeatures};
use crate::types::string::PrintableString;
use crate::util::atomic_counter::AtomicCounter;
use crate::util::logger::{BoxedSpan, Level, Logger, Span, WithContext};
use crate::util::ser::{VecWriter, Writeable, Writer};

#[allow(unused_imports)]
use crate::prelude::*;

use crate::io;
use crate::sync::{FairRwLock, Mutex, MutexGuard};
use core::convert::Infallible;
use core::ops::Deref;
use core::sync::atomic::{AtomicBool, AtomicI32, AtomicU32, Ordering};
use core::{cmp, fmt, hash, mem};
#[cfg(not(c_bindings))]
use {
	crate::chain::chainmonitor::ChainMonitor,
	crate::ln::channelmanager::{SimpleArcChannelManager, SimpleRefChannelManager},
	crate::onion_message::messenger::{SimpleArcOnionMessenger, SimpleRefOnionMessenger},
	crate::routing::gossip::{NetworkGraph, P2PGossipSync},
	crate::sign::{InMemorySigner, KeysManager},
	crate::sync::Arc,
};

use bitcoin::hashes::sha256::Hash as Sha256;
use bitcoin::hashes::sha256::HashEngine as Sha256Engine;
use bitcoin::hashes::{Hash, HashEngine};

/// A handler provided to [`PeerManager`] for reading and handling custom messages.
///
/// [BOLT 1] specifies a custom message type range for use with experimental or application-specific
/// messages. `CustomMessageHandler` allows for user-defined handling of such types. See the
/// [`lightning_custom_message`] crate for tools useful in composing more than one custom handler.
///
/// [BOLT 1]: https://github.com/lightning/bolts/blob/master/01-messaging.md
/// [`lightning_custom_message`]: https://docs.rs/lightning_custom_message/latest/lightning_custom_message
pub trait CustomMessageHandler: wire::CustomMessageReader {
	/// Handles the given message sent from `sender_node_id`, possibly producing messages for
	/// [`CustomMessageHandler::get_and_clear_pending_msg`] to return and thus for [`PeerManager`]
	/// to send.
	fn handle_custom_message(
		&self, msg: Self::CustomMessage, sender_node_id: PublicKey,
	) -> Result<(), LightningError>;

	/// Returns the list of pending messages that were generated by the handler, clearing the list
	/// in the process. Each message is paired with the node id of the intended recipient. If no
	/// connection to the node exists, then the message is simply not sent.
	fn get_and_clear_pending_msg(&self) -> Vec<(PublicKey, Self::CustomMessage)>;

	/// Indicates a peer disconnected.
	fn peer_disconnected(&self, their_node_id: PublicKey);

	/// Handle a peer connecting.
	///
	/// May return an `Err(())` to indicate that we should immediately disconnect from the peer
	/// (e.g. because the features they support are not sufficient to communicate with us).
	///
	/// Note, of course, that other message handlers may wish to communicate with the peer, which
	/// disconnecting them will prevent.
	///
	/// [`Self::peer_disconnected`] will not be called if `Err(())` is returned.
	fn peer_connected(&self, their_node_id: PublicKey, msg: &Init, inbound: bool)
		-> Result<(), ()>;

	/// Gets the node feature flags which this handler itself supports. All available handlers are
	/// queried similarly and their feature flags are OR'd together to form the [`NodeFeatures`]
	/// which are broadcasted in our [`NodeAnnouncement`] message.
	///
	/// [`NodeAnnouncement`]: crate::ln::msgs::NodeAnnouncement
	fn provided_node_features(&self) -> NodeFeatures;

	/// Gets the init feature flags which should be sent to the given peer. All available handlers
	/// are queried similarly and their feature flags are OR'd together to form the [`InitFeatures`]
	/// which are sent in our [`Init`] message.
	///
	/// [`Init`]: crate::ln::msgs::Init
	fn provided_init_features(&self, their_node_id: PublicKey) -> InitFeatures;
}

/// A dummy struct which implements `RoutingMessageHandler` without storing any routing information
/// or doing any processing. You can provide one of these as the route_handler in a MessageHandler.
pub struct IgnoringMessageHandler {}
impl BaseMessageHandler for IgnoringMessageHandler {
	fn peer_disconnected(&self, _their_node_id: PublicKey) {}
	fn peer_connected(
		&self, _their_node_id: PublicKey, _init: &msgs::Init, _inbound: bool,
	) -> Result<(), ()> {
		Ok(())
	}
	fn provided_node_features(&self) -> NodeFeatures {
		NodeFeatures::empty()
	}
	fn provided_init_features(&self, _their_node_id: PublicKey) -> InitFeatures {
		InitFeatures::empty()
	}
	fn get_and_clear_pending_msg_events(&self) -> Vec<MessageSendEvent> {
		Vec::new()
	}
}
impl RoutingMessageHandler for IgnoringMessageHandler {
	fn handle_node_announcement(
		&self, _their_node_id: Option<PublicKey>, _msg: &msgs::NodeAnnouncement,
	) -> Result<bool, LightningError> {
		Ok(false)
	}
	fn handle_channel_announcement(
		&self, _their_node_id: Option<PublicKey>, _msg: &msgs::ChannelAnnouncement,
	) -> Result<bool, LightningError> {
		Ok(false)
	}
	fn handle_channel_update(
		&self, _their_node_id: Option<PublicKey>, _msg: &msgs::ChannelUpdate,
	) -> Result<bool, LightningError> {
		Ok(false)
	}
	fn get_next_channel_announcement(
		&self, _starting_point: u64,
	) -> Option<(msgs::ChannelAnnouncement, Option<msgs::ChannelUpdate>, Option<msgs::ChannelUpdate>)>
	{
		None
	}
	fn get_next_node_announcement(
		&self, _starting_point: Option<&NodeId>,
	) -> Option<msgs::NodeAnnouncement> {
		None
	}
	fn handle_reply_channel_range(
		&self, _their_node_id: PublicKey, _msg: msgs::ReplyChannelRange,
	) -> Result<(), LightningError> {
		Ok(())
	}
	fn handle_reply_short_channel_ids_end(
		&self, _their_node_id: PublicKey, _msg: msgs::ReplyShortChannelIdsEnd,
	) -> Result<(), LightningError> {
		Ok(())
	}
	fn handle_query_channel_range(
		&self, _their_node_id: PublicKey, _msg: msgs::QueryChannelRange,
	) -> Result<(), LightningError> {
		Ok(())
	}
	fn handle_query_short_channel_ids(
		&self, _their_node_id: PublicKey, _msg: msgs::QueryShortChannelIds,
	) -> Result<(), LightningError> {
		Ok(())
	}
	fn processing_queue_high(&self) -> bool {
		false
	}
}

impl OnionMessageHandler for IgnoringMessageHandler {
	fn handle_onion_message(&self, _their_node_id: PublicKey, _msg: &msgs::OnionMessage) {}
	fn next_onion_message_for_peer(&self, _peer_node_id: PublicKey) -> Option<msgs::OnionMessage> {
		None
	}
	fn timer_tick_occurred(&self) {}
}

impl OffersMessageHandler for IgnoringMessageHandler {
	fn handle_message(
		&self, _message: OffersMessage, _context: Option<OffersContext>,
		_responder: Option<Responder>,
	) -> Option<(OffersMessage, ResponseInstruction)> {
		None
	}
}
impl AsyncPaymentsMessageHandler for IgnoringMessageHandler {
	fn handle_offer_paths_request(
		&self, _message: OfferPathsRequest, _context: AsyncPaymentsContext,
		_responder: Option<Responder>,
	) -> Option<(OfferPaths, ResponseInstruction)> {
		None
	}
	fn handle_offer_paths(
		&self, _message: OfferPaths, _context: AsyncPaymentsContext, _responder: Option<Responder>,
	) -> Option<(ServeStaticInvoice, ResponseInstruction)> {
		None
	}
	fn handle_serve_static_invoice(
		&self, _message: ServeStaticInvoice, _context: AsyncPaymentsContext,
		_responder: Option<Responder>,
	) {
	}
	fn handle_static_invoice_persisted(
		&self, _message: StaticInvoicePersisted, _context: AsyncPaymentsContext,
	) {
	}
	fn handle_held_htlc_available(
		&self, _message: HeldHtlcAvailable, _context: AsyncPaymentsContext,
		_responder: Option<Responder>,
	) -> Option<(ReleaseHeldHtlc, ResponseInstruction)> {
		None
	}
	fn handle_release_held_htlc(&self, _message: ReleaseHeldHtlc, _context: AsyncPaymentsContext) {}
}
impl DNSResolverMessageHandler for IgnoringMessageHandler {
	fn handle_dnssec_query(
		&self, _message: DNSSECQuery, _responder: Option<Responder>,
	) -> Option<(DNSResolverMessage, ResponseInstruction)> {
		None
	}
	fn handle_dnssec_proof(&self, _message: DNSSECProof, _context: DNSResolverContext) {}
}
impl CustomOnionMessageHandler for IgnoringMessageHandler {
	type CustomMessage = Infallible;
	fn handle_custom_message(
		&self, _message: Infallible, _context: Option<Vec<u8>>, _responder: Option<Responder>,
	) -> Option<(Infallible, ResponseInstruction)> {
		// Since we always return `None` in the read the handle method should never be called.
		unreachable!();
	}
	fn read_custom_message<R: io::Read>(
		&self, _msg_type: u64, _buffer: &mut R,
	) -> Result<Option<Infallible>, msgs::DecodeError>
	where
		Self: Sized,
	{
		Ok(None)
	}
	fn release_pending_custom_messages(&self) -> Vec<(Infallible, MessageSendInstructions)> {
		vec![]
	}
}

impl SendOnlyMessageHandler for IgnoringMessageHandler {}

impl OnionMessageContents for Infallible {
	fn tlv_type(&self) -> u64 {
		unreachable!();
	}
	#[cfg(c_bindings)]
	fn msg_type(&self) -> String {
		unreachable!();
	}
	#[cfg(not(c_bindings))]
	fn msg_type(&self) -> &'static str {
		unreachable!();
	}
}

impl Deref for IgnoringMessageHandler {
	type Target = IgnoringMessageHandler;
	fn deref(&self) -> &Self {
		self
	}
}

// Implement Type for Infallible, note that it cannot be constructed, and thus you can never call a
// method that takes self for it.
impl wire::Type for Infallible {
	fn type_id(&self) -> u16 {
		unreachable!();
	}
}
impl Writeable for Infallible {
	fn write<W: Writer>(&self, _: &mut W) -> Result<(), io::Error> {
		unreachable!();
	}
}

impl wire::CustomMessageReader for IgnoringMessageHandler {
	type CustomMessage = Infallible;
	fn read<R: io::Read>(
		&self, _message_type: u16, _buffer: &mut R,
	) -> Result<Option<Self::CustomMessage>, msgs::DecodeError> {
		Ok(None)
	}
}

impl CustomMessageHandler for IgnoringMessageHandler {
	fn handle_custom_message(
		&self, _msg: Infallible, _sender_node_id: PublicKey,
	) -> Result<(), LightningError> {
		// Since we always return `None` in the read the handle method should never be called.
		unreachable!();
	}

	fn get_and_clear_pending_msg(&self) -> Vec<(PublicKey, Self::CustomMessage)> {
		Vec::new()
	}

	fn peer_disconnected(&self, _their_node_id: PublicKey) {}

	fn peer_connected(
		&self, _their_node_id: PublicKey, _msg: &Init, _inbound: bool,
	) -> Result<(), ()> {
		Ok(())
	}

	fn provided_node_features(&self) -> NodeFeatures {
		NodeFeatures::empty()
	}

	fn provided_init_features(&self, _their_node_id: PublicKey) -> InitFeatures {
		InitFeatures::empty()
	}
}

/// A dummy struct which implements `ChannelMessageHandler` without having any channels.
/// You can provide one of these as the route_handler in a MessageHandler.
pub struct ErroringMessageHandler {
	message_queue: Mutex<Vec<MessageSendEvent>>,
}
impl ErroringMessageHandler {
	/// Constructs a new ErroringMessageHandler
	pub fn new() -> Self {
		Self { message_queue: Mutex::new(Vec::new()) }
	}
	fn push_error(&self, node_id: PublicKey, channel_id: ChannelId) {
		self.message_queue.lock().unwrap().push(MessageSendEvent::HandleError {
			action: msgs::ErrorAction::SendErrorMessage {
				msg: msgs::ErrorMessage {
					channel_id,
					data: "We do not support channel messages, sorry.".to_owned(),
				},
			},
			node_id,
		});
	}
}
impl BaseMessageHandler for ErroringMessageHandler {
	fn peer_disconnected(&self, _their_node_id: PublicKey) {}
	fn peer_connected(
		&self, _their_node_id: PublicKey, _init: &msgs::Init, _inbound: bool,
	) -> Result<(), ()> {
		Ok(())
	}
	fn provided_node_features(&self) -> NodeFeatures {
		NodeFeatures::empty()
	}
	fn provided_init_features(&self, _their_node_id: PublicKey) -> InitFeatures {
		// Set a number of features which various nodes may require to talk to us. It's totally
		// reasonable to indicate we "support" all kinds of channel features...we just reject all
		// channels.
		let mut features = InitFeatures::empty();
		features.set_data_loss_protect_optional();
		features.set_upfront_shutdown_script_optional();
		features.set_variable_length_onion_optional();
		features.set_static_remote_key_optional();
		features.set_payment_secret_optional();
		features.set_basic_mpp_optional();
		features.set_wumbo_optional();
		features.set_shutdown_any_segwit_optional();
		features.set_dual_fund_optional();
		features.set_channel_type_optional();
		features.set_scid_privacy_optional();
		features.set_zero_conf_optional();
		features.set_route_blinding_optional();
		#[cfg(simple_close)]
		features.set_simple_close_optional();
		features
	}

	fn get_and_clear_pending_msg_events(&self) -> Vec<MessageSendEvent> {
		let mut res = Vec::new();
		mem::swap(&mut res, &mut self.message_queue.lock().unwrap());
		res
	}
}
impl ChannelMessageHandler for ErroringMessageHandler {
	// Any messages which are related to a specific channel generate an error message to let the
	// peer know we don't care about channels.
	fn handle_open_channel(&self, their_node_id: PublicKey, msg: &msgs::OpenChannel) {
		ErroringMessageHandler::push_error(
			self,
			their_node_id,
			msg.common_fields.temporary_channel_id,
		);
	}
	fn handle_accept_channel(&self, their_node_id: PublicKey, msg: &msgs::AcceptChannel) {
		ErroringMessageHandler::push_error(
			self,
			their_node_id,
			msg.common_fields.temporary_channel_id,
		);
	}
	fn handle_funding_created(&self, their_node_id: PublicKey, msg: &msgs::FundingCreated) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.temporary_channel_id);
	}
	fn handle_funding_signed(&self, their_node_id: PublicKey, msg: &msgs::FundingSigned) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	fn handle_channel_ready(&self, their_node_id: PublicKey, msg: &msgs::ChannelReady) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	fn handle_shutdown(&self, their_node_id: PublicKey, msg: &msgs::Shutdown) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	fn handle_closing_signed(&self, their_node_id: PublicKey, msg: &msgs::ClosingSigned) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	#[cfg(simple_close)]
	fn handle_closing_complete(&self, their_node_id: PublicKey, msg: msgs::ClosingComplete) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	#[cfg(simple_close)]
	fn handle_closing_sig(&self, their_node_id: PublicKey, msg: msgs::ClosingSig) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	fn handle_stfu(&self, their_node_id: PublicKey, msg: &msgs::Stfu) {
		ErroringMessageHandler::push_error(&self, their_node_id, msg.channel_id);
	}
	#[cfg(splicing)]
	fn handle_splice_init(&self, their_node_id: PublicKey, msg: &msgs::SpliceInit) {
		ErroringMessageHandler::push_error(&self, their_node_id, msg.channel_id);
	}
	#[cfg(splicing)]
	fn handle_splice_ack(&self, their_node_id: PublicKey, msg: &msgs::SpliceAck) {
		ErroringMessageHandler::push_error(&self, their_node_id, msg.channel_id);
	}
	#[cfg(splicing)]
	fn handle_splice_locked(&self, their_node_id: PublicKey, msg: &msgs::SpliceLocked) {
		ErroringMessageHandler::push_error(&self, their_node_id, msg.channel_id);
	}
	fn handle_update_add_htlc(&self, their_node_id: PublicKey, msg: &msgs::UpdateAddHTLC) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	fn handle_update_fulfill_htlc(&self, their_node_id: PublicKey, msg: msgs::UpdateFulfillHTLC) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	fn handle_update_fail_htlc(&self, their_node_id: PublicKey, msg: &msgs::UpdateFailHTLC) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	fn handle_update_fail_malformed_htlc(
		&self, their_node_id: PublicKey, msg: &msgs::UpdateFailMalformedHTLC,
	) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	fn handle_commitment_signed(&self, their_node_id: PublicKey, msg: &msgs::CommitmentSigned) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	fn handle_commitment_signed_batch(
		&self, their_node_id: PublicKey, channel_id: ChannelId, _batch: Vec<msgs::CommitmentSigned>,
	) {
		ErroringMessageHandler::push_error(self, their_node_id, channel_id);
	}
	fn handle_revoke_and_ack(&self, their_node_id: PublicKey, msg: &msgs::RevokeAndACK) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	fn handle_update_fee(&self, their_node_id: PublicKey, msg: &msgs::UpdateFee) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	fn handle_announcement_signatures(
		&self, their_node_id: PublicKey, msg: &msgs::AnnouncementSignatures,
	) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	fn handle_channel_reestablish(&self, their_node_id: PublicKey, msg: &msgs::ChannelReestablish) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}
	// msgs::ChannelUpdate does not contain the channel_id field, so we just drop them.
	fn handle_channel_update(&self, _their_node_id: PublicKey, _msg: &msgs::ChannelUpdate) {}

	fn handle_peer_storage(&self, _their_node_id: PublicKey, _msg: msgs::PeerStorage) {}
	fn handle_peer_storage_retrieval(
		&self, _their_node_id: PublicKey, _msg: msgs::PeerStorageRetrieval,
	) {
	}

	fn handle_error(&self, _their_node_id: PublicKey, _msg: &msgs::ErrorMessage) {}

	fn get_chain_hashes(&self) -> Option<Vec<ChainHash>> {
		// We don't enforce any chains upon peer connection for `ErroringMessageHandler` and leave it up
		// to users of `ErroringMessageHandler` to make decisions on network compatiblility.
		// There's not really any way to pull in specific networks here, and hardcoding can cause breakages.
		None
	}

	fn handle_open_channel_v2(&self, their_node_id: PublicKey, msg: &msgs::OpenChannelV2) {
		ErroringMessageHandler::push_error(
			self,
			their_node_id,
			msg.common_fields.temporary_channel_id,
		);
	}

	fn handle_accept_channel_v2(&self, their_node_id: PublicKey, msg: &msgs::AcceptChannelV2) {
		ErroringMessageHandler::push_error(
			self,
			their_node_id,
			msg.common_fields.temporary_channel_id,
		);
	}

	fn handle_tx_add_input(&self, their_node_id: PublicKey, msg: &msgs::TxAddInput) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}

	fn handle_tx_add_output(&self, their_node_id: PublicKey, msg: &msgs::TxAddOutput) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}

	fn handle_tx_remove_input(&self, their_node_id: PublicKey, msg: &msgs::TxRemoveInput) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}

	fn handle_tx_remove_output(&self, their_node_id: PublicKey, msg: &msgs::TxRemoveOutput) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}

	fn handle_tx_complete(&self, their_node_id: PublicKey, msg: &msgs::TxComplete) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}

	fn handle_tx_signatures(&self, their_node_id: PublicKey, msg: &msgs::TxSignatures) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}

	fn handle_tx_init_rbf(&self, their_node_id: PublicKey, msg: &msgs::TxInitRbf) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}

	fn handle_tx_ack_rbf(&self, their_node_id: PublicKey, msg: &msgs::TxAckRbf) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}

	fn handle_tx_abort(&self, their_node_id: PublicKey, msg: &msgs::TxAbort) {
		ErroringMessageHandler::push_error(self, their_node_id, msg.channel_id);
	}

	fn message_received(&self) {}
}

impl Deref for ErroringMessageHandler {
	type Target = ErroringMessageHandler;
	fn deref(&self) -> &Self {
		self
	}
}

/// Provides references to trait impls which handle different types of messages.
pub struct MessageHandler<CM: Deref, RM: Deref, OM: Deref, CustomM: Deref, SM: Deref>
where
	CM::Target: ChannelMessageHandler,
	RM::Target: RoutingMessageHandler,
	OM::Target: OnionMessageHandler,
	CustomM::Target: CustomMessageHandler,
	SM::Target: SendOnlyMessageHandler,
{
	/// A message handler which handles messages specific to channels. Usually this is just a
	/// [`ChannelManager`] object or an [`ErroringMessageHandler`].
	///
	/// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
	pub chan_handler: CM,
	/// A message handler which handles messages updating our knowledge of the network channel
	/// graph. Usually this is just a [`P2PGossipSync`] object or an [`IgnoringMessageHandler`].
	///
	/// [`P2PGossipSync`]: crate::routing::gossip::P2PGossipSync
	pub route_handler: RM,

	/// A message handler which handles onion messages. This should generally be an
	/// [`OnionMessenger`], but can also be an [`IgnoringMessageHandler`].
	///
	/// [`OnionMessenger`]: crate::onion_message::messenger::OnionMessenger
	pub onion_message_handler: OM,

	/// A message handler which handles custom messages. The only LDK-provided implementation is
	/// [`IgnoringMessageHandler`].
	pub custom_message_handler: CustomM,

	/// A message handler which can be used to send messages.
	///
	/// This should generally be a [`ChainMonitor`].
	///
	/// [`ChainMonitor`]: crate::chain::chainmonitor::ChainMonitor
	pub send_only_message_handler: SM,
}

/// Provides an object which can be used to send data to and which uniquely identifies a connection
/// to a remote host. You will need to be able to generate multiple of these which meet Eq and
/// implement Hash to meet the PeerManager API.
///
/// For efficiency, [`Clone`] should be relatively cheap for this type.
///
/// Two descriptors may compare equal (by [`cmp::Eq`] and [`hash::Hash`]) as long as the original
/// has been disconnected, the [`PeerManager`] has been informed of the disconnection (either by it
/// having triggered the disconnection or a call to [`PeerManager::socket_disconnected`]), and no
/// further calls to the [`PeerManager`] related to the original socket occur. This allows you to
/// use a file descriptor for your SocketDescriptor directly, however for simplicity you may wish
/// to simply use another value which is guaranteed to be globally unique instead.
pub trait SocketDescriptor: cmp::Eq + hash::Hash + Clone {
	/// Attempts to send some data from the given slice to the peer.
	///
	/// Returns the amount of data which was sent, possibly 0 if the socket has since disconnected.
	/// Note that in the disconnected case, [`PeerManager::socket_disconnected`] must still be
	/// called and further write attempts may occur until that time.
	///
	/// If the returned size is smaller than `data.len()`, a
	/// [`PeerManager::write_buffer_space_avail`] call must be made the next time more data can be
	/// written. Additionally, until a `send_data` event completes fully, no further
	/// [`PeerManager::read_event`] calls should be made for the same peer! Because this is to
	/// prevent denial-of-service issues, you should not read or buffer any data from the socket
	/// until then.
	///
	/// If a [`PeerManager::read_event`] call on this descriptor had previously returned true
	/// (indicating that read events should be paused to prevent DoS in the send buffer),
	/// `resume_read` may be set indicating that read events on this descriptor should resume. A
	/// `resume_read` of false carries no meaning, and should not cause any action.
	fn send_data(&mut self, data: &[u8], resume_read: bool) -> usize;
	/// Disconnect the socket pointed to by this SocketDescriptor.
	///
	/// You do *not* need to call [`PeerManager::socket_disconnected`] with this socket after this
	/// call (doing so is a noop).
	fn disconnect_socket(&mut self);
}

/// Details of a connected peer as returned by [`PeerManager::list_peers`].
pub struct PeerDetails {
	/// The node id of the peer.
	///
	/// For outbound connections, this [`PublicKey`] will be the same as the `their_node_id` parameter
	/// passed in to [`PeerManager::new_outbound_connection`].
	pub counterparty_node_id: PublicKey,
	/// The socket address the peer provided in the initial handshake.
	///
	/// Will only be `Some` if an address had been previously provided to
	/// [`PeerManager::new_outbound_connection`] or [`PeerManager::new_inbound_connection`].
	pub socket_address: Option<SocketAddress>,
	/// The features the peer provided in the initial handshake.
	pub init_features: InitFeatures,
	/// Indicates the direction of the peer connection.
	///
	/// Will be `true` for inbound connections, and `false` for outbound connections.
	pub is_inbound_connection: bool,
}

/// Error for PeerManager errors. If you get one of these, you must disconnect the socket and
/// generate no further read_event/write_buffer_space_avail/socket_disconnected calls for the
/// descriptor.
#[derive(Clone)]
pub struct PeerHandleError {}
impl fmt::Debug for PeerHandleError {
	fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {
		formatter.write_str("Peer Sent Invalid Data")
	}
}
impl fmt::Display for PeerHandleError {
	fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {
		formatter.write_str("Peer Sent Invalid Data")
	}
}

/// Internal struct for keeping track of the gossip syncing progress with a given peer
enum InitSyncTracker {
	/// Only sync ad-hoc gossip as it comes in, do not send historical gossip.
	/// Upon receipt of a GossipTimestampFilter message, this is the default initial state if the
	/// contained timestamp is less than 6 hours old.
	NoSyncRequested,
	/// Send historical gossip starting at the given channel id, which gets incremented as the
	/// gossiping progresses.
	/// Upon receipt of a GossipTimestampFilter message, this is the default initial state if the
	/// contained timestamp is at least 6 hours old, and the initial channel id is set to 0.
	ChannelsSyncing(u64),
	/// Once the channel announcements and updates finish syncing, the node announcements are synced.
	NodesSyncing(NodeId),
}

/// A batch of messages initiated when receiving a `start_batch` message.
struct MessageBatch {
	/// The channel associated with all the messages in the batch.
	channel_id: ChannelId,

	/// The number of messages expected to be in the batch.
	batch_size: usize,

	/// The batch of messages, which should all be of the same type.
	messages: MessageBatchImpl,
}

/// The representation of the message batch, which may different for each message type.
enum MessageBatchImpl {
	/// A batch of `commitment_signed` messages used when there are pending splices.
	CommitmentSigned(Vec<msgs::CommitmentSigned>),
}

/// The ratio between buffer sizes at which we stop sending initial sync messages vs when we stop
/// forwarding gossip messages to peers altogether.
const FORWARD_INIT_SYNC_BUFFER_LIMIT_RATIO: usize = 2;

/// When the outbound buffer has this many messages, we'll stop reading bytes from the peer until
/// we have fewer than this many messages in the outbound buffer again.
/// We also use this as the target number of outbound gossip messages to keep in the write buffer,
/// refilled as we send bytes.
const OUTBOUND_BUFFER_LIMIT_READ_PAUSE: usize = 12;
/// When the outbound buffer has this many messages, we'll simply skip relaying gossip messages to
/// the peer.
const OUTBOUND_BUFFER_LIMIT_DROP_GOSSIP: usize =
	OUTBOUND_BUFFER_LIMIT_READ_PAUSE * FORWARD_INIT_SYNC_BUFFER_LIMIT_RATIO;

/// If we've sent a ping, and are still awaiting a response, we may need to churn our way through
/// the socket receive buffer before receiving the ping.
///
/// On a fairly old Arm64 board, with Linux defaults, this can take as long as 20 seconds, not
/// including any network delays, outbound traffic, or the same for messages from other peers.
///
/// Thus, to avoid needlessly disconnecting a peer, we allow a peer to take this many timer ticks
/// per connected peer to respond to a ping, as long as they send us at least one message during
/// each tick, ensuring we aren't actually just disconnected.
/// With a timer tick interval of ten seconds, this translates to about 40 seconds per connected
/// peer.
///
/// When we improve parallelism somewhat we should reduce this to e.g. this many timer ticks per
/// two connected peers, assuming most LDK-running systems have at least two cores.
const MAX_BUFFER_DRAIN_TICK_INTERVALS_PER_PEER: i8 = 4;

/// This is the minimum number of messages we expect a peer to be able to handle within one timer
/// tick. Once we have sent this many messages since the last ping, we send a ping right away to
/// ensures we don't just fill up our send buffer and leave the peer with too many messages to
/// process before the next ping.
///
/// Note that we continue responding to other messages even after we've sent this many messages, so
/// it's more of a general guideline used for gossip backfill (and gossip forwarding, times
/// [`FORWARD_INIT_SYNC_BUFFER_LIMIT_RATIO`]) than a hard limit.
const BUFFER_DRAIN_MSGS_PER_TICK: usize = 32;

struct Peer {
	channel_encryptor: PeerChannelEncryptor,
	/// We cache a `NodeId` here to avoid serializing peers' keys every time we forward gossip
	/// messages in `PeerManager`. Use `Peer::set_their_node_id` to modify this field.
	their_node_id: Option<(PublicKey, NodeId)>,
	/// The features provided in the peer's [`msgs::Init`] message.
	///
	/// This is set only after we've processed the [`msgs::Init`] message and called relevant
	/// `peer_connected` handler methods. Thus, this field is set *iff* we've finished our
	/// handshake and can talk to this peer normally (though use [`Peer::handshake_complete`] to
	/// check this.
	their_features: Option<InitFeatures>,
	their_socket_address: Option<SocketAddress>,

	pending_outbound_buffer: VecDeque<Vec<u8>>,
	pending_outbound_buffer_first_msg_offset: usize,
	/// Queue gossip broadcasts separately from `pending_outbound_buffer` so we can easily
	/// prioritize channel messages over them.
	///
	/// Note that these messages are *not* encrypted/MAC'd, and are only serialized.
	gossip_broadcast_buffer: VecDeque<MessageBuf>,
	awaiting_write_event: bool,

	pending_read_buffer: Vec<u8>,
	pending_read_buffer_pos: usize,
	pending_read_is_header: bool,

	sync_status: InitSyncTracker,

	msgs_sent_since_pong: usize,
	awaiting_pong_timer_tick_intervals: i64,
	ping_pong_span: Option<BoxedSpan>,
	received_message_since_timer_tick: bool,
	sent_gossip_timestamp_filter: bool,

	/// Indicates we've received a `channel_announcement` since the last time we had
	/// [`PeerManager::gossip_processing_backlogged`] set (or, really, that we've received a
	/// `channel_announcement` at all - we set this unconditionally but unset it every time we
	/// check if we're gossip-processing-backlogged).
	received_channel_announce_since_backlogged: bool,

	inbound_connection: bool,

	message_batch: Option<MessageBatch>,
}

impl Peer {
	/// True after we've processed the [`msgs::Init`] message and called relevant `peer_connected`
	/// handler methods. Thus, this implies we've finished our handshake and can talk to this peer
	/// normally.
	fn handshake_complete(&self) -> bool {
		self.their_features.is_some()
	}

	/// Returns true if the channel announcements/updates for the given channel should be
	/// forwarded to this peer.
	/// If we are sending our routing table to this peer and we have not yet sent channel
	/// announcements/updates for the given channel_id then we will send it when we get to that
	/// point and we shouldn't send it yet to avoid sending duplicate updates. If we've already
	/// sent the old versions, we should send the update, and so return true here.
	fn should_forward_channel_announcement(&self, channel_id: u64) -> bool {
		if !self.handshake_complete() {
			return false;
		}
		if self.their_features.as_ref().unwrap().supports_gossip_queries()
			&& !self.sent_gossip_timestamp_filter
		{
			return false;
		}
		match self.sync_status {
			InitSyncTracker::NoSyncRequested => true,
			InitSyncTracker::ChannelsSyncing(i) => i < channel_id,
			InitSyncTracker::NodesSyncing(_) => true,
		}
	}

	/// Similar to the above, but for node announcements indexed by node_id.
	fn should_forward_node_announcement(&self, node_id: NodeId) -> bool {
		if !self.handshake_complete() {
			return false;
		}
		if self.their_features.as_ref().unwrap().supports_gossip_queries()
			&& !self.sent_gossip_timestamp_filter
		{
			return false;
		}
		match self.sync_status {
			InitSyncTracker::NoSyncRequested => true,
			InitSyncTracker::ChannelsSyncing(_) => false,
			InitSyncTracker::NodesSyncing(sync_node_id) => {
				sync_node_id.as_slice() < node_id.as_slice()
			},
		}
	}

	/// Returns whether we should be reading bytes from this peer, based on whether its outbound
	/// buffer still has space and we don't need to pause reads to get some writes out.
	fn should_read(&mut self, gossip_processing_backlogged: bool) -> bool {
		if !gossip_processing_backlogged {
			self.received_channel_announce_since_backlogged = false;
		}
		self.pending_outbound_buffer.len() < OUTBOUND_BUFFER_LIMIT_READ_PAUSE
			&& (!gossip_processing_backlogged || !self.received_channel_announce_since_backlogged)
	}

	/// Determines if we should push additional gossip background sync (aka "backfill") onto a peer's
	/// outbound buffer. This is checked every time the peer's buffer may have been drained.
	fn should_buffer_gossip_backfill(&self) -> bool {
		self.pending_outbound_buffer.is_empty()
			&& self.gossip_broadcast_buffer.is_empty()
			&& self.msgs_sent_since_pong < BUFFER_DRAIN_MSGS_PER_TICK
			&& self.handshake_complete()
	}

	/// Determines if we should push an onion message onto a peer's outbound buffer. This is checked
	/// every time the peer's buffer may have been drained.
	fn should_buffer_onion_message(&self) -> bool {
		self.pending_outbound_buffer.is_empty()
			&& self.handshake_complete()
			&& self.msgs_sent_since_pong < BUFFER_DRAIN_MSGS_PER_TICK
	}

	/// Determines if we should push additional gossip broadcast messages onto a peer's outbound
	/// buffer. This is checked every time the peer's buffer may have been drained.
	fn should_buffer_gossip_broadcast(&self) -> bool {
		self.pending_outbound_buffer.is_empty()
			&& self.handshake_complete()
			&& self.msgs_sent_since_pong < BUFFER_DRAIN_MSGS_PER_TICK
	}

	/// Returns whether this peer's outbound buffers are full and we should drop gossip broadcasts.
	fn buffer_full_drop_gossip_broadcast(&self) -> bool {
		let total_outbound_buffered =
			self.gossip_broadcast_buffer.len() + self.pending_outbound_buffer.len();

		total_outbound_buffered > OUTBOUND_BUFFER_LIMIT_DROP_GOSSIP
			|| self.msgs_sent_since_pong
				> BUFFER_DRAIN_MSGS_PER_TICK * FORWARD_INIT_SYNC_BUFFER_LIMIT_RATIO
	}

	fn set_their_node_id(&mut self, node_id: PublicKey) {
		self.their_node_id = Some((node_id, NodeId::from_pubkey(&node_id)));
	}
}

/// SimpleArcPeerManager is useful when you need a PeerManager with a static lifetime, e.g.
/// when you're using lightning-net-tokio (since tokio::spawn requires parameters with static
/// lifetimes). Other times you can afford a reference, which is more efficient, in which case
/// SimpleRefPeerManager is the more appropriate type. Defining these type aliases prevents
/// issues such as overly long function definitions.
///
/// This is not exported to bindings users as type aliases aren't supported in most languages.
#[cfg(not(c_bindings))]
pub type SimpleArcPeerManager<SD, M, T, F, C, L, CF, S> = PeerManager<
	SD,
	Arc<SimpleArcChannelManager<M, T, F, L>>,
	Arc<P2PGossipSync<Arc<NetworkGraph<Arc<L>>>, C, Arc<L>>>,
	Arc<SimpleArcOnionMessenger<M, T, F, L>>,
	Arc<L>,
	IgnoringMessageHandler,
	Arc<KeysManager>,
	Arc<ChainMonitor<InMemorySigner, Arc<CF>, Arc<T>, Arc<F>, Arc<L>, Arc<S>, Arc<KeysManager>>>,
>;

/// SimpleRefPeerManager is a type alias for a PeerManager reference, and is the reference
/// counterpart to the SimpleArcPeerManager type alias. Use this type by default when you don't
/// need a PeerManager with a static lifetime. You'll need a static lifetime in cases such as
/// usage of lightning-net-tokio (since tokio::spawn requires parameters with static lifetimes).
/// But if this is not necessary, using a reference is more efficient. Defining these type aliases
/// helps with issues such as long function definitions.
///
/// This is not exported to bindings users as type aliases aren't supported in most languages.
#[cfg(not(c_bindings))]
#[rustfmt::skip]
pub type SimpleRefPeerManager<
	'a, 'b, 'c, 'd, 'e, 'f, 'logger, 'h, 'i, 'j, 'graph, 'k, 'mr, SD, M, T, F, C, L
> = PeerManager<
	SD,
	&'j SimpleRefChannelManager<'a, 'b, 'c, 'd, 'e, 'graph, 'logger, 'i, 'mr, M, T, F, L>,
	&'f P2PGossipSync<&'graph NetworkGraph<&'logger L>, C, &'logger L>,
	&'h SimpleRefOnionMessenger<'a, 'b, 'c, 'd, 'e, 'graph, 'logger, 'i, 'j, 'k, M, T, F, L>,
	&'logger L,
	IgnoringMessageHandler,
	&'c KeysManager,
	&'j ChainMonitor<&'a M, C, &'b T, &'c F, &'logger L, &'c KeysManager, &'c KeysManager>,
>;

/// A generic trait which is implemented for all [`PeerManager`]s. This makes bounding functions or
/// structs on any [`PeerManager`] much simpler as only this trait is needed as a bound, rather
/// than the full set of bounds on [`PeerManager`] itself.
///
/// This is not exported to bindings users as general cover traits aren't useful in other
/// languages.
#[allow(missing_docs)]
pub trait APeerManager {
	type Descriptor: SocketDescriptor;
	type CMT: ChannelMessageHandler + ?Sized;
	type CM: Deref<Target = Self::CMT>;
	type RMT: RoutingMessageHandler + ?Sized;
	type RM: Deref<Target = Self::RMT>;
	type OMT: OnionMessageHandler + ?Sized;
	type OM: Deref<Target = Self::OMT>;
	type LT: Logger + ?Sized;
	type L: Deref<Target = Self::LT>;
	type CMHT: CustomMessageHandler + ?Sized;
	type CMH: Deref<Target = Self::CMHT>;
	type NST: NodeSigner + ?Sized;
	type NS: Deref<Target = Self::NST>;
	type SMT: SendOnlyMessageHandler + ?Sized;
	type SM: Deref<Target = Self::SMT>;
	/// Gets a reference to the underlying [`PeerManager`].
	fn as_ref(
		&self,
	) -> &PeerManager<
		Self::Descriptor,
		Self::CM,
		Self::RM,
		Self::OM,
		Self::L,
		Self::CMH,
		Self::NS,
		Self::SM,
	>;
}

impl<
		Descriptor: SocketDescriptor,
		CM: Deref,
		RM: Deref,
		OM: Deref,
		L: Deref,
		CMH: Deref,
		NS: Deref,
		SM: Deref,
	> APeerManager for PeerManager<Descriptor, CM, RM, OM, L, CMH, NS, SM>
where
	CM::Target: ChannelMessageHandler,
	RM::Target: RoutingMessageHandler,
	OM::Target: OnionMessageHandler,
	L::Target: Logger,
	CMH::Target: CustomMessageHandler,
	NS::Target: NodeSigner,
	SM::Target: SendOnlyMessageHandler,
{
	type Descriptor = Descriptor;
	type CMT = <CM as Deref>::Target;
	type CM = CM;
	type RMT = <RM as Deref>::Target;
	type RM = RM;
	type OMT = <OM as Deref>::Target;
	type OM = OM;
	type LT = <L as Deref>::Target;
	type L = L;
	type CMHT = <CMH as Deref>::Target;
	type CMH = CMH;
	type NST = <NS as Deref>::Target;
	type NS = NS;
	type SMT = <SM as Deref>::Target;
	type SM = SM;
	fn as_ref(&self) -> &PeerManager<Descriptor, CM, RM, OM, L, CMH, NS, SM> {
		self
	}
}

/// A PeerManager manages a set of peers, described by their [`SocketDescriptor`] and marshalls
/// socket events into messages which it passes on to its [`MessageHandler`].
///
/// Locks are taken internally, so you must never assume that reentrancy from a
/// [`SocketDescriptor`] call back into [`PeerManager`] methods will not deadlock.
///
/// Calls to [`read_event`] will decode relevant messages and pass them to the
/// [`ChannelMessageHandler`], likely doing message processing in-line. Thus, the primary form of
/// parallelism in Rust-Lightning is in calls to [`read_event`]. Note, however, that calls to any
/// [`PeerManager`] functions related to the same connection must occur only in serial, making new
/// calls only after previous ones have returned.
///
/// Rather than using a plain [`PeerManager`], it is preferable to use either a [`SimpleArcPeerManager`]
/// a [`SimpleRefPeerManager`], for conciseness. See their documentation for more details, but
/// essentially you should default to using a [`SimpleRefPeerManager`], and use a
/// [`SimpleArcPeerManager`] when you require a `PeerManager` with a static lifetime, such as when
/// you're using lightning-net-tokio.
///
/// [`read_event`]: PeerManager::read_event
pub struct PeerManager<
	Descriptor: SocketDescriptor,
	CM: Deref,
	RM: Deref,
	OM: Deref,
	L: Deref,
	CMH: Deref,
	NS: Deref,
	SM: Deref,
> where
	CM::Target: ChannelMessageHandler,
	RM::Target: RoutingMessageHandler,
	OM::Target: OnionMessageHandler,
	L::Target: Logger,
	CMH::Target: CustomMessageHandler,
	NS::Target: NodeSigner,
	SM::Target: SendOnlyMessageHandler,
{
	message_handler: MessageHandler<CM, RM, OM, CMH, SM>,
	/// Connection state for each connected peer - we have an outer read-write lock which is taken
	/// as read while we're doing processing for a peer and taken write when a peer is being added
	/// or removed.
	///
	/// The inner Peer lock is held for sending and receiving bytes, but note that we do *not* hold
	/// it while we're processing a message. This is fine as [`PeerManager::read_event`] requires
	/// that there be no parallel calls for a given peer, so mutual exclusion of messages handed to
	/// the `MessageHandler`s for a given peer is already guaranteed.
	peers: FairRwLock<HashMap<Descriptor, Mutex<Peer>>>,
	/// Only add to this set when noise completes.
	/// Locked *after* peers. When an item is removed, it must be removed with the `peers` write
	/// lock held. Entries may be added with only the `peers` read lock held (though the
	/// `Descriptor` value must already exist in `peers`).
	node_id_to_descriptor: Mutex<HashMap<PublicKey, Descriptor>>,
	/// We can only have one thread processing events at once, but if a second call to
	/// `process_events` happens while a first call is in progress, one of the two calls needs to
	/// start from the top to ensure any new messages are also handled.
	///
	/// Because the event handler calls into user code which may block, we don't want to block a
	/// second thread waiting for another thread to handle events which is then blocked on user
	/// code, so we store an atomic counter here:
	///  * 0 indicates no event processor is running
	///  * 1 indicates an event processor is running
	///  * > 1 indicates an event processor is running but needs to start again from the top once
	///        it finishes as another thread tried to start processing events but returned early.
	event_processing_state: AtomicI32,

	/// Used to track the last value sent in a node_announcement "timestamp" field. We ensure this
	/// value increases strictly since we don't assume access to a time source.
	last_node_announcement_serial: AtomicU32,

	ephemeral_key_midstate: Sha256Engine,

	peer_counter: AtomicCounter,

	gossip_processing_backlogged: AtomicBool,
	gossip_processing_backlog_lifted: AtomicBool,

	node_signer: NS,

	logger: L,
	secp_ctx: Secp256k1<secp256k1::SignOnly>,
}

enum LogicalMessage<T: core::fmt::Debug + wire::Type + wire::TestEq> {
	FromWire(wire::Message<T>),
	CommitmentSignedBatch(ChannelId, Vec<msgs::CommitmentSigned>),
}

enum MessageHandlingError {
	PeerHandleError(PeerHandleError),
	LightningError(LightningError),
}

impl From<PeerHandleError> for MessageHandlingError {
	fn from(error: PeerHandleError) -> Self {
		MessageHandlingError::PeerHandleError(error)
	}
}

impl From<LightningError> for MessageHandlingError {
	fn from(error: LightningError) -> Self {
		MessageHandlingError::LightningError(error)
	}
}

macro_rules! encode_msg {
	($msg: expr) => {{
		let mut buffer = VecWriter(Vec::with_capacity(MSG_BUF_ALLOC_SIZE));
		wire::write($msg, &mut buffer).unwrap();
		buffer.0
	}};
}

impl<Descriptor: SocketDescriptor, CM: Deref, OM: Deref, L: Deref, NS: Deref, SM: Deref>
	PeerManager<Descriptor, CM, IgnoringMessageHandler, OM, L, IgnoringMessageHandler, NS, SM>
where
	CM::Target: ChannelMessageHandler,
	OM::Target: OnionMessageHandler,
	L::Target: Logger,
	NS::Target: NodeSigner,
	SM::Target: SendOnlyMessageHandler,
{
	/// Constructs a new `PeerManager` with the given `ChannelMessageHandler` and
	/// `OnionMessageHandler`. No routing message handler is used and network graph messages are
	/// ignored.
	///
	/// `ephemeral_random_data` is used to derive per-connection ephemeral keys and must be
	/// cryptographically secure random bytes.
	///
	/// `current_time` is used as an always-increasing counter that survives across restarts and is
	/// incremented irregularly internally. In general it is best to simply use the current UNIX
	/// timestamp, however if it is not available a persistent counter that increases once per
	/// minute should suffice.
	///
	/// This is not exported to bindings users as we can't export a PeerManager with a dummy route handler
	pub fn new_channel_only(
		channel_message_handler: CM, onion_message_handler: OM, current_time: u32,
		ephemeral_random_data: &[u8; 32], logger: L, node_signer: NS,
		send_only_message_handler: SM,
	) -> Self {
		Self::new(
			MessageHandler {
				chan_handler: channel_message_handler,
				route_handler: IgnoringMessageHandler {},
				onion_message_handler,
				custom_message_handler: IgnoringMessageHandler {},
				send_only_message_handler,
			},
			current_time,
			ephemeral_random_data,
			logger,
			node_signer,
		)
	}
}

impl<Descriptor: SocketDescriptor, RM: Deref, L: Deref, NS: Deref>
	PeerManager<
		Descriptor,
		ErroringMessageHandler,
		RM,
		IgnoringMessageHandler,
		L,
		IgnoringMessageHandler,
		NS,
		IgnoringMessageHandler,
	> where
	RM::Target: RoutingMessageHandler,
	L::Target: Logger,
	NS::Target: NodeSigner,
{
	/// Constructs a new `PeerManager` with the given `RoutingMessageHandler`. No channel message
	/// handler or onion message handler is used and onion and channel messages will be ignored (or
	/// generate error messages). Note that some other lightning implementations time-out connections
	/// after some time if no channel is built with the peer.
	///
	/// `current_time` is used as an always-increasing counter that survives across restarts and is
	/// incremented irregularly internally. In general it is best to simply use the current UNIX
	/// timestamp, however if it is not available a persistent counter that increases once per
	/// minute should suffice.
	///
	/// `ephemeral_random_data` is used to derive per-connection ephemeral keys and must be
	/// cryptographically secure random bytes.
	///
	/// This is not exported to bindings users as we can't export a PeerManager with a dummy channel handler
	pub fn new_routing_only(
		routing_message_handler: RM, current_time: u32, ephemeral_random_data: &[u8; 32],
		logger: L, node_signer: NS,
	) -> Self {
		Self::new(
			MessageHandler {
				chan_handler: ErroringMessageHandler::new(),
				route_handler: routing_message_handler,
				onion_message_handler: IgnoringMessageHandler {},
				custom_message_handler: IgnoringMessageHandler {},
				send_only_message_handler: IgnoringMessageHandler {},
			},
			current_time,
			ephemeral_random_data,
			logger,
			node_signer,
		)
	}
}

/// A simple wrapper that optionally prints ` from <pubkey>` for an optional pubkey.
/// This works around `format!()` taking a reference to each argument, preventing
/// `if let Some(node_id) = peer.their_node_id { format!(.., node_id) } else { .. }` from compiling
/// due to lifetime errors.
struct OptionalFromDebugger<'a>(&'a Option<(PublicKey, NodeId)>);
impl core::fmt::Display for OptionalFromDebugger<'_> {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> Result<(), core::fmt::Error> {
		if let Some((node_id, _)) = self.0 {
			write!(f, " from {}", node_id)
		} else {
			Ok(())
		}
	}
}

/// A function used to filter out local or private addresses
/// <https://www.iana.org./assignments/ipv4-address-space/ipv4-address-space.xhtml>
/// <https://www.iana.org/assignments/ipv6-address-space/ipv6-address-space.xhtml>
fn filter_addresses(ip_address: Option<SocketAddress>) -> Option<SocketAddress> {
	match ip_address {
		// For IPv4 range 10.0.0.0 - 10.255.255.255 (10/8)
		Some(SocketAddress::TcpIpV4 { addr: [10, _, _, _], port: _ }) => None,
		// For IPv4 range 0.0.0.0 - 0.255.255.255 (0/8)
		Some(SocketAddress::TcpIpV4 { addr: [0, _, _, _], port: _ }) => None,
		// For IPv4 range 100.64.0.0 - 100.127.255.255 (100.64/10)
		Some(SocketAddress::TcpIpV4 { addr: [100, 64..=127, _, _], port: _ }) => None,
		// For IPv4 range  	127.0.0.0 - 127.255.255.255 (127/8)
		Some(SocketAddress::TcpIpV4 { addr: [127, _, _, _], port: _ }) => None,
		// For IPv4 range  	169.254.0.0 - 169.254.255.255 (169.254/16)
		Some(SocketAddress::TcpIpV4 { addr: [169, 254, _, _], port: _ }) => None,
		// For IPv4 range 172.16.0.0 - 172.31.255.255 (172.16/12)
		Some(SocketAddress::TcpIpV4 { addr: [172, 16..=31, _, _], port: _ }) => None,
		// For IPv4 range 192.168.0.0 - 192.168.255.255 (192.168/16)
		Some(SocketAddress::TcpIpV4 { addr: [192, 168, _, _], port: _ }) => None,
		// For IPv4 range 192.88.99.0 - 192.88.99.255  (192.88.99/24)
		Some(SocketAddress::TcpIpV4 { addr: [192, 88, 99, _], port: _ }) => None,
		// For IPv6 range 2000:0000:0000:0000:0000:0000:0000:0000 - 3fff:ffff:ffff:ffff:ffff:ffff:ffff:ffff (2000::/3)
		Some(SocketAddress::TcpIpV6 {
			addr: [0x20..=0x3F, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _],
			port: _,
		}) => ip_address,
		// For remaining addresses
		Some(SocketAddress::TcpIpV6 { addr: _, port: _ }) => None,
		Some(..) => ip_address,
		None => None,
	}
}

impl<
		Descriptor: SocketDescriptor,
		CM: Deref,
		RM: Deref,
		OM: Deref,
		L: Deref,
		CMH: Deref,
		NS: Deref,
		SM: Deref,
	> PeerManager<Descriptor, CM, RM, OM, L, CMH, NS, SM>
where
	CM::Target: ChannelMessageHandler,
	RM::Target: RoutingMessageHandler,
	OM::Target: OnionMessageHandler,
	L::Target: Logger,
	CMH::Target: CustomMessageHandler,
	NS::Target: NodeSigner,
	SM::Target: SendOnlyMessageHandler,
{
	/// Constructs a new `PeerManager` with the given message handlers.
	///
	/// `ephemeral_random_data` is used to derive per-connection ephemeral keys and must be
	/// cryptographically secure random bytes.
	///
	/// `current_time` is used as an always-increasing counter that survives across restarts and is
	/// incremented irregularly internally. In general it is best to simply use the current UNIX
	/// timestamp, however if it is not available a persistent counter that increases once per
	/// minute should suffice.
	pub fn new(
		message_handler: MessageHandler<CM, RM, OM, CMH, SM>, current_time: u32,
		ephemeral_random_data: &[u8; 32], logger: L, node_signer: NS,
	) -> Self {
		let mut ephemeral_key_midstate = Sha256::engine();
		ephemeral_key_midstate.input(ephemeral_random_data);

		let mut secp_ctx = Secp256k1::signing_only();
		let ephemeral_hash = Sha256::from_engine(ephemeral_key_midstate.clone()).to_byte_array();
		secp_ctx.seeded_randomize(&ephemeral_hash);

		PeerManager {
			message_handler,
			peers: FairRwLock::new(new_hash_map()),
			node_id_to_descriptor: Mutex::new(new_hash_map()),
			event_processing_state: AtomicI32::new(0),
			ephemeral_key_midstate,
			peer_counter: AtomicCounter::new(),
			gossip_processing_backlogged: AtomicBool::new(false),
			gossip_processing_backlog_lifted: AtomicBool::new(false),
			last_node_announcement_serial: AtomicU32::new(current_time),
			logger,
			node_signer,
			secp_ctx,
		}
	}

	/// Returns a list of [`PeerDetails`] for connected peers that have completed the initial
	/// handshake.
	pub fn list_peers(&self) -> Vec<PeerDetails> {
		let peers = self.peers.read().unwrap();
		let filter_fn = |peer_mutex: &Mutex<Peer>| {
			let p = peer_mutex.lock().unwrap();
			if !p.handshake_complete() {
				return None;
			}
			let details = PeerDetails {
				// unwrap safety: their_node_id is guaranteed to be `Some` after the handshake
				// completed.
				counterparty_node_id: p.their_node_id.unwrap().0,
				socket_address: p.their_socket_address.clone(),
				// unwrap safety: their_features is guaranteed to be `Some` after the handshake
				// completed.
				init_features: p.their_features.clone().unwrap(),
				is_inbound_connection: p.inbound_connection,
			};
			Some(details)
		};
		peers.values().filter_map(filter_fn).collect()
	}

	/// Returns the [`PeerDetails`] of a connected peer that has completed the initial handshake.
	///
	/// Will return `None` if the peer is unknown or it hasn't completed the initial handshake.
	pub fn peer_by_node_id(&self, their_node_id: &PublicKey) -> Option<PeerDetails> {
		let peers = self.peers.read().unwrap();
		peers.values().find_map(|peer_mutex| {
			let p = peer_mutex.lock().unwrap();
			if !p.handshake_complete() {
				return None;
			}

			// unwrap safety: their_node_id is guaranteed to be `Some` after the handshake
			// completed.
			let counterparty_node_id = p.their_node_id.unwrap().0;

			if counterparty_node_id != *their_node_id {
				return None;
			}

			let details = PeerDetails {
				counterparty_node_id,
				socket_address: p.their_socket_address.clone(),
				// unwrap safety: their_features is guaranteed to be `Some` after the handshake
				// completed.
				init_features: p.their_features.clone().unwrap(),
				is_inbound_connection: p.inbound_connection,
			};
			Some(details)
		})
	}

	fn get_ephemeral_key(&self) -> SecretKey {
		let mut ephemeral_hash = self.ephemeral_key_midstate.clone();
		let counter = self.peer_counter.next();
		ephemeral_hash.input(&counter.to_le_bytes());
		SecretKey::from_slice(&Sha256::from_engine(ephemeral_hash).to_byte_array())
			.expect("You broke SHA-256!")
	}

	fn init_features(&self, their_node_id: PublicKey) -> InitFeatures {
		self.message_handler.chan_handler.provided_init_features(their_node_id)
			| self.message_handler.route_handler.provided_init_features(their_node_id)
			| self.message_handler.onion_message_handler.provided_init_features(their_node_id)
			| self.message_handler.custom_message_handler.provided_init_features(their_node_id)
			| self.message_handler.send_only_message_handler.provided_init_features(their_node_id)
	}

	/// Indicates a new outbound connection has been established to a node with the given `node_id`
	/// and an optional remote network address.
	///
	/// The remote network address adds the option to report a remote IP address back to a connecting
	/// peer using the init message.
	/// The user should pass the remote network address of the host they are connected to.
	///
	/// If an `Err` is returned here you must disconnect the connection immediately.
	///
	/// Returns a small number of bytes to send to the remote node (currently always 50).
	///
	/// Panics if descriptor is duplicative with some other descriptor which has not yet been
	/// [`socket_disconnected`].
	///
	/// [`socket_disconnected`]: PeerManager::socket_disconnected
	pub fn new_outbound_connection(
		&self, their_node_id: PublicKey, descriptor: Descriptor,
		remote_network_address: Option<SocketAddress>,
	) -> Result<Vec<u8>, PeerHandleError> {
		let mut peer_encryptor =
			PeerChannelEncryptor::new_outbound(their_node_id.clone(), self.get_ephemeral_key());
		let res = peer_encryptor.get_act_one(&self.secp_ctx).to_vec();
		let pending_read_buffer = [0; 50].to_vec(); // Noise act two is 50 bytes

		let mut peers = self.peers.write().unwrap();
		match peers.entry(descriptor) {
			hash_map::Entry::Occupied(_) => {
				debug_assert!(false, "PeerManager driver duplicated descriptors!");
				Err(PeerHandleError {})
			},
			hash_map::Entry::Vacant(e) => {
				e.insert(Mutex::new(Peer {
					channel_encryptor: peer_encryptor,
					their_node_id: None,
					their_features: None,
					their_socket_address: remote_network_address,

					pending_outbound_buffer: VecDeque::new(),
					pending_outbound_buffer_first_msg_offset: 0,
					gossip_broadcast_buffer: VecDeque::new(),
					awaiting_write_event: false,

					pending_read_buffer,
					pending_read_buffer_pos: 0,
					pending_read_is_header: false,

					sync_status: InitSyncTracker::NoSyncRequested,

					msgs_sent_since_pong: 0,
					awaiting_pong_timer_tick_intervals: 0,
					ping_pong_span: None,
					received_message_since_timer_tick: false,
					sent_gossip_timestamp_filter: false,

					received_channel_announce_since_backlogged: false,
					inbound_connection: false,

					message_batch: None,
				}));
				Ok(res)
			},
		}
	}

	/// Indicates a new inbound connection has been established to a node with an optional remote
	/// network address.
	///
	/// The remote network address adds the option to report a remote IP address back to a connecting
	/// peer using the init message.
	/// The user should pass the remote network address of the host they are connected to.
	///
	/// May refuse the connection by returning an Err, but will never write bytes to the remote end
	/// (outbound connector always speaks first). If an `Err` is returned here you must disconnect
	/// the connection immediately.
	///
	/// Panics if descriptor is duplicative with some other descriptor which has not yet been
	/// [`socket_disconnected`].
	///
	/// [`socket_disconnected`]: PeerManager::socket_disconnected
	pub fn new_inbound_connection(
		&self, descriptor: Descriptor, remote_network_address: Option<SocketAddress>,
	) -> Result<(), PeerHandleError> {
		let peer_encryptor = PeerChannelEncryptor::new_inbound(&self.node_signer);
		let pending_read_buffer = [0; 50].to_vec(); // Noise act one is 50 bytes

		let mut peers = self.peers.write().unwrap();
		match peers.entry(descriptor) {
			hash_map::Entry::Occupied(_) => {
				debug_assert!(false, "PeerManager driver duplicated descriptors!");
				Err(PeerHandleError {})
			},
			hash_map::Entry::Vacant(e) => {
				e.insert(Mutex::new(Peer {
					channel_encryptor: peer_encryptor,
					their_node_id: None,
					their_features: None,
					their_socket_address: remote_network_address,

					pending_outbound_buffer: VecDeque::new(),
					pending_outbound_buffer_first_msg_offset: 0,
					gossip_broadcast_buffer: VecDeque::new(),
					awaiting_write_event: false,

					pending_read_buffer,
					pending_read_buffer_pos: 0,
					pending_read_is_header: false,

					sync_status: InitSyncTracker::NoSyncRequested,

					msgs_sent_since_pong: 0,
					awaiting_pong_timer_tick_intervals: 0,
					ping_pong_span: None,
					received_message_since_timer_tick: false,
					sent_gossip_timestamp_filter: false,

					received_channel_announce_since_backlogged: false,
					inbound_connection: true,

					message_batch: None,
				}));
				Ok(())
			},
		}
	}

	fn peer_should_read(&self, peer: &mut Peer) -> bool {
		peer.should_read(self.gossip_processing_backlogged.load(Ordering::Relaxed))
	}

	fn update_gossip_backlogged(&self) {
		let new_state = self.message_handler.route_handler.processing_queue_high();
		let prev_state = self.gossip_processing_backlogged.swap(new_state, Ordering::Relaxed);
		if prev_state && !new_state {
			self.gossip_processing_backlog_lifted.store(true, Ordering::Relaxed);
		}
	}

	fn do_attempt_write_data(
		&self, descriptor: &mut Descriptor, peer: &mut Peer, force_one_write: bool,
	) {
		let mut have_written = false;
		while !peer.awaiting_write_event {
			if peer.should_buffer_onion_message() {
				if let Some((peer_node_id, _)) = peer.their_node_id {
					let handler = &self.message_handler.onion_message_handler;
					if let Some(next_onion_message) =
						handler.next_onion_message_for_peer(peer_node_id)
					{
						self.enqueue_message(peer, &next_onion_message);
					}
				}
			}
			if peer.should_buffer_gossip_broadcast() {
				if let Some(msg) = peer.gossip_broadcast_buffer.pop_front() {
					peer.pending_outbound_buffer
						.push_back(peer.channel_encryptor.encrypt_buffer(msg));
				}
			}
			if peer.should_buffer_gossip_backfill() {
				match peer.sync_status {
					InitSyncTracker::NoSyncRequested => {},
					InitSyncTracker::ChannelsSyncing(c) if c < 0xffff_ffff_ffff_ffff => {
						if let Some((announce, update_a_option, update_b_option)) =
							self.message_handler.route_handler.get_next_channel_announcement(c)
						{
							self.enqueue_message(peer, &announce);
							if let Some(update_a) = update_a_option {
								self.enqueue_message(peer, &update_a);
							}
							if let Some(update_b) = update_b_option {
								self.enqueue_message(peer, &update_b);
							}
							peer.sync_status = InitSyncTracker::ChannelsSyncing(
								announce.contents.short_channel_id + 1,
							);
						} else {
							peer.sync_status =
								InitSyncTracker::ChannelsSyncing(0xffff_ffff_ffff_ffff);
						}
					},
					InitSyncTracker::ChannelsSyncing(c) if c == 0xffff_ffff_ffff_ffff => {
						let handler = &self.message_handler.route_handler;
						if let Some(msg) = handler.get_next_node_announcement(None) {
							self.enqueue_message(peer, &msg);
							peer.sync_status = InitSyncTracker::NodesSyncing(msg.contents.node_id);
						} else {
							peer.sync_status = InitSyncTracker::NoSyncRequested;
						}
					},
					InitSyncTracker::ChannelsSyncing(_) => unreachable!(),
					InitSyncTracker::NodesSyncing(sync_node_id) => {
						let handler = &self.message_handler.route_handler;
						if let Some(msg) = handler.get_next_node_announcement(Some(&sync_node_id)) {
							self.enqueue_message(peer, &msg);
							peer.sync_status = InitSyncTracker::NodesSyncing(msg.contents.node_id);
						} else {
							peer.sync_status = InitSyncTracker::NoSyncRequested;
						}
					},
				}
			}
			if peer.msgs_sent_since_pong >= BUFFER_DRAIN_MSGS_PER_TICK {
				self.maybe_send_extra_ping(peer);
			}

			let should_read = self.peer_should_read(peer);
			let next_buff = match peer.pending_outbound_buffer.front() {
				None => {
					if force_one_write && !have_written {
						if should_read {
							let data_sent = descriptor.send_data(&[], should_read);
							debug_assert_eq!(data_sent, 0, "Can't write more than no data");
						}
					}
					return;
				},
				Some(buff) => buff,
			};

			let pending = &next_buff[peer.pending_outbound_buffer_first_msg_offset..];
			let data_sent = descriptor.send_data(pending, should_read);
			have_written = true;
			peer.pending_outbound_buffer_first_msg_offset += data_sent;
			if peer.pending_outbound_buffer_first_msg_offset == next_buff.len() {
				peer.pending_outbound_buffer_first_msg_offset = 0;
				peer.pending_outbound_buffer.pop_front();
				const VEC_SIZE: usize = ::core::mem::size_of::<Vec<u8>>();
				let large_capacity = peer.pending_outbound_buffer.capacity() > 4096 / VEC_SIZE;
				let lots_of_slack = peer.pending_outbound_buffer.len()
					< peer.pending_outbound_buffer.capacity() / 2;
				if large_capacity && lots_of_slack {
					peer.pending_outbound_buffer.shrink_to_fit();
				}
			} else {
				peer.awaiting_write_event = true;
			}
		}
	}

	/// Indicates that there is room to write data to the given socket descriptor.
	///
	/// May return an Err to indicate that the connection should be closed.
	///
	/// May call [`send_data`] on the descriptor passed in (or an equal descriptor) before
	/// returning. Thus, be very careful with reentrancy issues! The invariants around calling
	/// [`write_buffer_space_avail`] in case a write did not fully complete must still hold - be
	/// ready to call [`write_buffer_space_avail`] again if a write call generated here isn't
	/// sufficient!
	///
	/// [`send_data`]: SocketDescriptor::send_data
	/// [`write_buffer_space_avail`]: PeerManager::write_buffer_space_avail
	pub fn write_buffer_space_avail(
		&self, descriptor: &mut Descriptor,
	) -> Result<(), PeerHandleError> {
		let peers = self.peers.read().unwrap();
		match peers.get(descriptor) {
			None => {
				// This is most likely a simple race condition where the user found that the socket
				// was writeable, then we told the user to `disconnect_socket()`, then they called
				// this method. Return an error to make sure we get disconnected.
				return Err(PeerHandleError {});
			},
			Some(peer_mutex) => {
				let mut peer = peer_mutex.lock().unwrap();
				peer.awaiting_write_event = false;
				self.do_attempt_write_data(descriptor, &mut peer, false);
			},
		};
		Ok(())
	}

	/// Indicates that data was read from the given socket descriptor.
	///
	/// May return an Err to indicate that the connection should be closed.
	///
	/// Will *not* call back into [`send_data`] on any descriptors to avoid reentrancy complexity.
	/// Thus, however, you should call [`process_events`] after any `read_event` to generate
	/// [`send_data`] calls to handle responses.
	///
	/// If `Ok(true)` is returned, further read_events should not be triggered until a
	/// [`send_data`] call on this descriptor has `resume_read` set (preventing DoS issues in the
	/// send buffer).
	///
	/// In order to avoid processing too many messages at once per peer, `data` should be on the
	/// order of 4KiB.
	///
	/// [`send_data`]: SocketDescriptor::send_data
	/// [`process_events`]: PeerManager::process_events
	pub fn read_event(
		&self, peer_descriptor: &mut Descriptor, data: &[u8],
	) -> Result<bool, PeerHandleError> {
		match self.do_read_event(peer_descriptor, data) {
			Ok(res) => Ok(res),
			Err(e) => {
				self.disconnect_event_internal(peer_descriptor, "of a protocol error");
				Err(e)
			},
		}
	}

	/// Append a message to a peer's pending outbound/write buffer
	fn enqueue_message<M: wire::Type>(&self, peer: &mut Peer, message: &M) {
		let their_node_id = peer.their_node_id.map(|p| p.0);
		if let Some(node_id) = their_node_id {
			let logger = WithContext::from(&self.logger, their_node_id, None, None);
			if is_gossip_msg(message.type_id()) {
				log_gossip!(logger, "Enqueueing message {:?} to {}", message, node_id);
			} else {
				log_trace!(logger, "Enqueueing message {:?} to {}", message, node_id);
			}
		} else {
			debug_assert!(false, "node_id should be set by the time we send a message");
		}
		peer.msgs_sent_since_pong += 1;
		peer.pending_outbound_buffer.push_back(peer.channel_encryptor.encrypt_message(message));
	}

	/// Append a message to a peer's pending outbound/write gossip broadcast buffer
	fn enqueue_encoded_gossip_broadcast(&self, peer: &mut Peer, encoded_message: MessageBuf) {
		peer.msgs_sent_since_pong += 1;
		peer.gossip_broadcast_buffer.push_back(encoded_message);
	}

	fn do_read_event(
		&self, peer_descriptor: &mut Descriptor, data: &[u8],
	) -> Result<bool, PeerHandleError> {
		let mut pause_read = false;
		let peers = self.peers.read().unwrap();
		let mut msgs_to_forward = Vec::new();
		let mut peer_node_id = None;

		if let Some(peer_mutex) = peers.get(peer_descriptor) {
			let mut read_pos = 0;
			while read_pos < data.len() {
				macro_rules! try_potential_handleerror {
					($peer: expr, $thing: expr) => {{
						let res = $thing;
						let logger = WithContext::from(&self.logger, peer_node_id.map(|(id, _)| id), None, None);
						match res {
							Ok(x) => x,
							Err(e) => {
								match e.action {
									msgs::ErrorAction::DisconnectPeer { .. } => {
										// We may have an `ErrorMessage` to send to the peer,
										// but writing to the socket while reading can lead to
										// re-entrant code and possibly unexpected behavior. The
										// message send is optimistic anyway, and in this case
										// we immediately disconnect the peer.
										log_debug!(logger, "Error handling message{}; disconnecting peer with: {}", OptionalFromDebugger(&peer_node_id), e.err);
										return Err(PeerHandleError { });
									},
									msgs::ErrorAction::DisconnectPeerWithWarning { .. } => {
										// We have a `WarningMessage` to send to the peer, but
										// writing to the socket while reading can lead to
										// re-entrant code and possibly unexpected behavior. The
										// message send is optimistic anyway, and in this case
										// we immediately disconnect the peer.
										log_debug!(logger, "Error handling message{}; disconnecting peer with: {}", OptionalFromDebugger(&peer_node_id), e.err);
										return Err(PeerHandleError { });
									},
									msgs::ErrorAction::IgnoreAndLog(level) => {
										log_given_level!(logger, level, "Error handling {}message{}; ignoring: {}",
											 if level == Level::Gossip { "gossip " } else { "" },
											 OptionalFromDebugger(&peer_node_id), e.err);
										continue
									},
									msgs::ErrorAction::IgnoreDuplicateGossip => continue, // Don't even bother logging these
									msgs::ErrorAction::IgnoreError => {
										log_debug!(logger, "Error handling message{}; ignoring: {}", OptionalFromDebugger(&peer_node_id), e.err);
										continue;
									},
									msgs::ErrorAction::SendErrorMessage { msg } => {
										log_debug!(logger, "Error handling message{}; sending error message with: {}", OptionalFromDebugger(&peer_node_id), e.err);
										self.enqueue_message($peer, &msg);
										continue;
									},
									msgs::ErrorAction::SendWarningMessage { msg, log_level } => {
										log_given_level!(logger, log_level, "Error handling message{}; sending warning message with: {}", OptionalFromDebugger(&peer_node_id), e.err);
										self.enqueue_message($peer, &msg);
										continue;
									},
								}
							}
						}
					}}
				}

				let mut peer_lock = peer_mutex.lock().unwrap();
				let peer = &mut *peer_lock;
				let mut msg_to_handle = None;
				if peer_node_id.is_none() {
					peer_node_id.clone_from(&peer.their_node_id);
				}

				assert!(peer.pending_read_buffer.len() > 0);
				assert!(peer.pending_read_buffer.len() > peer.pending_read_buffer_pos);

				{
					let data_to_copy = cmp::min(
						peer.pending_read_buffer.len() - peer.pending_read_buffer_pos,
						data.len() - read_pos,
					);
					peer.pending_read_buffer
						[peer.pending_read_buffer_pos..peer.pending_read_buffer_pos + data_to_copy]
						.copy_from_slice(&data[read_pos..read_pos + data_to_copy]);
					read_pos += data_to_copy;
					peer.pending_read_buffer_pos += data_to_copy;
				}

				if peer.pending_read_buffer_pos == peer.pending_read_buffer.len() {
					peer.pending_read_buffer_pos = 0;

					macro_rules! insert_node_id {
						() => {
							let their_node_id = if let Some((node_id, _)) = peer.their_node_id {
								node_id
							} else {
								debug_assert!(false, "Should have a node_id to insert");
								return Err(PeerHandleError {});
							};
							let logger = WithContext::from(&self.logger, Some(their_node_id), None, None);
							match self.node_id_to_descriptor.lock().unwrap().entry(their_node_id) {
								hash_map::Entry::Occupied(e) => {
									log_trace!(logger, "Got second connection with {}, closing", their_node_id);
									// Unset `their_node_id` so that we don't generate a peer_disconnected event
									peer.their_node_id = None;
									// Check that the peers map is consistent with the
									// node_id_to_descriptor map, as this has been broken
									// before.
									debug_assert!(peers.get(e.get()).is_some());
									return Err(PeerHandleError { })
								},
								hash_map::Entry::Vacant(entry) => {
									log_debug!(logger, "Finished noise handshake for connection with {}", their_node_id);
									entry.insert(peer_descriptor.clone())
								},
							};
						}
					}

					let next_step = peer.channel_encryptor.get_noise_step();
					match next_step {
						NextNoiseStep::ActOne => {
							let res = peer.channel_encryptor.process_act_one_with_keys(
								&peer.pending_read_buffer[..],
								&self.node_signer,
								self.get_ephemeral_key(),
								&self.secp_ctx,
							);
							let act_two = try_potential_handleerror!(peer, res).to_vec();
							peer.pending_outbound_buffer.push_back(act_two);
							peer.pending_read_buffer = [0; 66].to_vec(); // act three is 66 bytes long
						},
						NextNoiseStep::ActTwo => {
							let res = peer
								.channel_encryptor
								.process_act_two(&peer.pending_read_buffer[..], &self.node_signer);
							let (act_three, their_node_id) = try_potential_handleerror!(peer, res);
							peer.pending_outbound_buffer.push_back(act_three.to_vec());
							peer.pending_read_buffer = [0; 18].to_vec(); // Message length header is 18 bytes
							peer.pending_read_is_header = true;

							peer.set_their_node_id(their_node_id);
							insert_node_id!();
							let features = self.init_features(their_node_id);
							let networks = self.message_handler.chan_handler.get_chain_hashes();
							let resp = msgs::Init {
								features,
								networks,
								remote_network_address: filter_addresses(
									peer.their_socket_address.clone(),
								),
							};
							self.enqueue_message(peer, &resp);
						},
						NextNoiseStep::ActThree => {
							let res = peer
								.channel_encryptor
								.process_act_three(&peer.pending_read_buffer[..]);
							let their_node_id = try_potential_handleerror!(peer, res);
							peer.pending_read_buffer = [0; 18].to_vec(); // Message length header is 18 bytes
							peer.pending_read_is_header = true;
							peer.set_their_node_id(their_node_id);
							insert_node_id!();
							let features = self.init_features(their_node_id);
							let networks = self.message_handler.chan_handler.get_chain_hashes();
							let resp = msgs::Init {
								features,
								networks,
								remote_network_address: filter_addresses(
									peer.their_socket_address.clone(),
								),
							};
							self.enqueue_message(peer, &resp);
						},
						NextNoiseStep::NoiseComplete => {
							if peer.pending_read_is_header {
								let res = peer
									.channel_encryptor
									.decrypt_length_header(&peer.pending_read_buffer[..]);
								let msg_len = try_potential_handleerror!(peer, res);
								if peer.pending_read_buffer.capacity() > 8192 {
									peer.pending_read_buffer = Vec::new();
								}
								peer.pending_read_buffer.resize(msg_len as usize + 16, 0);
								if msg_len < 2 {
									// Need at least the message type tag
									return Err(PeerHandleError {});
								}
								peer.pending_read_is_header = false;
							} else {
								debug_assert!(peer.pending_read_buffer.len() >= 2 + 16);
								let res = peer
									.channel_encryptor
									.decrypt_message(&mut peer.pending_read_buffer[..]);
								try_potential_handleerror!(peer, res);

								let message_result = wire::read(
									&mut &peer.pending_read_buffer
										[..peer.pending_read_buffer.len() - 16],
									&*self.message_handler.custom_message_handler,
								);

								// Reset read buffer
								if peer.pending_read_buffer.capacity() > 8192 {
									peer.pending_read_buffer = Vec::new();
								}
								peer.pending_read_buffer.resize(18, 0);
								peer.pending_read_is_header = true;

								let their_node_id = peer.their_node_id.map(|p| p.0);
								let logger =
									WithContext::from(&self.logger, their_node_id, None, None);
								let message = match message_result {
									Ok(x) => x,
									Err(e) => {
										match e {
											// Note that to avoid re-entrancy we never call
											// `do_attempt_write_data` from here, causing
											// the messages enqueued here to not actually
											// be sent before the peer is disconnected.
											(
												msgs::DecodeError::UnknownRequiredFeature,
												Some(ty),
											) if is_gossip_msg(ty) => {
												log_gossip!(logger, "Got a channel/node announcement with an unknown required feature flag, you may want to update!");
												continue;
											},
											(msgs::DecodeError::UnsupportedCompression, _) => {
												log_gossip!(logger, "We don't support zlib-compressed message fields, sending a warning and ignoring message");
												let channel_id = ChannelId::new_zero();
												let data = "Unsupported message compression: zlib"
													.to_owned();
												let msg = msgs::WarningMessage { channel_id, data };
												self.enqueue_message(peer, &msg);
												continue;
											},
											(_, Some(ty)) if is_gossip_msg(ty) => {
												log_gossip!(logger, "Got an invalid value while deserializing a gossip message");
												let channel_id = ChannelId::new_zero();
												let data = format!(
													"Unreadable/bogus gossip message of type {}",
													ty
												);
												let msg = msgs::WarningMessage { channel_id, data };
												self.enqueue_message(peer, &msg);
												continue;
											},
											(msgs::DecodeError::UnknownRequiredFeature, _) => {
												log_debug!(logger, "Received a message with an unknown required feature flag or TLV, you may want to update!");
												return Err(PeerHandleError {});
											},
											(msgs::DecodeError::UnknownVersion, _) => {
												return Err(PeerHandleError {})
											},
											(msgs::DecodeError::InvalidValue, _) => {
												log_debug!(logger, "Got an invalid value while deserializing message");
												return Err(PeerHandleError {});
											},
											(msgs::DecodeError::ShortRead, _) => {
												log_debug!(logger, "Deserialization failed due to shortness of message");
												return Err(PeerHandleError {});
											},
											(msgs::DecodeError::BadLengthDescriptor, _) => {
												return Err(PeerHandleError {})
											},
											(msgs::DecodeError::Io(_), _) => {
												return Err(PeerHandleError {})
											},
											(msgs::DecodeError::DangerousValue, _) => {
												return Err(PeerHandleError {})
											},
										}
									},
								};

								msg_to_handle = Some(message);
							}
						},
					}
				}
				pause_read = !self.peer_should_read(peer);

				if let Some(message) = msg_to_handle {
					match self.handle_message(&peer_mutex, peer_lock, message) {
						Err(handling_error) => match handling_error {
							MessageHandlingError::PeerHandleError(e) => return Err(e),
							MessageHandlingError::LightningError(e) => {
								try_potential_handleerror!(&mut peer_mutex.lock().unwrap(), Err(e));
							},
						},
						Ok(Some(msg)) => {
							msgs_to_forward.push(msg);
						},
						Ok(None) => {},
					}
				}
			}
		} else {
			// This is most likely a simple race condition where the user read some bytes
			// from the socket, then we told the user to `disconnect_socket()`, then they
			// called this method. Return an error to make sure we get disconnected.
			return Err(PeerHandleError {});
		}

		for msg in msgs_to_forward.drain(..) {
			self.forward_broadcast_msg(
				&*peers,
				&msg,
				peer_node_id.as_ref().map(|(pk, _)| pk),
				false,
			);
		}

		Ok(pause_read)
	}

	/// Process an incoming message and return a decision (ok, lightning error, peer handling error) regarding the next action with the peer
	///
	/// Returns the message back if it needs to be broadcasted to all other peers.
	fn handle_message(
		&self, peer_mutex: &Mutex<Peer>, peer_lock: MutexGuard<Peer>,
		message: wire::Message<
			<<CMH as Deref>::Target as wire::CustomMessageReader>::CustomMessage,
		>,
	) -> Result<
		Option<wire::Message<<<CMH as Deref>::Target as wire::CustomMessageReader>::CustomMessage>>,
		MessageHandlingError,
	> {
		let their_node_id = peer_lock
			.their_node_id
			.expect("We know the peer's public key by the time we receive messages")
			.0;
		let logger = WithContext::from(&self.logger, Some(their_node_id), None, None);

		let unprocessed_message =
			self.do_handle_message_holding_peer_lock(peer_lock, message, their_node_id, &logger)?;

		self.message_handler.chan_handler.message_received();

		match unprocessed_message {
			Some(LogicalMessage::FromWire(message)) => self.do_handle_message_without_peer_lock(
				peer_mutex,
				message,
				their_node_id,
				&logger,
			),
			Some(LogicalMessage::CommitmentSignedBatch(channel_id, batch)) => {
				log_trace!(
					logger,
					"Received commitment_signed batch {:?} from {}",
					batch,
					their_node_id,
				);
				let chan_handler = &self.message_handler.chan_handler;
				chan_handler.handle_commitment_signed_batch(their_node_id, channel_id, batch);
				return Ok(None);
			},
			None => Ok(None),
		}
	}

	// Conducts all message processing that requires us to hold the `peer_lock`.
	//
	// Returns `None` if the message was fully processed and otherwise returns the message back to
	// allow it to be subsequently processed by `do_handle_message_without_peer_lock`.
	fn do_handle_message_holding_peer_lock<'a>(
		&self, mut peer_lock: MutexGuard<Peer>,
		message: wire::Message<
			<<CMH as Deref>::Target as wire::CustomMessageReader>::CustomMessage,
		>,
		their_node_id: PublicKey, logger: &WithContext<'a, L>,
	) -> Result<
		Option<
			LogicalMessage<<<CMH as Deref>::Target as wire::CustomMessageReader>::CustomMessage>,
		>,
		MessageHandlingError,
	> {
		peer_lock.received_message_since_timer_tick = true;

		// Need an Init as first message
		if let wire::Message::Init(msg) = message {
			// Check if we have any compatible chains if the `networks` field is specified.
			if let Some(networks) = &msg.networks {
				let chan_handler = &self.message_handler.chan_handler;
				if let Some(our_chains) = chan_handler.get_chain_hashes() {
					let mut have_compatible_chains = false;
					'our_chains: for our_chain in our_chains.iter() {
						for their_chain in networks {
							if our_chain == their_chain {
								have_compatible_chains = true;
								break 'our_chains;
							}
						}
					}
					if !have_compatible_chains {
						log_debug!(logger, "Peer does not support any of our supported chains");
						return Err(PeerHandleError {}.into());
					}
				}
			}

			let our_features = self.init_features(their_node_id);
			if msg.features.requires_unknown_bits_from(&our_features) {
				log_debug!(
					logger,
					"Peer {} requires features unknown to us: {:?}",
					their_node_id,
					msg.features.required_unknown_bits_from(&our_features)
				);
				return Err(PeerHandleError {}.into());
			}

			if our_features.requires_unknown_bits_from(&msg.features) {
				log_debug!(
					logger,
					"We require features unknown to our peer {}: {:?}",
					their_node_id,
					our_features.required_unknown_bits_from(&msg.features)
				);
				return Err(PeerHandleError {}.into());
			}

			if peer_lock.their_features.is_some() {
				return Err(PeerHandleError {}.into());
			}

			log_info!(
				logger,
				"Received peer Init message from {}: {}",
				their_node_id,
				msg.features
			);

			// For peers not supporting gossip queries start sync now, otherwise wait until we receive a filter.
			if msg.features.initial_routing_sync() && !msg.features.supports_gossip_queries() {
				peer_lock.sync_status = InitSyncTracker::ChannelsSyncing(0);
			}

			let inbound = peer_lock.inbound_connection;
			let route_handler = &self.message_handler.route_handler;
			if let Err(()) = route_handler.peer_connected(their_node_id, &msg, inbound) {
				log_debug!(
					logger,
					"Route Handler decided we couldn't communicate with peer {}",
					their_node_id,
				);
				return Err(PeerHandleError {}.into());
			}
			let chan_handler = &self.message_handler.chan_handler;
			if let Err(()) = chan_handler.peer_connected(their_node_id, &msg, inbound) {
				log_debug!(
					logger,
					"Channel Handler decided we couldn't communicate with peer {}",
					their_node_id,
				);
				self.message_handler.route_handler.peer_disconnected(their_node_id);
				return Err(PeerHandleError {}.into());
			}
			let onion_message_handler = &self.message_handler.onion_message_handler;
			if let Err(()) = onion_message_handler.peer_connected(their_node_id, &msg, inbound) {
				log_debug!(
					logger,
					"Onion Message Handler decided we couldn't communicate with peer {}",
					their_node_id,
				);
				self.message_handler.route_handler.peer_disconnected(their_node_id);
				self.message_handler.chan_handler.peer_disconnected(their_node_id);
				return Err(PeerHandleError {}.into());
			}
			let custom_handler = &self.message_handler.custom_message_handler;
			if let Err(()) = custom_handler.peer_connected(their_node_id, &msg, inbound) {
				log_debug!(
					logger,
					"Custom Message Handler decided we couldn't communicate with peer {}",
					their_node_id,
				);
				self.message_handler.route_handler.peer_disconnected(their_node_id);
				self.message_handler.chan_handler.peer_disconnected(their_node_id);
				self.message_handler.onion_message_handler.peer_disconnected(their_node_id);
				return Err(PeerHandleError {}.into());
			}
			let sends_handler = &self.message_handler.send_only_message_handler;
			if let Err(()) = sends_handler.peer_connected(their_node_id, &msg, inbound) {
				log_debug!(
					logger,
					"Sending-Only Message Handler decided we couldn't communicate with peer {}",
					their_node_id,
				);
				self.message_handler.route_handler.peer_disconnected(their_node_id);
				self.message_handler.chan_handler.peer_disconnected(their_node_id);
				self.message_handler.onion_message_handler.peer_disconnected(their_node_id);
				self.message_handler.custom_message_handler.peer_disconnected(their_node_id);
				return Err(PeerHandleError {}.into());
			}

			peer_lock.awaiting_pong_timer_tick_intervals = 0;
			peer_lock.their_features = Some(msg.features);
			return Ok(None);
		} else if peer_lock.their_features.is_none() {
			log_debug!(logger, "Peer {} sent non-Init first message", their_node_id);
			return Err(PeerHandleError {}.into());
		}

		// During splicing, commitment_signed messages need to be collected into a single batch
		// before they are handled.
		if let wire::Message::StartBatch(msg) = message {
			if peer_lock.message_batch.is_some() {
				let error = format!(
					"Peer {} sent start_batch for channel {} before previous batch completed",
					their_node_id, &msg.channel_id
				);
				log_debug!(logger, "{}", error);
				return Err(LightningError {
					err: error.clone(),
					action: msgs::ErrorAction::DisconnectPeerWithWarning {
						msg: msgs::WarningMessage { channel_id: msg.channel_id, data: error },
					},
				}
				.into());
			}

			let batch_size = msg.batch_size as usize;
			if batch_size <= 1 {
				let error = format!(
					"Peer {} sent start_batch for channel {} not strictly greater than 1",
					their_node_id, &msg.channel_id
				);
				log_debug!(logger, "{}", error);
				return Err(LightningError {
					err: error.clone(),
					action: msgs::ErrorAction::SendWarningMessage {
						msg: msgs::WarningMessage { channel_id: msg.channel_id, data: error },
						log_level: Level::Debug,
					},
				}
				.into());
			}

			const BATCH_SIZE_LIMIT: usize = 20;
			if batch_size > BATCH_SIZE_LIMIT {
				let error = format!(
					"Peer {} sent start_batch for channel {} exceeding the limit",
					their_node_id, &msg.channel_id
				);
				log_debug!(logger, "{}", error);
				return Err(LightningError {
					err: error.clone(),
					action: msgs::ErrorAction::DisconnectPeerWithWarning {
						msg: msgs::WarningMessage { channel_id: msg.channel_id, data: error },
					},
				}
				.into());
			}

			let messages = match msg.message_type {
				Some(message_type) if message_type == msgs::CommitmentSigned::TYPE => {
					let messages = Vec::with_capacity(batch_size);
					MessageBatchImpl::CommitmentSigned(messages)
				},
				_ => {
					log_debug!(
						logger,
						"Peer {} sent start_batch for channel {} without a known message type; ignoring",
						their_node_id,
						&msg.channel_id,
					);
					return Ok(None);
				},
			};

			let message_batch = MessageBatch { channel_id: msg.channel_id, batch_size, messages };
			peer_lock.message_batch = Some(message_batch);

			return Ok(None);
		}

		if let wire::Message::CommitmentSigned(msg) = message {
			if let Some(message_batch) = &mut peer_lock.message_batch {
				let MessageBatchImpl::CommitmentSigned(ref mut messages) =
					&mut message_batch.messages;

				if msg.channel_id != message_batch.channel_id {
					let error = format!("Peer {} sent batched commitment_signed for the wrong channel (expected: {}, actual: {})", their_node_id, message_batch.channel_id, &msg.channel_id);
					log_debug!(logger, "{}", error);
					return Err(LightningError {
						err: error.clone(),
						action: msgs::ErrorAction::DisconnectPeerWithWarning {
							msg: msgs::WarningMessage { channel_id: msg.channel_id, data: error },
						},
					}
					.into());
				}

				messages.push(msg);

				if messages.len() == message_batch.batch_size {
					let MessageBatch { channel_id, batch_size: _, messages } =
						peer_lock.message_batch.take().expect("batch should have been inserted");
					let MessageBatchImpl::CommitmentSigned(batch) = messages;

					return Ok(Some(LogicalMessage::CommitmentSignedBatch(channel_id, batch)));
				} else {
					return Ok(None);
				}
			} else {
				return Ok(Some(LogicalMessage::FromWire(wire::Message::CommitmentSigned(msg))));
			}
		} else if let Some(message_batch) = &peer_lock.message_batch {
			match message_batch.messages {
				MessageBatchImpl::CommitmentSigned(_) => {
					log_debug!(
						logger,
						"Peer {} sent an unexpected message for a commitment_signed batch",
						their_node_id,
					);
				},
			}

			return Err(PeerHandleError {}.into());
		}

		if let wire::Message::GossipTimestampFilter(_msg) = message {
			// When supporting gossip messages, start initial gossip sync only after we receive
			// a GossipTimestampFilter
			if peer_lock.their_features.as_ref().unwrap().supports_gossip_queries()
				&& !peer_lock.sent_gossip_timestamp_filter
			{
				peer_lock.sent_gossip_timestamp_filter = true;

				#[allow(unused_mut)]
				let mut should_do_full_sync = true;
				#[cfg(feature = "std")]
				{
					// Forward ad-hoc gossip if the timestamp range is less than six hours ago.
					// Otherwise, do a full sync.
					use std::time::{SystemTime, UNIX_EPOCH};
					let full_sync_threshold = SystemTime::now()
						.duration_since(UNIX_EPOCH)
						.expect("Time must be > 1970")
						.as_secs() - 6 * 3600;
					if (_msg.first_timestamp as u64) > full_sync_threshold {
						should_do_full_sync = false;
					}
				}
				if should_do_full_sync {
					peer_lock.sync_status = InitSyncTracker::ChannelsSyncing(0);
				} else {
					peer_lock.sync_status = InitSyncTracker::NoSyncRequested;
				}
			}
			return Ok(None);
		}

		if let wire::Message::ChannelAnnouncement(ref _msg) = message {
			peer_lock.received_channel_announce_since_backlogged = true;
		}

		Ok(Some(LogicalMessage::FromWire(message)))
	}

	// Conducts all message processing that doesn't require us to hold the `peer_lock`.
	//
	// Returns the message back if it needs to be broadcasted to all other peers.
	fn do_handle_message_without_peer_lock<'a>(
		&self, peer_mutex: &Mutex<Peer>,
		message: wire::Message<
			<<CMH as Deref>::Target as wire::CustomMessageReader>::CustomMessage,
		>,
		their_node_id: PublicKey, logger: &WithContext<'a, L>,
	) -> Result<
		Option<wire::Message<<<CMH as Deref>::Target as wire::CustomMessageReader>::CustomMessage>>,
		MessageHandlingError,
	> {
		if is_gossip_msg(message.type_id()) {
			log_gossip!(logger, "Received message {:?} from {}", message, their_node_id);
		} else {
			log_trace!(logger, "Received message {:?} from {}", message, their_node_id);
		}

		let mut should_forward = None;

		match message {
			// Setup and Control messages:
			wire::Message::Init(_) => {
				// Handled above
			},
			wire::Message::GossipTimestampFilter(_) => {
				// Handled above
			},
			wire::Message::Error(msg) => {
				log_debug!(
					logger,
					"Got Err message from {}: {}",
					their_node_id,
					PrintableString(&msg.data)
				);
				self.message_handler.chan_handler.handle_error(their_node_id, &msg);
				if msg.channel_id.is_zero() {
					return Err(PeerHandleError {}.into());
				}
			},
			wire::Message::Warning(msg) => {
				log_debug!(
					logger,
					"Got warning message from {}: {}",
					their_node_id,
					PrintableString(&msg.data)
				);
			},

			wire::Message::Ping(msg) => {
				if msg.ponglen < 65532 {
					let resp = msgs::Pong { byteslen: msg.ponglen };
					self.enqueue_message(&mut *peer_mutex.lock().unwrap(), &resp);
				}
			},
			wire::Message::Pong(_msg) => {
				let mut peer_lock = peer_mutex.lock().unwrap();
				peer_lock.awaiting_pong_timer_tick_intervals = 0;
				peer_lock.msgs_sent_since_pong = 0;
				peer_lock.ping_pong_span = None;
			},

			// Channel messages:
			wire::Message::StartBatch(_msg) => {
				debug_assert!(false);
			},
			wire::Message::OpenChannel(msg) => {
				self.message_handler.chan_handler.handle_open_channel(their_node_id, &msg);
			},
			wire::Message::OpenChannelV2(_msg) => {
				self.message_handler.chan_handler.handle_open_channel_v2(their_node_id, &_msg);
			},
			wire::Message::AcceptChannel(msg) => {
				self.message_handler.chan_handler.handle_accept_channel(their_node_id, &msg);
			},
			wire::Message::AcceptChannelV2(msg) => {
				self.message_handler.chan_handler.handle_accept_channel_v2(their_node_id, &msg);
			},

			wire::Message::FundingCreated(msg) => {
				self.message_handler.chan_handler.handle_funding_created(their_node_id, &msg);
			},
			wire::Message::FundingSigned(msg) => {
				self.message_handler.chan_handler.handle_funding_signed(their_node_id, &msg);
			},
			wire::Message::ChannelReady(msg) => {
				self.message_handler.chan_handler.handle_channel_ready(their_node_id, &msg);
			},
			wire::Message::PeerStorage(msg) => {
				self.message_handler.chan_handler.handle_peer_storage(their_node_id, msg);
			},
			wire::Message::PeerStorageRetrieval(msg) => {
				self.message_handler.chan_handler.handle_peer_storage_retrieval(their_node_id, msg);
			},

			// Quiescence messages:
			wire::Message::Stfu(msg) => {
				self.message_handler.chan_handler.handle_stfu(their_node_id, &msg);
			},

			#[cfg(splicing)]
			// Splicing messages:
			wire::Message::SpliceInit(msg) => {
				self.message_handler.chan_handler.handle_splice_init(their_node_id, &msg);
			},
			#[cfg(splicing)]
			wire::Message::SpliceAck(msg) => {
				self.message_handler.chan_handler.handle_splice_ack(their_node_id, &msg);
			},
			#[cfg(splicing)]
			wire::Message::SpliceLocked(msg) => {
				self.message_handler.chan_handler.handle_splice_locked(their_node_id, &msg);
			},

			// Interactive transaction construction messages:
			wire::Message::TxAddInput(msg) => {
				self.message_handler.chan_handler.handle_tx_add_input(their_node_id, &msg);
			},
			wire::Message::TxAddOutput(msg) => {
				self.message_handler.chan_handler.handle_tx_add_output(their_node_id, &msg);
			},
			wire::Message::TxRemoveInput(msg) => {
				self.message_handler.chan_handler.handle_tx_remove_input(their_node_id, &msg);
			},
			wire::Message::TxRemoveOutput(msg) => {
				self.message_handler.chan_handler.handle_tx_remove_output(their_node_id, &msg);
			},
			wire::Message::TxComplete(msg) => {
				self.message_handler.chan_handler.handle_tx_complete(their_node_id, &msg);
			},
			wire::Message::TxSignatures(msg) => {
				self.message_handler.chan_handler.handle_tx_signatures(their_node_id, &msg);
			},
			wire::Message::TxInitRbf(msg) => {
				self.message_handler.chan_handler.handle_tx_init_rbf(their_node_id, &msg);
			},
			wire::Message::TxAckRbf(msg) => {
				self.message_handler.chan_handler.handle_tx_ack_rbf(their_node_id, &msg);
			},
			wire::Message::TxAbort(msg) => {
				self.message_handler.chan_handler.handle_tx_abort(their_node_id, &msg);
			},

			wire::Message::Shutdown(msg) => {
				self.message_handler.chan_handler.handle_shutdown(their_node_id, &msg);
			},
			wire::Message::ClosingSigned(msg) => {
				self.message_handler.chan_handler.handle_closing_signed(their_node_id, &msg);
			},
			#[cfg(simple_close)]
			wire::Message::ClosingComplete(msg) => {
				self.message_handler.chan_handler.handle_closing_complete(their_node_id, msg);
			},
			#[cfg(simple_close)]
			wire::Message::ClosingSig(msg) => {
				self.message_handler.chan_handler.handle_closing_sig(their_node_id, msg);
			},

			// Commitment messages:
			wire::Message::UpdateAddHTLC(msg) => {
				self.message_handler.chan_handler.handle_update_add_htlc(their_node_id, &msg);
			},
			wire::Message::UpdateFulfillHTLC(msg) => {
				self.message_handler.chan_handler.handle_update_fulfill_htlc(their_node_id, msg);
			},
			wire::Message::UpdateFailHTLC(msg) => {
				self.message_handler.chan_handler.handle_update_fail_htlc(their_node_id, &msg);
			},
			wire::Message::UpdateFailMalformedHTLC(msg) => {
				let chan_handler = &self.message_handler.chan_handler;
				chan_handler.handle_update_fail_malformed_htlc(their_node_id, &msg);
			},

			wire::Message::CommitmentSigned(msg) => {
				self.message_handler.chan_handler.handle_commitment_signed(their_node_id, &msg);
			},
			wire::Message::RevokeAndACK(msg) => {
				self.message_handler.chan_handler.handle_revoke_and_ack(their_node_id, &msg);
			},
			wire::Message::UpdateFee(msg) => {
				self.message_handler.chan_handler.handle_update_fee(their_node_id, &msg);
			},
			wire::Message::ChannelReestablish(msg) => {
				self.message_handler.chan_handler.handle_channel_reestablish(their_node_id, &msg);
			},

			// Routing messages:
			wire::Message::AnnouncementSignatures(msg) => {
				let chan_handler = &self.message_handler.chan_handler;
				chan_handler.handle_announcement_signatures(their_node_id, &msg);
			},
			wire::Message::ChannelAnnouncement(msg) => {
				let route_handler = &self.message_handler.route_handler;
				if route_handler
					.handle_channel_announcement(Some(their_node_id), &msg)
					.map_err(|e| -> MessageHandlingError { e.into() })?
				{
					should_forward = Some(wire::Message::ChannelAnnouncement(msg));
				}
				self.update_gossip_backlogged();
			},
			wire::Message::NodeAnnouncement(msg) => {
				let route_handler = &self.message_handler.route_handler;
				if route_handler
					.handle_node_announcement(Some(their_node_id), &msg)
					.map_err(|e| -> MessageHandlingError { e.into() })?
				{
					should_forward = Some(wire::Message::NodeAnnouncement(msg));
				}
				self.update_gossip_backlogged();
			},
			wire::Message::ChannelUpdate(msg) => {
				let route_handler = &self.message_handler.route_handler;
				if route_handler
					.handle_channel_update(Some(their_node_id), &msg)
					.map_err(|e| -> MessageHandlingError { e.into() })?
				{
					should_forward = Some(wire::Message::ChannelUpdate(msg));
				}
				self.update_gossip_backlogged();
			},
			wire::Message::QueryShortChannelIds(msg) => {
				let route_handler = &self.message_handler.route_handler;
				route_handler.handle_query_short_channel_ids(their_node_id, msg)?;
			},
			wire::Message::ReplyShortChannelIdsEnd(msg) => {
				let route_handler = &self.message_handler.route_handler;
				route_handler.handle_reply_short_channel_ids_end(their_node_id, msg)?;
			},
			wire::Message::QueryChannelRange(msg) => {
				let route_handler = &self.message_handler.route_handler;
				route_handler.handle_query_channel_range(their_node_id, msg)?;
			},
			wire::Message::ReplyChannelRange(msg) => {
				let route_handler = &self.message_handler.route_handler;
				route_handler.handle_reply_channel_range(their_node_id, msg)?;
			},

			// Onion message:
			wire::Message::OnionMessage(msg) => {
				let onion_message_handler = &self.message_handler.onion_message_handler;
				onion_message_handler.handle_onion_message(their_node_id, &msg);
			},

			// Unknown messages:
			wire::Message::Unknown(type_id) if message.is_even() => {
				log_debug!(
					logger,
					"Received unknown even message of type {}, disconnecting peer!",
					type_id
				);
				return Err(PeerHandleError {}.into());
			},
			wire::Message::Unknown(type_id) => {
				log_trace!(logger, "Received unknown odd message of type {}, ignoring", type_id);
			},
			wire::Message::Custom(custom) => {
				let custom_message_handler = &self.message_handler.custom_message_handler;
				custom_message_handler.handle_custom_message(custom, their_node_id)?;
			},
		};
		Ok(should_forward)
	}

	/// Forwards a gossip `msg` to `peers` excluding node(s) that generated the gossip message and
	/// excluding `except_node`.
	///
	/// If the message queue for a peer is somewhat full, the message will not be forwarded to them
	/// unless `allow_large_buffer` is set, in which case the message will be treated as critical
	/// and delivered no matter the available buffer space.
	fn forward_broadcast_msg(
		&self, peers: &HashMap<Descriptor, Mutex<Peer>>,
		msg: &wire::Message<<<CMH as Deref>::Target as wire::CustomMessageReader>::CustomMessage>,
		except_node: Option<&PublicKey>, allow_large_buffer: bool,
	) {
		match msg {
			wire::Message::ChannelAnnouncement(ref msg) => {
				log_gossip!(self.logger, "Sending message to all peers except {:?} or the announced channel's counterparties: {:?}", except_node, msg);
				let encoded_msg = encode_msg!(msg);

				for (_, peer_mutex) in peers.iter() {
					let mut peer = peer_mutex.lock().unwrap();
					if !peer.handshake_complete()
						|| !peer.should_forward_channel_announcement(msg.contents.short_channel_id)
					{
						continue;
					}
					debug_assert!(peer.their_node_id.is_some());
					debug_assert!(peer.channel_encryptor.is_ready_for_encryption());
					let their_node_id = peer.their_node_id.map(|p| p.0);
					let logger = WithContext::from(&self.logger, their_node_id, None, None);
					if peer.buffer_full_drop_gossip_broadcast() && !allow_large_buffer {
						log_gossip!(
							logger,
							"Skipping broadcast message to {:?} as its outbound buffer is full",
							peer.their_node_id
						);
						continue;
					}
					if let Some((_, their_node_id)) = peer.their_node_id {
						if their_node_id == msg.contents.node_id_1
							|| their_node_id == msg.contents.node_id_2
						{
							continue;
						}
					}
					if except_node.is_some()
						&& peer.their_node_id.as_ref().map(|(pk, _)| pk) == except_node
					{
						continue;
					}
					self.enqueue_encoded_gossip_broadcast(
						&mut *peer,
						MessageBuf::from_encoded(&encoded_msg),
					);
				}
			},
			wire::Message::NodeAnnouncement(ref msg) => {
				log_gossip!(
					self.logger,
					"Sending message to all peers except {:?} or the announced node: {:?}",
					except_node,
					msg
				);
				let encoded_msg = encode_msg!(msg);

				for (_, peer_mutex) in peers.iter() {
					let mut peer = peer_mutex.lock().unwrap();
					if !peer.handshake_complete()
						|| !peer.should_forward_node_announcement(msg.contents.node_id)
					{
						continue;
					}
					debug_assert!(peer.their_node_id.is_some());
					debug_assert!(peer.channel_encryptor.is_ready_for_encryption());
					let their_node_id = peer.their_node_id.map(|p| p.0);
					let logger = WithContext::from(&self.logger, their_node_id, None, None);
					if peer.buffer_full_drop_gossip_broadcast() && !allow_large_buffer {
						log_gossip!(
							logger,
							"Skipping broadcast message to {:?} as its outbound buffer is full",
							peer.their_node_id
						);
						continue;
					}
					if let Some((_, their_node_id)) = peer.their_node_id {
						if their_node_id == msg.contents.node_id {
							continue;
						}
					}
					if except_node.is_some()
						&& peer.their_node_id.as_ref().map(|(pk, _)| pk) == except_node
					{
						continue;
					}
					self.enqueue_encoded_gossip_broadcast(
						&mut *peer,
						MessageBuf::from_encoded(&encoded_msg),
					);
				}
			},
			wire::Message::ChannelUpdate(ref msg) => {
				log_gossip!(
					self.logger,
					"Sending message to all peers except {:?}: {:?}",
					except_node,
					msg
				);
				let encoded_msg = encode_msg!(msg);

				for (_, peer_mutex) in peers.iter() {
					let mut peer = peer_mutex.lock().unwrap();
					if !peer.handshake_complete()
						|| !peer.should_forward_channel_announcement(msg.contents.short_channel_id)
					{
						continue;
					}
					debug_assert!(peer.their_node_id.is_some());
					debug_assert!(peer.channel_encryptor.is_ready_for_encryption());
					let their_node_id = peer.their_node_id.map(|p| p.0);
					let logger = WithContext::from(&self.logger, their_node_id, None, None);
					if peer.buffer_full_drop_gossip_broadcast() && !allow_large_buffer {
						log_gossip!(
							logger,
							"Skipping broadcast message to {:?} as its outbound buffer is full",
							peer.their_node_id
						);
						continue;
					}
					if except_node.is_some()
						&& peer.their_node_id.as_ref().map(|(pk, _)| pk) == except_node
					{
						continue;
					}
					self.enqueue_encoded_gossip_broadcast(
						&mut *peer,
						MessageBuf::from_encoded(&encoded_msg),
					);
				}
			},
			_ => {
				debug_assert!(false, "We shouldn't attempt to forward anything but gossip messages")
			},
		}
	}

	/// Checks for any events generated by our handlers and processes them. Includes sending most
	/// response messages as well as messages generated by calls to handler functions directly (eg
	/// functions like [`ChannelManager::process_pending_htlc_forwards`] or [`send_payment`]).
	///
	/// May call [`send_data`] on [`SocketDescriptor`]s. Thus, be very careful with reentrancy
	/// issues!
	///
	/// This should be called any time we may have messages to send. It is automatically called by
	/// [`lightning-net-tokio`] after processing incoming messages, and by
	/// [`lightning-background-processor`] when channel state has changed. Therefore, If you are not
	/// using both [`lightning-net-tokio`] and [`lightning-background-processor`], you may need to call
	/// this function manually to prevent messages from being delayed.
	///
	/// Note that if there are any other calls to this function waiting on lock(s) this may return
	/// without doing any work. All available events that need handling will be handled before the
	/// other calls return.
	///
	/// [`send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
	/// [`ChannelManager::process_pending_htlc_forwards`]: crate::ln::channelmanager::ChannelManager::process_pending_htlc_forwards
	/// [`send_data`]: SocketDescriptor::send_data
	pub fn process_events(&self) {
		if self.event_processing_state.fetch_add(1, Ordering::AcqRel) > 0 {
			// If we're not the first event processor to get here, just return early, the increment
			// we just did will be treated as "go around again" at the end.
			return;
		}

		loop {
			self.update_gossip_backlogged();
			let flush_read_disabled =
				self.gossip_processing_backlog_lifted.swap(false, Ordering::Relaxed);

			let mut peers_to_disconnect = new_hash_map();

			{
				let peers_lock = self.peers.read().unwrap();

				let peers = &*peers_lock;
				macro_rules! get_peer_for_forwarding {
					($node_id: expr) => {{
						if peers_to_disconnect.get($node_id).is_some() {
							// If we've "disconnected" this peer, do not send to it.
							None
						} else {
							let descriptor_opt =
								self.node_id_to_descriptor.lock().unwrap().get($node_id).cloned();
							match descriptor_opt {
								Some(descriptor) => match peers.get(&descriptor) {
									Some(peer_mutex) => {
										let peer_lock = peer_mutex.lock().unwrap();
										if !peer_lock.handshake_complete() {
											None
										} else {
											Some(peer_lock)
										}
									},
									None => {
										debug_assert!(false, "Inconsistent peers set state!");
										None
									},
								},
								None => None,
							}
						}
					}};
				}

				let route_handler = &self.message_handler.route_handler;
				let chan_handler = &self.message_handler.chan_handler;
				let onion_message_handler = &self.message_handler.onion_message_handler;
				let custom_message_handler = &self.message_handler.custom_message_handler;
				let send_only_message_handler = &self.message_handler.send_only_message_handler;

				// Handles a `MessageSendEvent`, using `from_chan_handler` to decide if we should
				// robustly gossip broadcast events even if a peer's message buffer is full.
				let mut handle_event = |event, from_chan_handler| {
					match event {
						MessageSendEvent::SendPeerStorage { ref node_id, ref msg } => {
							log_debug!(
								WithContext::from(&self.logger, Some(*node_id), None, None),
								"Handling SendPeerStorage event in peer_handler for {}",
								node_id,
							);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendPeerStorageRetrieval { ref node_id, ref msg } => {
							log_debug!(
								WithContext::from(&self.logger, Some(*node_id), None, None),
								"Handling SendPeerStorageRetrieval event in peer_handler for {}",
								node_id,
							);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendAcceptChannel { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.common_fields.temporary_channel_id), None), "Handling SendAcceptChannel event in peer_handler for node {} for channel {}",
									node_id,
									&msg.common_fields.temporary_channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendAcceptChannelV2 { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.common_fields.temporary_channel_id), None), "Handling SendAcceptChannelV2 event in peer_handler for node {} for channel {}",
									node_id,
									&msg.common_fields.temporary_channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendOpenChannel { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.common_fields.temporary_channel_id), None), "Handling SendOpenChannel event in peer_handler for node {} for channel {}",
									node_id,
									&msg.common_fields.temporary_channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendOpenChannelV2 { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.common_fields.temporary_channel_id), None), "Handling SendOpenChannelV2 event in peer_handler for node {} for channel {}",
									node_id,
									&msg.common_fields.temporary_channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendFundingCreated { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.temporary_channel_id), None), "Handling SendFundingCreated event in peer_handler for node {} for channel {} (which becomes {})",
									node_id,
									&msg.temporary_channel_id,
									ChannelId::v1_from_funding_txid(msg.funding_txid.as_byte_array(), msg.funding_output_index));
							// TODO: If the peer is gone we should generate a DiscardFunding event
							// indicating to the wallet that they should just throw away this funding transaction
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendFundingSigned { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendFundingSigned event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendChannelReady { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendChannelReady event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendStfu { ref node_id, ref msg } => {
							let logger = WithContext::from(
								&self.logger,
								Some(*node_id),
								Some(msg.channel_id),
								None,
							);
							log_debug!(logger, "Handling SendStfu event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendSpliceInit { ref node_id, ref msg } => {
							let logger = WithContext::from(
								&self.logger,
								Some(*node_id),
								Some(msg.channel_id),
								None,
							);
							log_debug!(logger, "Handling SendSpliceInit event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendSpliceAck { ref node_id, ref msg } => {
							let logger = WithContext::from(
								&self.logger,
								Some(*node_id),
								Some(msg.channel_id),
								None,
							);
							log_debug!(logger, "Handling SendSpliceAck event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendSpliceLocked { ref node_id, ref msg } => {
							let logger = WithContext::from(
								&self.logger,
								Some(*node_id),
								Some(msg.channel_id),
								None,
							);
							log_debug!(logger, "Handling SendSpliceLocked event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendTxAddInput { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendTxAddInput event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendTxAddOutput { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendTxAddOutput event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendTxRemoveInput { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendTxRemoveInput event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendTxRemoveOutput { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendTxRemoveOutput event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendTxComplete { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendTxComplete event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendTxSignatures { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendTxSignatures event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendTxInitRbf { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendTxInitRbf event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendTxAckRbf { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendTxAckRbf event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendTxAbort { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendTxAbort event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendAnnouncementSignatures { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendAnnouncementSignatures event in peer_handler for node {} for channel {})",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::UpdateHTLCs {
							ref node_id,
							ref channel_id,
							updates:
								msgs::CommitmentUpdate {
									ref update_add_htlcs,
									ref update_fulfill_htlcs,
									ref update_fail_htlcs,
									ref update_fail_malformed_htlcs,
									ref update_fee,
									ref commitment_signed,
								},
						} => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(*channel_id), None), "Handling UpdateHTLCs event in peer_handler for node {} with {} adds, {} fulfills, {} fails, {} commits for channel {}",
									node_id,
									update_add_htlcs.len(),
									update_fulfill_htlcs.len(),
									update_fail_htlcs.len(),
									commitment_signed.len(),
									channel_id);
							let mut peer = get_peer_for_forwarding!(node_id)?;
							for msg in update_add_htlcs {
								self.enqueue_message(&mut *peer, msg);
							}
							for msg in update_fulfill_htlcs {
								self.enqueue_message(&mut *peer, msg);
							}
							for msg in update_fail_htlcs {
								self.enqueue_message(&mut *peer, msg);
							}
							for msg in update_fail_malformed_htlcs {
								self.enqueue_message(&mut *peer, msg);
							}
							if let &Some(ref msg) = update_fee {
								self.enqueue_message(&mut *peer, msg);
							}
							if commitment_signed.len() > 1 {
								let msg = msgs::StartBatch {
									channel_id: *channel_id,
									batch_size: commitment_signed.len() as u16,
									message_type: Some(msgs::CommitmentSigned::TYPE),
								};
								self.enqueue_message(&mut *peer, &msg);
							}
							for msg in commitment_signed {
								self.enqueue_message(&mut *peer, msg);
							}
						},
						MessageSendEvent::SendRevokeAndACK { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendRevokeAndACK event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendClosingSigned { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendClosingSigned event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendClosingComplete { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendClosingComplete event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendClosingSig { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendClosingSig event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendShutdown { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling Shutdown event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendChannelReestablish { ref node_id, ref msg } => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), Some(msg.channel_id), None), "Handling SendChannelReestablish event in peer_handler for node {} for channel {}",
									node_id,
									&msg.channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendChannelAnnouncement {
							ref node_id,
							ref msg,
							ref update_msg,
						} => {
							log_debug!(WithContext::from(&self.logger, Some(*node_id), None, None), "Handling SendChannelAnnouncement event in peer_handler for node {} for short channel id {}",
									node_id,
									msg.contents.short_channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
							self.enqueue_message(
								&mut *get_peer_for_forwarding!(node_id)?,
								update_msg,
							);
						},
						MessageSendEvent::BroadcastChannelAnnouncement { msg, update_msg } => {
							log_debug!(self.logger, "Handling BroadcastChannelAnnouncement event in peer_handler for short channel id {}", msg.contents.short_channel_id);
							match route_handler.handle_channel_announcement(None, &msg) {
								Ok(_)
								| Err(LightningError {
									action: msgs::ErrorAction::IgnoreDuplicateGossip,
									..
								}) => {
									let forward = wire::Message::ChannelAnnouncement(msg);
									self.forward_broadcast_msg(
										peers,
										&forward,
										None,
										from_chan_handler,
									);
								},
								_ => {},
							}
							if let Some(msg) = update_msg {
								match route_handler.handle_channel_update(None, &msg) {
									Ok(_)
									| Err(LightningError {
										action: msgs::ErrorAction::IgnoreDuplicateGossip,
										..
									}) => {
										let forward = wire::Message::ChannelUpdate(msg);
										self.forward_broadcast_msg(
											peers,
											&forward,
											None,
											from_chan_handler,
										);
									},
									_ => {},
								}
							}
						},
						MessageSendEvent::BroadcastChannelUpdate { msg } => {
							log_debug!(self.logger, "Handling BroadcastChannelUpdate event in peer_handler for contents {:?}", msg.contents);
							match route_handler.handle_channel_update(None, &msg) {
								Ok(_)
								| Err(LightningError {
									action: msgs::ErrorAction::IgnoreDuplicateGossip,
									..
								}) => {
									let forward = wire::Message::ChannelUpdate(msg);
									self.forward_broadcast_msg(
										peers,
										&forward,
										None,
										from_chan_handler,
									);
								},
								_ => {},
							}
						},
						MessageSendEvent::BroadcastNodeAnnouncement { msg } => {
							log_debug!(self.logger, "Handling BroadcastNodeAnnouncement event in peer_handler for node {}", msg.contents.node_id);
							match route_handler.handle_node_announcement(None, &msg) {
								Ok(_)
								| Err(LightningError {
									action: msgs::ErrorAction::IgnoreDuplicateGossip,
									..
								}) => {
									let forward = wire::Message::NodeAnnouncement(msg);
									self.forward_broadcast_msg(
										peers,
										&forward,
										None,
										from_chan_handler,
									);
								},
								_ => {},
							}
						},
						MessageSendEvent::SendChannelUpdate { ref node_id, ref msg } => {
							log_trace!(WithContext::from(&self.logger, Some(*node_id), None, None), "Handling SendChannelUpdate event in peer_handler for node {} for channel {}",
									node_id, msg.contents.short_channel_id);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::HandleError { node_id, action } => {
							let logger = WithContext::from(&self.logger, Some(node_id), None, None);
							match action {
								msgs::ErrorAction::DisconnectPeer { msg } => {
									if let Some(msg) = msg.as_ref() {
										log_trace!(logger, "Handling DisconnectPeer HandleError event in peer_handler for node {} with message {}",
											node_id, msg.data);
									} else {
										log_trace!(logger, "Handling DisconnectPeer HandleError event in peer_handler for node {}",
											node_id);
									}
									// We do not have the peers write lock, so we just store that we're
									// about to disconnect the peer and do it after we finish
									// processing most messages.
									let msg = msg.map(|msg| {
										wire::Message::<<<CMH as Deref>::Target as wire::CustomMessageReader>::CustomMessage>::Error(msg)
									});
									peers_to_disconnect.insert(node_id, msg);
								},
								msgs::ErrorAction::DisconnectPeerWithWarning { msg } => {
									log_trace!(logger, "Handling DisconnectPeer HandleError event in peer_handler for node {} with message {}",
										node_id, msg.data);
									// We do not have the peers write lock, so we just store that we're
									// about to disconnect the peer and do it after we finish
									// processing most messages.
									peers_to_disconnect
										.insert(node_id, Some(wire::Message::Warning(msg)));
								},
								msgs::ErrorAction::IgnoreAndLog(level) => {
									log_given_level!(
										logger,
										level,
										"Received a HandleError event to be ignored for node {}",
										node_id,
									);
								},
								msgs::ErrorAction::IgnoreDuplicateGossip => {},
								msgs::ErrorAction::IgnoreError => {
									log_debug!(
										logger,
										"Received a HandleError event to be ignored for node {}",
										node_id,
									);
								},
								msgs::ErrorAction::SendErrorMessage { ref msg } => {
									log_trace!(logger, "Handling SendErrorMessage HandleError event in peer_handler for node {} with message {}",
											node_id,
											msg.data);
									self.enqueue_message(
										&mut *get_peer_for_forwarding!(&node_id)?,
										msg,
									);
								},
								msgs::ErrorAction::SendWarningMessage {
									ref msg,
									ref log_level,
								} => {
									log_given_level!(logger, *log_level, "Handling SendWarningMessage HandleError event in peer_handler for node {} with message {}",
											node_id,
											msg.data);
									self.enqueue_message(
										&mut *get_peer_for_forwarding!(&node_id)?,
										msg,
									);
								},
							}
						},
						MessageSendEvent::SendChannelRangeQuery { ref node_id, ref msg } => {
							log_gossip!(WithContext::from(&self.logger, Some(*node_id), None, None), "Handling SendChannelRangeQuery event in peer_handler for node {} with first_blocknum={}, number_of_blocks={}",
								node_id,
								msg.first_blocknum,
								msg.number_of_blocks);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendShortIdsQuery { ref node_id, ref msg } => {
							log_gossip!(WithContext::from(&self.logger, Some(*node_id), None, None), "Handling SendShortIdsQuery event in peer_handler for node {} with num_scids={}",
								node_id,
								msg.short_channel_ids.len());
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendReplyChannelRange { ref node_id, ref msg } => {
							log_gossip!(WithContext::from(&self.logger, Some(*node_id), None, None), "Handling SendReplyChannelRange event in peer_handler for node {} with num_scids={} first_blocknum={} number_of_blocks={}, sync_complete={}",
								node_id,
								msg.short_channel_ids.len(),
								msg.first_blocknum,
								msg.number_of_blocks,
								msg.sync_complete);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
						MessageSendEvent::SendGossipTimestampFilter { ref node_id, ref msg } => {
							log_gossip!(WithContext::from(&self.logger, Some(*node_id), None, None), "Handling SendGossipTimestampFilter event in peer_handler for node {} with first_timestamp={}, timestamp_range={}",
								node_id,
								msg.first_timestamp,
								msg.timestamp_range);
							self.enqueue_message(&mut *get_peer_for_forwarding!(node_id)?, msg);
						},
					}
					Some(())
				};

				let chan_events = chan_handler.get_and_clear_pending_msg_events();
				for event in chan_events {
					handle_event(event, true);
				}

				let route_events = route_handler.get_and_clear_pending_msg_events();
				for event in route_events {
					handle_event(event, false);
				}

				let send_only_events = send_only_message_handler.get_and_clear_pending_msg_events();
				for event in send_only_events {
					handle_event(event, false);
				}

				let onion_msg_events = onion_message_handler.get_and_clear_pending_msg_events();
				for event in onion_msg_events {
					handle_event(event, false);
				}

				for (node_id, msg) in custom_message_handler.get_and_clear_pending_msg() {
					if peers_to_disconnect.get(&node_id).is_some() {
						continue;
					}
					let mut peer = if let Some(peer) = get_peer_for_forwarding!(&node_id) {
						peer
					} else {
						continue;
					};
					self.enqueue_message(&mut peer, &msg);
				}

				for (descriptor, peer_mutex) in peers.iter() {
					let mut peer = peer_mutex.lock().unwrap();
					if flush_read_disabled {
						peer.received_channel_announce_since_backlogged = false;
					}
					self.do_attempt_write_data(
						&mut (*descriptor).clone(),
						&mut *peer,
						flush_read_disabled,
					);
				}
			}
			if !peers_to_disconnect.is_empty() {
				let mut peers_lock = self.peers.write().unwrap();
				let peers = &mut *peers_lock;
				for (node_id, msg) in peers_to_disconnect.drain() {
					// Note that since we are holding the peers *write* lock we can
					// remove from node_id_to_descriptor immediately (as no other
					// thread can be holding the peer lock if we have the global write
					// lock).

					let descriptor_opt =
						self.node_id_to_descriptor.lock().unwrap().remove(&node_id);
					if let Some(mut descriptor) = descriptor_opt {
						if let Some(peer_mutex) = peers.remove(&descriptor) {
							let mut peer = peer_mutex.lock().unwrap();
							if let Some(msg) = msg {
								self.enqueue_message(&mut *peer, &msg);
								// This isn't guaranteed to work, but if there is enough free
								// room in the send buffer, put the error message there...
								self.do_attempt_write_data(&mut descriptor, &mut *peer, false);
							}
							self.do_disconnect(descriptor, &*peer, "DisconnectPeer HandleError");
						} else {
							debug_assert!(false, "Missing connection for peer");
						}
					}
				}
			}

			if self.event_processing_state.fetch_sub(1, Ordering::AcqRel) != 1 {
				// If another thread incremented the state while we were running we should go
				// around again, but only once.
				self.event_processing_state.store(1, Ordering::Release);
				continue;
			}
			break;
		}
	}

	/// Indicates that the given socket descriptor's connection is now closed.
	pub fn socket_disconnected(&self, descriptor: &Descriptor) {
		self.disconnect_event_internal(descriptor, "the socket was disconnected");
	}

	fn do_disconnect(&self, mut descriptor: Descriptor, peer: &Peer, reason: &'static str) {
		if !peer.handshake_complete() {
			log_trace!(
				self.logger,
				"Disconnecting peer which hasn't completed handshake due to {}",
				reason
			);
			descriptor.disconnect_socket();
			return;
		}

		debug_assert!(peer.their_node_id.is_some());
		if let Some((node_id, _)) = peer.their_node_id {
			log_trace!(
				WithContext::from(&self.logger, Some(node_id), None, None),
				"Disconnecting peer with id {} due to {}",
				node_id,
				reason
			);
			self.message_handler.route_handler.peer_disconnected(node_id);
			self.message_handler.chan_handler.peer_disconnected(node_id);
			self.message_handler.onion_message_handler.peer_disconnected(node_id);
			self.message_handler.custom_message_handler.peer_disconnected(node_id);
			self.message_handler.send_only_message_handler.peer_disconnected(node_id);
		}
		descriptor.disconnect_socket();
	}

	fn disconnect_event_internal(&self, descriptor: &Descriptor, reason: &'static str) {
		let mut peers = self.peers.write().unwrap();
		let peer_option = peers.remove(descriptor);
		match peer_option {
			None => {
				// This is most likely a simple race condition where the user found that the socket
				// was disconnected, then we told the user to `disconnect_socket()`, then they
				// called this method. Either way we're disconnected, return.
			},
			Some(peer_lock) => {
				let peer = peer_lock.lock().unwrap();
				if let Some((node_id, _)) = peer.their_node_id {
					let logger = WithContext::from(&self.logger, Some(node_id), None, None);
					log_trace!(
						logger,
						"Handling disconnection of peer {} because {}",
						node_id,
						reason
					);
					let removed = self.node_id_to_descriptor.lock().unwrap().remove(&node_id);
					debug_assert!(removed.is_some(), "descriptor maps should be consistent");
					if !peer.handshake_complete() {
						return;
					}
					self.message_handler.route_handler.peer_disconnected(node_id);
					self.message_handler.chan_handler.peer_disconnected(node_id);
					self.message_handler.onion_message_handler.peer_disconnected(node_id);
					self.message_handler.custom_message_handler.peer_disconnected(node_id);
					self.message_handler.send_only_message_handler.peer_disconnected(node_id);
				}
			},
		};
	}

	/// Disconnect a peer given its node id.
	///
	/// If a peer is connected, this will call [`disconnect_socket`] on the descriptor for the
	/// peer. Thus, be very careful about reentrancy issues.
	///
	/// [`disconnect_socket`]: SocketDescriptor::disconnect_socket
	pub fn disconnect_by_node_id(&self, node_id: PublicKey) {
		let mut peers_lock = self.peers.write().unwrap();
		if let Some(descriptor) = self.node_id_to_descriptor.lock().unwrap().remove(&node_id) {
			let peer_opt = peers_lock.remove(&descriptor);
			if let Some(peer_mutex) = peer_opt {
				self.do_disconnect(descriptor, &*peer_mutex.lock().unwrap(), "client request");
			} else {
				debug_assert!(false, "node_id_to_descriptor thought we had a peer");
			}
		}
	}

	/// Disconnects all currently-connected peers. This is useful on platforms where there may be
	/// an indication that TCP sockets have stalled even if we weren't around to time them out
	/// using regular ping/pongs.
	pub fn disconnect_all_peers(&self) {
		let mut peers_lock = self.peers.write().unwrap();
		self.node_id_to_descriptor.lock().unwrap().clear();
		let peers = &mut *peers_lock;
		for (descriptor, peer_mutex) in peers.drain() {
			self.do_disconnect(
				descriptor,
				&*peer_mutex.lock().unwrap(),
				"client request to disconnect all peers",
			);
		}
	}

	/// This is called when we're blocked on sending additional gossip messages until we receive a
	/// pong. If we aren't waiting on a pong, we take this opportunity to send a ping (setting
	/// `awaiting_pong_timer_tick_intervals` to a special flag value to indicate this).
	fn maybe_send_extra_ping(&self, peer: &mut Peer) {
		if peer.awaiting_pong_timer_tick_intervals == 0 {
			peer.awaiting_pong_timer_tick_intervals = -1;
			let ping = msgs::Ping { ponglen: 0, byteslen: 64 };
			let ping_pong_span =
				self.logger.start(Span::PingPong { node_id: peer.their_node_id.unwrap().0 }, None);
			peer.ping_pong_span = Some(BoxedSpan::new(ping_pong_span));
			self.enqueue_message(peer, &ping);
		}
	}

	/// Send pings to each peer and disconnect those which did not respond to the last round of
	/// pings.
	///
	/// This may be called on any timescale you want, however, roughly once every ten seconds is
	/// preferred. The call rate determines both how often we send a ping to our peers and how much
	/// time they have to respond before we disconnect them.
	///
	/// May call [`send_data`] on all [`SocketDescriptor`]s. Thus, be very careful with reentrancy
	/// issues!
	///
	/// [`send_data`]: SocketDescriptor::send_data
	pub fn timer_tick_occurred(&self) {
		let mut descriptors_needing_disconnect = Vec::new();
		{
			let peers_lock = self.peers.read().unwrap();

			self.update_gossip_backlogged();
			let flush_read_disabled =
				self.gossip_processing_backlog_lifted.swap(false, Ordering::Relaxed);

			for (descriptor, peer_mutex) in peers_lock.iter() {
				let mut peer = peer_mutex.lock().unwrap();
				if flush_read_disabled {
					peer.received_channel_announce_since_backlogged = false;
				}

				if !peer.handshake_complete() {
					// The peer needs to complete its handshake before we can exchange messages. We
					// give peers one timer tick to complete handshake, reusing
					// `awaiting_pong_timer_tick_intervals` to track number of timer ticks taken
					// for handshake completion.
					if peer.awaiting_pong_timer_tick_intervals != 0 {
						descriptors_needing_disconnect.push(descriptor.clone());
					} else {
						peer.awaiting_pong_timer_tick_intervals = 1;
					}
					continue;
				}
				debug_assert!(peer.channel_encryptor.is_ready_for_encryption());
				debug_assert!(peer.their_node_id.is_some());

				// We use a loop as a `goto` to skip writing the Ping message:
				loop {
					if peer.awaiting_pong_timer_tick_intervals == -1 {
						// Magic value set in `maybe_send_extra_ping`.
						peer.awaiting_pong_timer_tick_intervals = 1;
						peer.received_message_since_timer_tick = false;
						break;
					}
					let not_recently_active = peer.awaiting_pong_timer_tick_intervals > 0
						&& !peer.received_message_since_timer_tick;
					let reached_threshold_intervals = peer.awaiting_pong_timer_tick_intervals
						as u64
						> MAX_BUFFER_DRAIN_TICK_INTERVALS_PER_PEER as u64 * peers_lock.len() as u64;
					if not_recently_active || reached_threshold_intervals {
						descriptors_needing_disconnect.push(descriptor.clone());
						break;
					}
					peer.received_message_since_timer_tick = false;

					if peer.awaiting_pong_timer_tick_intervals > 0 {
						peer.awaiting_pong_timer_tick_intervals += 1;
						break;
					}

					peer.awaiting_pong_timer_tick_intervals = 1;
					let ping = msgs::Ping { ponglen: 0, byteslen: 64 };
					let ping_pong_span = self
						.logger
						.start(Span::PingPong { node_id: peer.their_node_id.unwrap().0 }, None);
					peer.ping_pong_span = Some(BoxedSpan::new(ping_pong_span));
					self.enqueue_message(&mut *peer, &ping);
					break;
				}
				self.do_attempt_write_data(
					&mut (descriptor.clone()),
					&mut *peer,
					flush_read_disabled,
				);
			}
		}

		if !descriptors_needing_disconnect.is_empty() {
			{
				let mut peers_lock = self.peers.write().unwrap();
				for descriptor in descriptors_needing_disconnect {
					if let Some(peer_mutex) = peers_lock.remove(&descriptor) {
						let peer = peer_mutex.lock().unwrap();
						if let Some((node_id, _)) = peer.their_node_id {
							self.node_id_to_descriptor.lock().unwrap().remove(&node_id);
						}
						self.do_disconnect(descriptor, &*peer, "ping/handshake timeout");
					}
				}
			}
		}
	}

	#[allow(dead_code)]
	// Messages of up to 64KB should never end up more than half full with addresses, as that would
	// be absurd. We ensure this by checking that at least 100 (our stated public contract on when
	// broadcast_node_announcement panics) of the maximum-length addresses would fit in a 64KB
	// message...
	const HALF_MESSAGE_IS_ADDRS: u32 =
		::core::u16::MAX as u32 / (SocketAddress::MAX_LEN as u32 + 1) / 2;
	#[allow(dead_code)]
	// ...by failing to compile if the number of addresses that would be half of a message is
	// smaller than 100:
	const STATIC_ASSERT: u32 = Self::HALF_MESSAGE_IS_ADDRS - 100;

	/// Generates a signed node_announcement from the given arguments, sending it to all connected
	/// peers. Note that peers will likely ignore this message unless we have at least one public
	/// channel which has at least six confirmations on-chain.
	///
	/// `rgb` is a node "color" and `alias` is a printable human-readable string to describe this
	/// node to humans. They carry no in-protocol meaning.
	///
	/// `addresses` represent the set (possibly empty) of socket addresses on which this node
	/// accepts incoming connections. These will be included in the node_announcement, publicly
	/// tying these addresses together and to this node. If you wish to preserve user privacy,
	/// addresses should likely contain only Tor Onion addresses.
	///
	/// Panics if `addresses` is absurdly large (more than 100).
	///
	/// [`get_and_clear_pending_msg_events`]: BaseMessageHandler::get_and_clear_pending_msg_events
	pub fn broadcast_node_announcement(
		&self, rgb: [u8; 3], alias: [u8; 32], mut addresses: Vec<SocketAddress>,
	) {
		if addresses.len() > 100 {
			panic!("More than half the message size was taken up by public addresses!");
		}

		// While all existing nodes handle unsorted addresses just fine, the spec requires that
		// addresses be sorted for future compatibility.
		addresses.sort_by_key(|addr| addr.get_id());

		let features = self.message_handler.chan_handler.provided_node_features()
			| self.message_handler.route_handler.provided_node_features()
			| self.message_handler.onion_message_handler.provided_node_features()
			| self.message_handler.custom_message_handler.provided_node_features()
			| self.message_handler.send_only_message_handler.provided_node_features();
		let announcement = msgs::UnsignedNodeAnnouncement {
			features,
			timestamp: self.last_node_announcement_serial.fetch_add(1, Ordering::AcqRel),
			node_id: NodeId::from_pubkey(&self.node_signer.get_node_id(Recipient::Node).unwrap()),
			rgb,
			alias: NodeAlias(alias),
			addresses,
			excess_address_data: Vec::new(),
			excess_data: Vec::new(),
		};
		let node_announce_sig = match self
			.node_signer
			.sign_gossip_message(msgs::UnsignedGossipMessage::NodeAnnouncement(&announcement))
		{
			Ok(sig) => sig,
			Err(_) => {
				log_error!(self.logger, "Failed to generate signature for node_announcement");
				return;
			},
		};

		let msg = msgs::NodeAnnouncement { signature: node_announce_sig, contents: announcement };

		log_debug!(
			self.logger,
			"Broadcasting NodeAnnouncement after passing it to our own RoutingMessageHandler."
		);
		let _ = self.message_handler.route_handler.handle_node_announcement(None, &msg);
		self.forward_broadcast_msg(
			&*self.peers.read().unwrap(),
			&wire::Message::NodeAnnouncement(msg),
			None,
			true,
		);
	}
}

fn is_gossip_msg(type_id: u16) -> bool {
	match type_id {
		msgs::ChannelAnnouncement::TYPE
		| msgs::ChannelUpdate::TYPE
		| msgs::NodeAnnouncement::TYPE
		| msgs::QueryChannelRange::TYPE
		| msgs::ReplyChannelRange::TYPE
		| msgs::QueryShortChannelIds::TYPE
		| msgs::ReplyShortChannelIdsEnd::TYPE => true,
		_ => false,
	}
}

#[cfg(test)]
mod tests {
	use super::*;

	use crate::io;
	use crate::ln::msgs::{Init, LightningError, SocketAddress};
	use crate::ln::peer_channel_encryptor::PeerChannelEncryptor;
	use crate::ln::types::ChannelId;
	use crate::ln::{msgs, wire};
	use crate::sign::{NodeSigner, Recipient};
	use crate::types::features::{InitFeatures, NodeFeatures};
	use crate::util::test_utils;

	use bitcoin::constants::ChainHash;
	use bitcoin::secp256k1::{PublicKey, Secp256k1, SecretKey};
	use bitcoin::Network;

	use crate::sync::{Arc, Mutex};
	use core::convert::Infallible;
	use core::sync::atomic::{AtomicBool, AtomicUsize, Ordering};

	#[allow(unused_imports)]
	use crate::prelude::*;

	#[derive(Clone)]
	struct FileDescriptor {
		fd: u16,
		hang_writes: Arc<AtomicBool>,
		outbound_data: Arc<Mutex<Vec<u8>>>,
		disconnect: Arc<AtomicBool>,
	}
	impl PartialEq for FileDescriptor {
		fn eq(&self, other: &Self) -> bool {
			self.fd == other.fd
		}
	}
	impl Eq for FileDescriptor {}
	impl core::hash::Hash for FileDescriptor {
		fn hash<H: core::hash::Hasher>(&self, hasher: &mut H) {
			self.fd.hash(hasher)
		}
	}

	impl SocketDescriptor for FileDescriptor {
		fn send_data(&mut self, data: &[u8], _resume_read: bool) -> usize {
			if self.hang_writes.load(Ordering::Acquire) {
				0
			} else {
				self.outbound_data.lock().unwrap().extend_from_slice(data);
				data.len()
			}
		}

		fn disconnect_socket(&mut self) {
			self.disconnect.store(true, Ordering::Release);
		}
	}

	impl FileDescriptor {
		fn new(fd: u16) -> Self {
			Self {
				fd,
				hang_writes: Arc::new(AtomicBool::new(false)),
				outbound_data: Arc::new(Mutex::new(Vec::new())),
				disconnect: Arc::new(AtomicBool::new(false)),
			}
		}
	}

	struct PeerManagerCfg {
		chan_handler: test_utils::TestChannelMessageHandler,
		routing_handler: test_utils::TestRoutingMessageHandler,
		custom_handler: TestCustomMessageHandler,
		send_only_handler: TestBaseMsgHandler,
		logger: test_utils::TestLogger,
		node_signer: test_utils::TestNodeSigner,
	}

	struct TestCustomMessageHandler {
		features: InitFeatures,
		conn_tracker: test_utils::ConnectionTracker,
	}

	impl TestCustomMessageHandler {
		fn new(features: InitFeatures) -> Self {
			Self { features, conn_tracker: test_utils::ConnectionTracker::new() }
		}
	}

	impl wire::CustomMessageReader for TestCustomMessageHandler {
		type CustomMessage = Infallible;
		fn read<R: io::Read>(
			&self, _: u16, _: &mut R,
		) -> Result<Option<Self::CustomMessage>, msgs::DecodeError> {
			Ok(None)
		}
	}

	impl CustomMessageHandler for TestCustomMessageHandler {
		fn handle_custom_message(&self, _: Infallible, _: PublicKey) -> Result<(), LightningError> {
			unreachable!();
		}

		fn get_and_clear_pending_msg(&self) -> Vec<(PublicKey, Self::CustomMessage)> {
			Vec::new()
		}

		fn peer_disconnected(&self, their_node_id: PublicKey) {
			self.conn_tracker.peer_disconnected(their_node_id);
		}

		fn peer_connected(
			&self, their_node_id: PublicKey, _msg: &Init, _inbound: bool,
		) -> Result<(), ()> {
			self.conn_tracker.peer_connected(their_node_id)
		}

		fn provided_node_features(&self) -> NodeFeatures {
			NodeFeatures::empty()
		}

		fn provided_init_features(&self, _: PublicKey) -> InitFeatures {
			self.features.clone()
		}
	}

	struct TestBaseMsgHandler(test_utils::ConnectionTracker);

	impl BaseMessageHandler for TestBaseMsgHandler {
		fn get_and_clear_pending_msg_events(&self) -> Vec<MessageSendEvent> {
			Vec::new()
		}

		fn peer_disconnected(&self, their_node_id: PublicKey) {
			self.0.peer_disconnected(their_node_id);
		}

		fn peer_connected(
			&self, their_node_id: PublicKey, _msg: &Init, _inbound: bool,
		) -> Result<(), ()> {
			self.0.peer_connected(their_node_id)
		}

		fn provided_node_features(&self) -> NodeFeatures {
			NodeFeatures::empty()
		}

		fn provided_init_features(&self, _: PublicKey) -> InitFeatures {
			InitFeatures::empty()
		}
	}

	impl SendOnlyMessageHandler for TestBaseMsgHandler {}

	fn create_peermgr_cfgs(peer_count: usize) -> Vec<PeerManagerCfg> {
		let mut cfgs = Vec::new();
		for i in 0..peer_count {
			let node_secret = SecretKey::from_slice(&[42 + i as u8; 32]).unwrap();
			let features = {
				let mut feature_bits = vec![0u8; 33];
				feature_bits[32] = 0b00000001;
				InitFeatures::from_le_bytes(feature_bits)
			};
			cfgs.push(PeerManagerCfg {
				chan_handler: test_utils::TestChannelMessageHandler::new(
					ChainHash::using_genesis_block(Network::Testnet),
				),
				logger: test_utils::TestLogger::with_id(i.to_string()),
				routing_handler: test_utils::TestRoutingMessageHandler::new(),
				custom_handler: TestCustomMessageHandler::new(features),
				send_only_handler: TestBaseMsgHandler(test_utils::ConnectionTracker::new()),
				node_signer: test_utils::TestNodeSigner::new(node_secret),
			});
		}

		cfgs
	}

	fn create_feature_incompatible_peermgr_cfgs(peer_count: usize) -> Vec<PeerManagerCfg> {
		let mut cfgs = Vec::new();
		for i in 0..peer_count {
			let node_secret = SecretKey::from_slice(&[42 + i as u8; 32]).unwrap();
			let features = {
				let mut feature_bits = vec![0u8; 33 + i + 1];
				feature_bits[33 + i] = 0b00000001;
				InitFeatures::from_le_bytes(feature_bits)
			};
			cfgs.push(PeerManagerCfg {
				chan_handler: test_utils::TestChannelMessageHandler::new(
					ChainHash::using_genesis_block(Network::Testnet),
				),
				logger: test_utils::TestLogger::new(),
				routing_handler: test_utils::TestRoutingMessageHandler::new(),
				custom_handler: TestCustomMessageHandler::new(features),
				send_only_handler: TestBaseMsgHandler(test_utils::ConnectionTracker::new()),
				node_signer: test_utils::TestNodeSigner::new(node_secret),
			});
		}

		cfgs
	}

	fn create_chain_incompatible_peermgr_cfgs(peer_count: usize) -> Vec<PeerManagerCfg> {
		let mut cfgs = Vec::new();
		for i in 0..peer_count {
			let node_secret = SecretKey::from_slice(&[42 + i as u8; 32]).unwrap();
			let features = InitFeatures::from_le_bytes(vec![0u8; 33]);
			let network = ChainHash::from(&[i as u8; 32]);
			cfgs.push(PeerManagerCfg {
				chan_handler: test_utils::TestChannelMessageHandler::new(network),
				logger: test_utils::TestLogger::new(),
				routing_handler: test_utils::TestRoutingMessageHandler::new(),
				custom_handler: TestCustomMessageHandler::new(features),
				send_only_handler: TestBaseMsgHandler(test_utils::ConnectionTracker::new()),
				node_signer: test_utils::TestNodeSigner::new(node_secret),
			});
		}

		cfgs
	}

	fn create_network<'a>(peer_count: usize, cfgs: &'a Vec<PeerManagerCfg>) -> Vec<TestPeer<'a>> {
		let mut peers = Vec::new();
		for i in 0..peer_count {
			let ephemeral_bytes = [i as u8; 32];
			let msg_handler = MessageHandler {
				chan_handler: &cfgs[i].chan_handler,
				route_handler: &cfgs[i].routing_handler,
				onion_message_handler: IgnoringMessageHandler {},
				custom_message_handler: &cfgs[i].custom_handler,
				send_only_message_handler: &cfgs[i].send_only_handler,
			};
			let peer = PeerManager::new(
				msg_handler,
				0,
				&ephemeral_bytes,
				&cfgs[i].logger,
				&cfgs[i].node_signer,
			);
			peers.push(peer);
		}

		peers
	}

	type TestPeer<'a> = PeerManager<
		FileDescriptor,
		&'a test_utils::TestChannelMessageHandler,
		&'a test_utils::TestRoutingMessageHandler,
		IgnoringMessageHandler,
		&'a test_utils::TestLogger,
		&'a TestCustomMessageHandler,
		&'a test_utils::TestNodeSigner,
		&'a TestBaseMsgHandler,
	>;

	fn try_establish_connection<'a>(
		peer_a: &TestPeer<'a>, peer_b: &TestPeer<'a>,
	) -> (
		FileDescriptor,
		FileDescriptor,
		Result<bool, PeerHandleError>,
		Result<bool, PeerHandleError>,
	) {
		let addr_a = SocketAddress::TcpIpV4 { addr: [127, 0, 0, 1], port: 1000 };
		let addr_b = SocketAddress::TcpIpV4 { addr: [127, 0, 0, 1], port: 1001 };

		static FD_COUNTER: AtomicUsize = AtomicUsize::new(0);
		let fd = FD_COUNTER.fetch_add(1, Ordering::Relaxed) as u16;

		let id_a = peer_a.node_signer.get_node_id(Recipient::Node).unwrap();
		let mut fd_a = FileDescriptor::new(fd);
		let mut fd_b = FileDescriptor::new(fd);

		let initial_data =
			peer_b.new_outbound_connection(id_a, fd_b.clone(), Some(addr_a.clone())).unwrap();
		peer_a.new_inbound_connection(fd_a.clone(), Some(addr_b.clone())).unwrap();
		assert_eq!(peer_a.read_event(&mut fd_a, &initial_data).unwrap(), false);
		peer_a.process_events();

		let a_data = fd_a.outbound_data.lock().unwrap().split_off(0);
		assert_eq!(peer_b.read_event(&mut fd_b, &a_data).unwrap(), false);

		peer_b.process_events();
		let b_data = fd_b.outbound_data.lock().unwrap().split_off(0);
		let a_refused = peer_a.read_event(&mut fd_a, &b_data);

		peer_a.process_events();
		let a_data = fd_a.outbound_data.lock().unwrap().split_off(0);
		let b_refused = peer_b.read_event(&mut fd_b, &a_data);

		(fd_a, fd_b, a_refused, b_refused)
	}

	fn establish_connection<'a>(
		peer_a: &TestPeer<'a>, peer_b: &TestPeer<'a>,
	) -> (FileDescriptor, FileDescriptor) {
		let addr_a = SocketAddress::TcpIpV4 { addr: [127, 0, 0, 1], port: 1000 };
		let addr_b = SocketAddress::TcpIpV4 { addr: [127, 0, 0, 1], port: 1001 };

		let id_a = peer_a.node_signer.get_node_id(Recipient::Node).unwrap();
		let id_b = peer_b.node_signer.get_node_id(Recipient::Node).unwrap();

		let features_a = peer_a.init_features(id_b);
		let features_b = peer_b.init_features(id_a);

		let (fd_a, fd_b, a_refused, b_refused) = try_establish_connection(peer_a, peer_b);

		assert_eq!(a_refused.unwrap(), false);
		assert_eq!(b_refused.unwrap(), false);

		assert_eq!(peer_a.peer_by_node_id(&id_b).unwrap().counterparty_node_id, id_b);
		assert_eq!(peer_a.peer_by_node_id(&id_b).unwrap().socket_address, Some(addr_b));
		assert_eq!(peer_a.peer_by_node_id(&id_b).unwrap().init_features, features_b);
		assert_eq!(peer_b.peer_by_node_id(&id_a).unwrap().counterparty_node_id, id_a);
		assert_eq!(peer_b.peer_by_node_id(&id_a).unwrap().socket_address, Some(addr_a));
		assert_eq!(peer_b.peer_by_node_id(&id_a).unwrap().init_features, features_a);
		(fd_a.clone(), fd_b.clone())
	}

	#[test]
	#[cfg(feature = "std")]
	fn fuzz_threaded_connections() {
		// Spawn two threads which repeatedly connect two peers together, leading to "got second
		// connection with peer" disconnections and rapid reconnect. This previously found an issue
		// with our internal map consistency, and is a generally good smoke test of disconnection.
		let cfgs = Arc::new(create_peermgr_cfgs(2));
		// Until we have std::thread::scoped we have to unsafe { turn off the borrow checker }.
		let peers = Arc::new(create_network(2, unsafe { &*(&*cfgs as *const _) as &'static _ }));

		let start_time = std::time::Instant::now();
		macro_rules! spawn_thread {
			($id: expr) => {{
				let peers = Arc::clone(&peers);
				let cfgs = Arc::clone(&cfgs);
				std::thread::spawn(move || {
					let mut ctr = 0;
					while start_time.elapsed() < std::time::Duration::from_secs(1) {
						let id_a = peers[0].node_signer.get_node_id(Recipient::Node).unwrap();
						let mut fd_a = FileDescriptor::new($id + ctr * 3);
						let addr_a = SocketAddress::TcpIpV4 { addr: [127, 0, 0, 1], port: 1000 };
						let mut fd_b = FileDescriptor::new($id + ctr * 3);
						let addr_b = SocketAddress::TcpIpV4 { addr: [127, 0, 0, 1], port: 1001 };
						let initial_data = peers[1]
							.new_outbound_connection(id_a, fd_b.clone(), Some(addr_a.clone()))
							.unwrap();
						peers[0]
							.new_inbound_connection(fd_a.clone(), Some(addr_b.clone()))
							.unwrap();
						if peers[0].read_event(&mut fd_a, &initial_data).is_err() {
							break;
						}

						while start_time.elapsed() < std::time::Duration::from_secs(1) {
							peers[0].process_events();
							if fd_a.disconnect.load(Ordering::Acquire) {
								break;
							}
							let a_data = fd_a.outbound_data.lock().unwrap().split_off(0);
							if peers[1].read_event(&mut fd_b, &a_data).is_err() {
								break;
							}

							peers[1].process_events();
							if fd_b.disconnect.load(Ordering::Acquire) {
								break;
							}
							let b_data = fd_b.outbound_data.lock().unwrap().split_off(0);
							if peers[0].read_event(&mut fd_a, &b_data).is_err() {
								break;
							}

							let node_id_1 =
								peers[1].node_signer.get_node_id(Recipient::Node).unwrap();
							let msg_event_1 = MessageSendEvent::SendShutdown {
								node_id: node_id_1,
								msg: msgs::Shutdown {
									channel_id: ChannelId::new_zero(),
									scriptpubkey: bitcoin::ScriptBuf::new(),
								},
							};
							cfgs[0].chan_handler.pending_events.lock().unwrap().push(msg_event_1);

							let node_id_0 =
								peers[0].node_signer.get_node_id(Recipient::Node).unwrap();
							let msg_event_0 = MessageSendEvent::SendShutdown {
								node_id: node_id_0,
								msg: msgs::Shutdown {
									channel_id: ChannelId::new_zero(),
									scriptpubkey: bitcoin::ScriptBuf::new(),
								},
							};
							cfgs[1].chan_handler.pending_events.lock().unwrap().push(msg_event_0);

							if ctr % 2 == 0 {
								peers[0].timer_tick_occurred();
								peers[1].timer_tick_occurred();
							}
						}

						peers[0].socket_disconnected(&fd_a);
						peers[1].socket_disconnected(&fd_b);
						ctr += 1;
						std::thread::sleep(std::time::Duration::from_micros(1));
					}
				})
			}};
		}
		let thrd_a = spawn_thread!(1);
		let thrd_b = spawn_thread!(2);

		thrd_a.join().unwrap();
		thrd_b.join().unwrap();
	}

	#[test]
	fn test_feature_incompatible_peers() {
		let cfgs = create_peermgr_cfgs(2);
		let incompatible_cfgs = create_feature_incompatible_peermgr_cfgs(2);

		let peers = create_network(2, &cfgs);
		let incompatible_peers = create_network(2, &incompatible_cfgs);
		let peer_pairs = [(&peers[0], &incompatible_peers[0]), (&incompatible_peers[1], &peers[1])];
		for (peer_a, peer_b) in peer_pairs.iter() {
			let id_a = peer_a.node_signer.get_node_id(Recipient::Node).unwrap();
			let mut fd_a = FileDescriptor::new(1);
			let addr_a = SocketAddress::TcpIpV4 { addr: [127, 0, 0, 1], port: 1000 };
			let mut fd_b = FileDescriptor::new(1);
			let addr_b = SocketAddress::TcpIpV4 { addr: [127, 0, 0, 1], port: 1001 };
			let initial_data =
				peer_b.new_outbound_connection(id_a, fd_b.clone(), Some(addr_a.clone())).unwrap();
			peer_a.new_inbound_connection(fd_a.clone(), Some(addr_b.clone())).unwrap();
			assert_eq!(peer_a.read_event(&mut fd_a, &initial_data).unwrap(), false);
			peer_a.process_events();

			let a_data = fd_a.outbound_data.lock().unwrap().split_off(0);
			assert_eq!(peer_b.read_event(&mut fd_b, &a_data).unwrap(), false);

			peer_b.process_events();
			let b_data = fd_b.outbound_data.lock().unwrap().split_off(0);

			// Should fail because of unknown required features
			assert!(peer_a.read_event(&mut fd_a, &b_data).is_err());
		}
	}

	#[test]
	fn test_chain_incompatible_peers() {
		let cfgs = create_peermgr_cfgs(2);
		let incompatible_cfgs = create_chain_incompatible_peermgr_cfgs(2);

		let peers = create_network(2, &cfgs);
		let incompatible_peers = create_network(2, &incompatible_cfgs);
		let peer_pairs = [(&peers[0], &incompatible_peers[0]), (&incompatible_peers[1], &peers[1])];
		for (peer_a, peer_b) in peer_pairs.iter() {
			let id_a = peer_a.node_signer.get_node_id(Recipient::Node).unwrap();
			let mut fd_a = FileDescriptor::new(1);
			let addr_a = SocketAddress::TcpIpV4 { addr: [127, 0, 0, 1], port: 1000 };
			let mut fd_b = FileDescriptor::new(1);
			let addr_b = SocketAddress::TcpIpV4 { addr: [127, 0, 0, 1], port: 1001 };
			let initial_data =
				peer_b.new_outbound_connection(id_a, fd_b.clone(), Some(addr_a.clone())).unwrap();
			peer_a.new_inbound_connection(fd_a.clone(), Some(addr_b.clone())).unwrap();
			assert_eq!(peer_a.read_event(&mut fd_a, &initial_data).unwrap(), false);
			peer_a.process_events();

			let a_data = fd_a.outbound_data.lock().unwrap().split_off(0);
			assert_eq!(peer_b.read_event(&mut fd_b, &a_data).unwrap(), false);

			peer_b.process_events();
			let b_data = fd_b.outbound_data.lock().unwrap().split_off(0);

			// Should fail because of incompatible chains
			assert!(peer_a.read_event(&mut fd_a, &b_data).is_err());
		}
	}

	#[test]
	fn test_disconnect_peer() {
		// Simple test which builds a network of PeerManager, connects and brings them to NoiseState::Finished and
		// push a DisconnectPeer event to remove the node flagged by id
		let cfgs = create_peermgr_cfgs(2);
		let peers = create_network(2, &cfgs);
		establish_connection(&peers[0], &peers[1]);
		{
			let peers_len = peers[0].peers.read().unwrap().len();
			assert_eq!(peers_len, 1);
		}

		let their_id = peers[1].node_signer.get_node_id(Recipient::Node).unwrap();
		cfgs[0].chan_handler.pending_events.lock().unwrap().push(MessageSendEvent::HandleError {
			node_id: their_id,
			action: msgs::ErrorAction::DisconnectPeer { msg: None },
		});

		peers[0].process_events();
		{
			let peers_len = peers[0].peers.read().unwrap().len();
			assert_eq!(peers_len, 0);
		}
	}

	#[test]
	fn test_send_simple_msg() {
		// Simple test which builds a network of PeerManager, connects and brings them to NoiseState::Finished and
		// push a message from one peer to another.
		let cfgs = create_peermgr_cfgs(2);
		let a_chan_handler = test_utils::TestChannelMessageHandler::new(
			ChainHash::using_genesis_block(Network::Testnet),
		);
		let b_chan_handler = test_utils::TestChannelMessageHandler::new(
			ChainHash::using_genesis_block(Network::Testnet),
		);
		let mut peers = create_network(2, &cfgs);
		let (fd_a, mut fd_b) = establish_connection(&peers[0], &peers[1]);
		{
			let peers_len = peers[0].peers.read().unwrap().len();
			assert_eq!(peers_len, 1);
		}

		let their_id = peers[1].node_signer.get_node_id(Recipient::Node).unwrap();

		let msg = msgs::Shutdown {
			channel_id: ChannelId::from_bytes([42; 32]),
			scriptpubkey: bitcoin::ScriptBuf::new(),
		};
		a_chan_handler
			.pending_events
			.lock()
			.unwrap()
			.push(MessageSendEvent::SendShutdown { node_id: their_id, msg: msg.clone() });
		peers[0].message_handler.chan_handler = &a_chan_handler;

		b_chan_handler.expect_receive_msg(wire::Message::Shutdown(msg));
		peers[1].message_handler.chan_handler = &b_chan_handler;

		peers[0].process_events();

		let a_data = fd_a.outbound_data.lock().unwrap().split_off(0);
		assert_eq!(peers[1].read_event(&mut fd_b, &a_data).unwrap(), false);
	}

	#[test]
	fn test_non_init_first_msg() {
		// Simple test of the first message received over a connection being something other than
		// Init. This results in an immediate disconnection, which previously included a spurious
		// peer_disconnected event handed to event handlers (which would panic in
		// `TestChannelMessageHandler` here).
		let cfgs = create_peermgr_cfgs(2);
		let peers = create_network(2, &cfgs);

		let mut fd_dup = FileDescriptor::new(3);
		let addr_dup = SocketAddress::TcpIpV4 { addr: [127, 0, 0, 1], port: 1003 };
		let id_a = cfgs[0].node_signer.get_node_id(Recipient::Node).unwrap();
		peers[0].new_inbound_connection(fd_dup.clone(), Some(addr_dup.clone())).unwrap();

		let mut dup_encryptor =
			PeerChannelEncryptor::new_outbound(id_a, SecretKey::from_slice(&[42; 32]).unwrap());
		let initial_data = dup_encryptor.get_act_one(&peers[1].secp_ctx);
		assert_eq!(peers[0].read_event(&mut fd_dup, &initial_data).unwrap(), false);
		peers[0].process_events();

		let a_data = fd_dup.outbound_data.lock().unwrap().split_off(0);
		let (act_three, _) =
			dup_encryptor.process_act_two(&a_data[..], &&cfgs[1].node_signer).unwrap();
		assert_eq!(peers[0].read_event(&mut fd_dup, &act_three).unwrap(), false);

		let not_init_msg = msgs::Ping { ponglen: 4, byteslen: 0 };
		let msg_bytes = dup_encryptor.encrypt_message(&not_init_msg);
		assert!(peers[0].read_event(&mut fd_dup, &msg_bytes).is_err());
	}

	#[test]
	fn test_disconnect_all_peer() {
		// Simple test which builds a network of PeerManager, connects and brings them to NoiseState::Finished and
		// then calls disconnect_all_peers
		let cfgs = create_peermgr_cfgs(2);
		let peers = create_network(2, &cfgs);
		establish_connection(&peers[0], &peers[1]);
		{
			let peers_len = peers[0].peers.read().unwrap().len();
			assert_eq!(peers_len, 1);
		}

		peers[0].disconnect_all_peers();
		{
			let peers_len = peers[0].peers.read().unwrap().len();
			assert_eq!(peers_len, 0);
		}
	}

	#[test]
	fn test_timer_tick_occurred() {
		// Create peers, a vector of two peer managers, perform initial set up and check that peers[0] has one Peer.
		let cfgs = create_peermgr_cfgs(2);
		let peers = create_network(2, &cfgs);
		establish_connection(&peers[0], &peers[1]);
		{
			let peers_len = peers[0].peers.read().unwrap().len();
			assert_eq!(peers_len, 1);
		}

		// peers[0] awaiting_pong is set to true, but the Peer is still connected
		peers[0].timer_tick_occurred();
		peers[0].process_events();
		{
			let peers_len = peers[0].peers.read().unwrap().len();
			assert_eq!(peers_len, 1);
		}

		// Since timer_tick_occurred() is called again when awaiting_pong is true, all Peers are disconnected
		peers[0].timer_tick_occurred();
		peers[0].process_events();
		{
			let peers_len = peers[0].peers.read().unwrap().len();
			assert_eq!(peers_len, 0);
		}
	}

	fn do_test_peer_connected_error_disconnects(handler: usize) {
		// Test that if a message handler fails a connection in `peer_connected` we reliably
		// produce `peer_disconnected` events for all other message handlers (that saw a
		// corresponding `peer_connected`).
		let cfgs = create_peermgr_cfgs(2);
		let peers = create_network(2, &cfgs);

		let chan_handler = peers[handler & 1].message_handler.chan_handler;
		let route_handler = peers[handler & 1].message_handler.route_handler;
		let custom_message_handler = peers[handler & 1].message_handler.custom_message_handler;
		let send_only_msg_handler = peers[handler & 1].message_handler.send_only_message_handler;

		match handler & !1 {
			0 => {
				chan_handler.conn_tracker.fail_connections.store(true, Ordering::Release);
			},
			2 => {
				route_handler.conn_tracker.fail_connections.store(true, Ordering::Release);
			},
			4 => {
				custom_message_handler.conn_tracker.fail_connections.store(true, Ordering::Release);
			},
			6 => {
				send_only_msg_handler.0.fail_connections.store(true, Ordering::Release);
			},
			_ => panic!(),
		}
		let (_sd1, _sd2, a_refused, b_refused) = try_establish_connection(&peers[0], &peers[1]);
		if handler & 1 == 0 {
			assert!(a_refused.is_err());
			assert!(peers[0].list_peers().is_empty());
		} else {
			assert!(b_refused.is_err());
			assert!(peers[1].list_peers().is_empty());
		}
		// At least one message handler should have seen the connection.
		assert!(
			chan_handler.conn_tracker.had_peers.load(Ordering::Acquire)
				|| route_handler.conn_tracker.had_peers.load(Ordering::Acquire)
				|| custom_message_handler.conn_tracker.had_peers.load(Ordering::Acquire)
				|| send_only_msg_handler.0.had_peers.load(Ordering::Acquire)
		);
		// And both message handlers doing tracking should see the disconnection
		assert!(chan_handler.conn_tracker.connected_peers.lock().unwrap().is_empty());
		assert!(route_handler.conn_tracker.connected_peers.lock().unwrap().is_empty());
		assert!(custom_message_handler.conn_tracker.connected_peers.lock().unwrap().is_empty());
		assert!(send_only_msg_handler.0.connected_peers.lock().unwrap().is_empty());
	}

	#[test]
	fn test_peer_connected_error_disconnects() {
		for i in 0..8 {
			do_test_peer_connected_error_disconnects(i);
		}
	}

	#[test]
	fn test_do_attempt_write_data() {
		// Create 2 peers with custom TestRoutingMessageHandlers and connect them.
		let cfgs = create_peermgr_cfgs(2);
		cfgs[0].routing_handler.request_full_sync.store(true, Ordering::Release);
		cfgs[1].routing_handler.request_full_sync.store(true, Ordering::Release);
		cfgs[0].routing_handler.announcement_available_for_sync.store(true, Ordering::Release);
		cfgs[1].routing_handler.announcement_available_for_sync.store(true, Ordering::Release);
		let peers = create_network(2, &cfgs);

		// By calling establish_connect, we trigger do_attempt_write_data between
		// the peers. Previously this function would mistakenly enter an infinite loop
		// when there were more channel messages available than could fit into a peer's
		// buffer. This issue would now be detected by this test (because we use custom
		// RoutingMessageHandlers that intentionally return more channel messages
		// than can fit into a peer's buffer).
		let (mut fd_a, mut fd_b) = establish_connection(&peers[0], &peers[1]);

		// Make each peer to read the messages that the other peer just wrote to them. Note that
		// due to the max-message-before-ping limits this may take a few iterations to complete.
		for _ in 0..150 / super::BUFFER_DRAIN_MSGS_PER_TICK + 1 {
			peers[1].process_events();
			let a_read_data = fd_b.outbound_data.lock().unwrap().split_off(0);
			assert!(!a_read_data.is_empty());

			peers[0].read_event(&mut fd_a, &a_read_data).unwrap();
			peers[0].process_events();

			let b_read_data = fd_a.outbound_data.lock().unwrap().split_off(0);
			assert!(!b_read_data.is_empty());
			peers[1].read_event(&mut fd_b, &b_read_data).unwrap();

			peers[0].process_events();
			assert_eq!(
				fd_a.outbound_data.lock().unwrap().len(),
				0,
				"Until A receives data, it shouldn't send more messages"
			);
		}

		// Check that each peer has received the expected number of channel updates and channel
		// announcements.
		assert_eq!(cfgs[0].routing_handler.chan_upds_recvd.load(Ordering::Acquire), 108);
		assert_eq!(cfgs[0].routing_handler.chan_anns_recvd.load(Ordering::Acquire), 54);
		assert_eq!(cfgs[1].routing_handler.chan_upds_recvd.load(Ordering::Acquire), 108);
		assert_eq!(cfgs[1].routing_handler.chan_anns_recvd.load(Ordering::Acquire), 54);
	}

	#[test]
	fn test_handshake_timeout() {
		// Tests that we time out a peer still waiting on handshake completion after a full timer
		// tick.
		let cfgs = create_peermgr_cfgs(2);
		cfgs[0].routing_handler.request_full_sync.store(true, Ordering::Release);
		cfgs[1].routing_handler.request_full_sync.store(true, Ordering::Release);
		let peers = create_network(2, &cfgs);

		let a_id = peers[0].node_signer.get_node_id(Recipient::Node).unwrap();
		let mut fd_a = FileDescriptor::new(1);
		let mut fd_b = FileDescriptor::new(1);
		let initial_data = peers[1].new_outbound_connection(a_id, fd_b.clone(), None).unwrap();
		peers[0].new_inbound_connection(fd_a.clone(), None).unwrap();

		// If we get a single timer tick before completion, that's fine
		{
			let peers_len = peers[0].peers.read().unwrap().len();
			assert_eq!(peers_len, 1);
		}
		peers[0].timer_tick_occurred();
		{
			let peers_len = peers[0].peers.read().unwrap().len();
			assert_eq!(peers_len, 1);
		}

		assert_eq!(peers[0].read_event(&mut fd_a, &initial_data).unwrap(), false);
		peers[0].process_events();
		let a_data = fd_a.outbound_data.lock().unwrap().split_off(0);
		assert_eq!(peers[1].read_event(&mut fd_b, &a_data).unwrap(), false);
		peers[1].process_events();

		// ...but if we get a second timer tick, we should disconnect the peer
		peers[0].timer_tick_occurred();
		{
			let peers_len = peers[0].peers.read().unwrap().len();
			assert_eq!(peers_len, 0);
		}

		let b_data = fd_b.outbound_data.lock().unwrap().split_off(0);
		assert!(peers[0].read_event(&mut fd_a, &b_data).is_err());
	}

	#[test]
	fn test_inbound_conn_handshake_complete_awaiting_pong() {
		// Test that we do not disconnect an outbound peer after the noise handshake completes due
		// to a pong timeout for a ping that was never sent if a timer tick fires after we send act
		// two of the noise handshake along with our init message but before we receive their init
		// message.
		let logger = test_utils::TestLogger::new();
		let node_signer_a =
			test_utils::TestNodeSigner::new(SecretKey::from_slice(&[42; 32]).unwrap());
		let node_signer_b =
			test_utils::TestNodeSigner::new(SecretKey::from_slice(&[43; 32]).unwrap());
		let message_handler_a = MessageHandler {
			chan_handler: ErroringMessageHandler::new(),
			route_handler: IgnoringMessageHandler {},
			onion_message_handler: IgnoringMessageHandler {},
			custom_message_handler: IgnoringMessageHandler {},
			send_only_message_handler: IgnoringMessageHandler {},
		};
		let message_handler_b = MessageHandler {
			chan_handler: ErroringMessageHandler::new(),
			route_handler: IgnoringMessageHandler {},
			onion_message_handler: IgnoringMessageHandler {},
			custom_message_handler: IgnoringMessageHandler {},
			send_only_message_handler: IgnoringMessageHandler {},
		};
		let peer_a = PeerManager::new(message_handler_a, 0, &[0; 32], &logger, &node_signer_a);
		let peer_b = PeerManager::new(message_handler_b, 0, &[1; 32], &logger, &node_signer_b);

		let a_id = node_signer_a.get_node_id(Recipient::Node).unwrap();
		let mut fd_a = FileDescriptor::new(1);
		let mut fd_b = FileDescriptor::new(1);

		// Exchange messages with both peers until they both complete the init handshake.
		let act_one = peer_b.new_outbound_connection(a_id, fd_b.clone(), None).unwrap();
		peer_a.new_inbound_connection(fd_a.clone(), None).unwrap();

		assert_eq!(peer_a.read_event(&mut fd_a, &act_one).unwrap(), false);
		peer_a.process_events();

		let act_two = fd_a.outbound_data.lock().unwrap().split_off(0);
		assert_eq!(peer_b.read_event(&mut fd_b, &act_two).unwrap(), false);
		peer_b.process_events();

		// Calling this here triggers the race on inbound connections.
		peer_b.timer_tick_occurred();

		let act_three_with_init_b = fd_b.outbound_data.lock().unwrap().split_off(0);
		{
			let peer_a_lock = peer_a.peers.read().unwrap();
			let handshake_complete =
				peer_a_lock.get(&fd_a).unwrap().lock().unwrap().handshake_complete();
			assert!(!handshake_complete);
		}

		assert_eq!(peer_a.read_event(&mut fd_a, &act_three_with_init_b).unwrap(), false);
		peer_a.process_events();

		{
			let peer_a_lock = peer_a.peers.read().unwrap();
			let handshake_complete =
				peer_a_lock.get(&fd_a).unwrap().lock().unwrap().handshake_complete();
			assert!(handshake_complete);
		}

		let init_a = fd_a.outbound_data.lock().unwrap().split_off(0);
		assert!(!init_a.is_empty());

		{
			let peer_b_lock = peer_b.peers.read().unwrap();
			let handshake_complete =
				peer_b_lock.get(&fd_b).unwrap().lock().unwrap().handshake_complete();
			assert!(!handshake_complete);
		}

		assert_eq!(peer_b.read_event(&mut fd_b, &init_a).unwrap(), false);
		peer_b.process_events();

		{
			let peer_b_lock = peer_b.peers.read().unwrap();
			let handshake_complete =
				peer_b_lock.get(&fd_b).unwrap().lock().unwrap().handshake_complete();
			assert!(handshake_complete);
		}

		// Make sure we're still connected.
		{
			let peers_len = peer_b.peers.read().unwrap().len();
			assert_eq!(peers_len, 1);
		}

		// B should send a ping on the first timer tick after `handshake_complete`.
		assert!(fd_b.outbound_data.lock().unwrap().split_off(0).is_empty());
		peer_b.timer_tick_occurred();
		peer_b.process_events();
		assert!(!fd_b.outbound_data.lock().unwrap().split_off(0).is_empty());

		let mut send_warning = || {
			{
				let peers = peer_a.peers.read().unwrap();
				let mut peer_b = peers.get(&fd_a).unwrap().lock().unwrap();
				peer_a.enqueue_message(
					&mut peer_b,
					&msgs::WarningMessage {
						channel_id: ChannelId([0; 32]),
						data: "no disconnect plz".to_string(),
					},
				);
			}
			peer_a.process_events();
			let msg = fd_a.outbound_data.lock().unwrap().split_off(0);
			assert!(!msg.is_empty());
			assert_eq!(peer_b.read_event(&mut fd_b, &msg).unwrap(), false);
			peer_b.process_events();
		};

		// Fire more ticks until we reach the pong timeout. We send any message except pong to
		// pretend the connection is still alive.
		send_warning();
		for _ in 0..MAX_BUFFER_DRAIN_TICK_INTERVALS_PER_PEER {
			peer_b.timer_tick_occurred();
			send_warning();
		}
		{
			let peers_len = peer_b.peers.read().unwrap().len();
			assert_eq!(peers_len, 1);
		}

		// One more tick should enforce the pong timeout.
		peer_b.timer_tick_occurred();
		{
			let peers_len = peer_b.peers.read().unwrap().len();
			assert_eq!(peers_len, 0);
		}
	}

	#[test]
	fn test_gossip_flood_pause() {
		use crate::routing::test_utils::channel_announcement;
		use lightning_types::features::ChannelFeatures;

		// Simple test which connects two nodes to a PeerManager and checks that if we run out of
		// socket buffer space we'll stop forwarding gossip but still push our own gossip.
		let cfgs = create_peermgr_cfgs(2);
		let peers = create_network(2, &cfgs);
		let (mut fd_a, mut fd_b) = establish_connection(&peers[0], &peers[1]);

		macro_rules! drain_queues {
			() => {
				loop {
					peers[0].process_events();
					peers[1].process_events();

					let msg = fd_a.outbound_data.lock().unwrap().split_off(0);
					if !msg.is_empty() {
						assert_eq!(peers[1].read_event(&mut fd_b, &msg).unwrap(), false);
						continue;
					}
					let msg = fd_b.outbound_data.lock().unwrap().split_off(0);
					if !msg.is_empty() {
						assert_eq!(peers[0].read_event(&mut fd_a, &msg).unwrap(), false);
						continue;
					}
					break;
				}
			};
		}

		// First, make sure all pending messages have been processed and queues drained.
		drain_queues!();

		let secp_ctx = Secp256k1::new();
		let key = SecretKey::from_slice(&[1; 32]).unwrap();
		let msg = channel_announcement(&key, &key, ChannelFeatures::empty(), 42, &secp_ctx);
		let msg_ev = MessageSendEvent::BroadcastChannelAnnouncement { msg, update_msg: None };

		fd_a.hang_writes.store(true, Ordering::Relaxed);

		// Now push an arbitrarily large number of messages and check that only
		// `OUTBOUND_BUFFER_LIMIT_DROP_GOSSIP` messages end up in the queue.
		for _ in 0..OUTBOUND_BUFFER_LIMIT_DROP_GOSSIP * 2 {
			cfgs[0].routing_handler.pending_events.lock().unwrap().push(msg_ev.clone());
			peers[0].process_events();
		}

		{
			let peer_a_lock = peers[0].peers.read().unwrap();
			let buf_len =
				peer_a_lock.get(&fd_a).unwrap().lock().unwrap().gossip_broadcast_buffer.len();
			assert_eq!(buf_len, OUTBOUND_BUFFER_LIMIT_DROP_GOSSIP);
		}

		// Check that if a broadcast message comes in from the channel handler (i.e. it is an
		// announcement for our own channel), it gets queued anyway.
		cfgs[0].chan_handler.pending_events.lock().unwrap().push(msg_ev);
		peers[0].process_events();

		{
			let peer_a_lock = peers[0].peers.read().unwrap();
			let buf_len =
				peer_a_lock.get(&fd_a).unwrap().lock().unwrap().gossip_broadcast_buffer.len();
			assert_eq!(buf_len, OUTBOUND_BUFFER_LIMIT_DROP_GOSSIP + 1);
		}

		// Finally, deliver all the messages and make sure we got the right count. Note that there
		// was an extra message that had already moved from the broadcast queue to the encrypted
		// message queue so we actually receive `OUTBOUND_BUFFER_LIMIT_DROP_GOSSIP + 2` messages.
		fd_a.hang_writes.store(false, Ordering::Relaxed);
		cfgs[1].routing_handler.chan_anns_recvd.store(0, Ordering::Relaxed);
		peers[0].write_buffer_space_avail(&mut fd_a).unwrap();

		drain_queues!();
		{
			let peer_a_lock = peers[0].peers.read().unwrap();
			let empty =
				peer_a_lock.get(&fd_a).unwrap().lock().unwrap().gossip_broadcast_buffer.is_empty();
			assert!(empty);
		}

		assert_eq!(
			cfgs[1].routing_handler.chan_anns_recvd.load(Ordering::Relaxed),
			OUTBOUND_BUFFER_LIMIT_DROP_GOSSIP + 2
		);
	}

	#[test]
	fn test_filter_addresses() {
		// Tests the filter_addresses function.

		// For (10/8)
		let ip_address = SocketAddress::TcpIpV4 { addr: [10, 0, 0, 0], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [10, 0, 255, 201], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [10, 255, 255, 255], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);

		// For (0/8)
		let ip_address = SocketAddress::TcpIpV4 { addr: [0, 0, 0, 0], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [0, 0, 255, 187], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [0, 255, 255, 255], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);

		// For (100.64/10)
		let ip_address = SocketAddress::TcpIpV4 { addr: [100, 64, 0, 0], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [100, 78, 255, 0], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [100, 127, 255, 255], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);

		// For (127/8)
		let ip_address = SocketAddress::TcpIpV4 { addr: [127, 0, 0, 0], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [127, 65, 73, 0], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [127, 255, 255, 255], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);

		// For (169.254/16)
		let ip_address = SocketAddress::TcpIpV4 { addr: [169, 254, 0, 0], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [169, 254, 221, 101], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [169, 254, 255, 255], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);

		// For (172.16/12)
		let ip_address = SocketAddress::TcpIpV4 { addr: [172, 16, 0, 0], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [172, 27, 101, 23], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [172, 31, 255, 255], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);

		// For (192.168/16)
		let ip_address = SocketAddress::TcpIpV4 { addr: [192, 168, 0, 0], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [192, 168, 205, 159], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [192, 168, 255, 255], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);

		// For (192.88.99/24)
		let ip_address = SocketAddress::TcpIpV4 { addr: [192, 88, 99, 0], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [192, 88, 99, 140], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV4 { addr: [192, 88, 99, 255], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);

		// For other IPv4 addresses
		let ip_address = SocketAddress::TcpIpV4 { addr: [188, 255, 99, 0], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), Some(ip_address.clone()));
		let ip_address = SocketAddress::TcpIpV4 { addr: [123, 8, 129, 14], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), Some(ip_address.clone()));
		let ip_address = SocketAddress::TcpIpV4 { addr: [2, 88, 9, 255], port: 1000 };
		assert_eq!(filter_addresses(Some(ip_address.clone())), Some(ip_address.clone()));

		// For (2000::/3)
		let ip_address = SocketAddress::TcpIpV6 {
			addr: [32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			port: 1000,
		};
		assert_eq!(filter_addresses(Some(ip_address.clone())), Some(ip_address.clone()));
		let ip_address = SocketAddress::TcpIpV6 {
			addr: [45, 34, 209, 190, 0, 123, 55, 34, 0, 0, 3, 27, 201, 0, 0, 0],
			port: 1000,
		};
		assert_eq!(filter_addresses(Some(ip_address.clone())), Some(ip_address.clone()));
		let ip_address = SocketAddress::TcpIpV6 {
			addr: [63, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],
			port: 1000,
		};
		assert_eq!(filter_addresses(Some(ip_address.clone())), Some(ip_address.clone()));

		// For other IPv6 addresses
		let ip_address = SocketAddress::TcpIpV6 {
			addr: [24, 240, 12, 32, 0, 0, 0, 0, 20, 97, 0, 32, 121, 254, 0, 0],
			port: 1000,
		};
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV6 {
			addr: [68, 23, 56, 63, 0, 0, 2, 7, 75, 109, 0, 39, 0, 0, 0, 0],
			port: 1000,
		};
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);
		let ip_address = SocketAddress::TcpIpV6 {
			addr: [101, 38, 140, 230, 100, 0, 30, 98, 0, 26, 0, 0, 57, 96, 0, 0],
			port: 1000,
		};
		assert_eq!(filter_addresses(Some(ip_address.clone())), None);

		// For (None)
		assert_eq!(filter_addresses(None), None);
	}

	#[test]
	#[cfg(feature = "std")]
	fn test_process_events_multithreaded() {
		use std::time::{Duration, Instant};
		// `process_events` shouldn't block on another thread processing events and instead should
		// simply signal the currently processing thread to go around the loop again.
		// Here we test that this happens by spawning a few threads and checking that we see one go
		// around again at least once.
		//
		// Each time `process_events` goes around the loop we call
		// `get_and_clear_pending_msg_events`, which we count using the `TestMessageHandler`. Thus,
		// to test we simply write zero to the counter before calling `process_events` and make
		// sure we observe a value greater than one at least once.
		let cfg = Arc::new(create_peermgr_cfgs(1));
		// Until we have std::thread::scoped we have to unsafe { turn off the borrow checker }.
		let peer = Arc::new(
			create_network(1, unsafe { &*(&*cfg as *const _) as &'static _ }).pop().unwrap(),
		);

		let end_time = Instant::now() + Duration::from_millis(100);
		let observed_loop = Arc::new(AtomicBool::new(false));
		let thread_fn = || {
			let thread_peer = Arc::clone(&peer);
			let thread_observed_loop = Arc::clone(&observed_loop);
			move || {
				while Instant::now() < end_time || !thread_observed_loop.load(Ordering::Acquire) {
					test_utils::TestChannelMessageHandler::MESSAGE_FETCH_COUNTER
						.with(|val| val.store(0, Ordering::Relaxed));
					thread_peer.process_events();
					if test_utils::TestChannelMessageHandler::MESSAGE_FETCH_COUNTER
						.with(|val| val.load(Ordering::Relaxed))
						> 1
					{
						thread_observed_loop.store(true, Ordering::Release);
						return;
					}
					std::thread::sleep(Duration::from_micros(1));
				}
			}
		};

		let thread_a = std::thread::spawn(thread_fn());
		let thread_b = std::thread::spawn(thread_fn());
		let thread_c = std::thread::spawn(thread_fn());
		thread_fn()();
		thread_a.join().unwrap();
		thread_b.join().unwrap();
		thread_c.join().unwrap();
		assert!(observed_loop.load(Ordering::Acquire));
	}
}
