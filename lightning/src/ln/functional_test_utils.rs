// This file is Copyright its original authors, visible in version control
// history.
//
// This file is licensed under the Apache License, Version 2.0 <LICENSE-APACHE
// or http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your option.
// You may not use this file except in accordance with one or both of these
// licenses.

//! A bunch of useful utilities for building networks of nodes and exchanging messages between
//! nodes for functional tests.

use crate::blinded_path::payment::DummyTlvs;
use crate::chain::channelmonitor::ChannelMonitor;
use crate::chain::transaction::OutPoint;
use crate::chain::{BestBlock, ChannelMonitorUpdateStatus, Confirm, Listen, Watch};
use crate::events::bump_transaction::sync::{
	BumpTransactionEventHandlerSync, WalletSourceSync, WalletSync,
};
use crate::events::bump_transaction::BumpTransactionEvent;
use crate::events::{
	ClaimedHTLC, ClosureReason, Event, HTLCHandlingFailureType, PaidBolt12Invoice, PathFailure,
	PaymentFailureReason, PaymentPurpose,
};
use crate::ln::chan_utils::{
	commitment_tx_base_weight, COMMITMENT_TX_WEIGHT_PER_HTLC, TRUC_MAX_WEIGHT,
};
use crate::ln::channelmanager::{
	AChannelManager, ChainParameters, ChannelManager, ChannelManagerReadArgs, PaymentId,
	RAACommitmentOrder, MIN_CLTV_EXPIRY_DELTA,
};
use crate::ln::funding::FundingTxInput;
use crate::ln::msgs::{self, OpenChannel};
use crate::ln::msgs::{
	BaseMessageHandler, ChannelMessageHandler, MessageSendEvent, RoutingMessageHandler,
};
use crate::ln::onion_utils::LocalHTLCFailureReason;
use crate::ln::outbound_payment::RecipientOnionFields;
use crate::ln::outbound_payment::Retry;
use crate::ln::peer_handler::IgnoringMessageHandler;
use crate::ln::types::ChannelId;
use crate::onion_message::messenger::OnionMessenger;
use crate::routing::gossip::{NetworkGraph, NetworkUpdate, P2PGossipSync};
use crate::routing::router::{self, PaymentParameters, Route, RouteParameters};
use crate::sign::{EntropySource, RandomBytes};
use crate::types::features::ChannelTypeFeatures;
use crate::types::features::InitFeatures;
use crate::types::payment::{PaymentHash, PaymentPreimage, PaymentSecret};
use crate::util::config::{MaxDustHTLCExposure, UserConfig};
use crate::util::logger::Logger;
use crate::util::scid_utils;
use crate::util::ser::{ReadableArgs, Writeable};
use crate::util::test_channel_signer::SignerOp;
use crate::util::test_channel_signer::TestChannelSigner;
use crate::util::test_utils::{self, TestLogger};
use crate::util::test_utils::{TestChainMonitor, TestKeysInterface, TestScorer};

use bitcoin::amount::Amount;
use bitcoin::block::{Block, Header, Version as BlockVersion};
use bitcoin::hash_types::{BlockHash, TxMerkleNode};
use bitcoin::hashes::sha256::Hash as Sha256;
use bitcoin::hashes::Hash as _;
use bitcoin::locktime::absolute::{LockTime, LOCK_TIME_THRESHOLD};
use bitcoin::network::Network;
use bitcoin::policy::MAX_STANDARD_TX_WEIGHT;
use bitcoin::pow::CompactTarget;
use bitcoin::script::ScriptBuf;
use bitcoin::secp256k1::{PublicKey, SecretKey};
use bitcoin::transaction::{self, Version as TxVersion};
use bitcoin::transaction::{Transaction, TxIn, TxOut};
use bitcoin::WPubkeyHash;

use crate::io;
use crate::prelude::*;
use crate::sync::{Arc, LockTestExt, Mutex, RwLock};
use alloc::rc::Rc;
use core::cell::RefCell;
use core::iter::repeat;
use core::mem;
use core::ops::Deref;

pub const CHAN_CONFIRM_DEPTH: u32 = 10;

/// Mine the given transaction in the next block and then mine CHAN_CONFIRM_DEPTH - 1 blocks on
/// top, giving the given transaction CHAN_CONFIRM_DEPTH confirmations.
///
/// Returns the SCID a channel confirmed in the given transaction will have, assuming the funding
/// output is the 1st output in the transaction.
pub fn confirm_transaction<'a, 'b, 'c, 'd>(node: &'a Node<'b, 'c, 'd>, tx: &Transaction) -> u64 {
	let scid = confirm_transaction_at(node, tx, node.best_block_info().1 + 1);
	connect_blocks(node, CHAN_CONFIRM_DEPTH - 1);
	scid
}
/// Mine a single block containing the given transaction
///
/// Returns the SCID a channel confirmed in the given transaction will have, assuming the funding
/// output is the 1st output in the transaction.
pub fn mine_transaction<'a, 'b, 'c, 'd>(node: &'a Node<'b, 'c, 'd>, tx: &Transaction) -> u64 {
	let height = node.best_block_info().1 + 1;
	confirm_transaction_at(node, tx, height)
}
/// Mine a single block containing the given transactions
pub fn mine_transactions<'a, 'b, 'c, 'd>(node: &'a Node<'b, 'c, 'd>, txn: &[&Transaction]) {
	let height = node.best_block_info().1 + 1;
	confirm_transactions_at(node, txn, height);
}
/// Mine a single block containing the given transaction without extra consistency checks which may
/// impact ChannelManager state.
pub fn mine_transaction_without_consistency_checks<'a, 'b, 'c, 'd>(
	node: &'a Node<'b, 'c, 'd>, tx: &Transaction,
) {
	let height = node.best_block_info().1 + 1;
	let mut block = Block {
		header: Header {
			version: BlockVersion::NO_SOFT_FORK_SIGNALLING,
			prev_blockhash: node.best_block_hash(),
			merkle_root: TxMerkleNode::all_zeros(),
			time: height,
			bits: CompactTarget::from_consensus(42),
			nonce: 42,
		},
		txdata: Vec::new(),
	};
	for _ in 0..*node.network_chan_count.borrow() {
		// Make sure we don't end up with channels at the same short id by offsetting by chan_count
		block.txdata.push(Transaction {
			version: transaction::Version(0),
			lock_time: LockTime::ZERO,
			input: Vec::new(),
			output: Vec::new(),
		});
	}
	block.txdata.push((*tx).clone());
	do_connect_block_without_consistency_checks(node, block, false);
}
/// Mine the given transaction at the given height, mining blocks as required to build to that
/// height
///
/// Returns the SCID a channel confirmed in the given transaction will have, assuming the funding
/// output is the 1st output in the transaction.
pub fn confirm_transactions_at<'a, 'b, 'c, 'd>(
	node: &'a Node<'b, 'c, 'd>, txn: &[&Transaction], conf_height: u32,
) -> u64 {
	let first_connect_height = node.best_block_info().1 + 1;
	assert!(first_connect_height <= conf_height);
	if conf_height > first_connect_height {
		connect_blocks(node, conf_height - first_connect_height);
	}
	let mut txdata = Vec::new();
	for _ in 0..*node.network_chan_count.borrow() {
		// Make sure we don't end up with channels at the same short id by offsetting by chan_count
		txdata.push(Transaction {
			version: transaction::Version(0),
			lock_time: LockTime::ZERO,
			input: Vec::new(),
			output: Vec::new(),
		});
	}
	for tx in txn {
		txdata.push((*tx).clone());
	}
	let block = create_dummy_block(node.best_block_hash(), conf_height, txdata);
	connect_block(node, &block);
	scid_utils::scid_from_parts(conf_height as u64, block.txdata.len() as u64 - 1, 0).unwrap()
}
pub fn confirm_transaction_at<'a, 'b, 'c, 'd>(
	node: &'a Node<'b, 'c, 'd>, tx: &Transaction, conf_height: u32,
) -> u64 {
	confirm_transactions_at(node, &[tx], conf_height)
}

/// The possible ways we may notify a ChannelManager of a new block
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum ConnectStyle {
	/// Calls `best_block_updated` first, detecting transactions in the block only after receiving
	/// the header and height information.
	BestBlockFirst,
	/// The same as `BestBlockFirst`, however when we have multiple blocks to connect, we only
	/// make a single `best_block_updated` call.
	BestBlockFirstSkippingBlocks,
	/// The same as `BestBlockFirst` when connecting blocks. During disconnection only
	/// `transaction_unconfirmed` is called.
	BestBlockFirstReorgsOnlyTip,
	/// Calls `transactions_confirmed` first, detecting transactions in the block before updating
	/// the header and height information.
	TransactionsFirst,
	/// The same as `TransactionsFirst`, however when we have multiple blocks to connect, we only
	/// make a single `best_block_updated` call.
	TransactionsFirstSkippingBlocks,
	/// The same as `TransactionsFirst`, however when we have multiple blocks to connect, we only
	/// make a single `best_block_updated` call. Further, we call `transactions_confirmed` multiple
	/// times to ensure it's idempotent.
	TransactionsDuplicativelyFirstSkippingBlocks,
	/// The same as `TransactionsFirst`, however when we have multiple blocks to connect, we only
	/// make a single `best_block_updated` call. Further, we call `transactions_confirmed` multiple
	/// times to ensure it's idempotent.
	HighlyRedundantTransactionsFirstSkippingBlocks,
	/// The same as `TransactionsFirst` when connecting blocks. During disconnection only
	/// `transaction_unconfirmed` is called.
	TransactionsFirstReorgsOnlyTip,
	/// Provides the full block via the `chain::Listen` interface. In the current code this is
	/// equivalent to `TransactionsFirst` with some additional assertions.
	FullBlockViaListen,
	/// Provides the full block via the `chain::Listen` interface, condensing multiple block
	/// disconnections into a single `blocks_disconnected` call.
	FullBlockDisconnectionsSkippingViaListen,
}

impl ConnectStyle {
	pub fn skips_blocks(&self) -> bool {
		match self {
			ConnectStyle::BestBlockFirst => false,
			ConnectStyle::BestBlockFirstSkippingBlocks => true,
			ConnectStyle::BestBlockFirstReorgsOnlyTip => true,
			ConnectStyle::TransactionsFirst => false,
			ConnectStyle::TransactionsFirstSkippingBlocks => true,
			ConnectStyle::TransactionsDuplicativelyFirstSkippingBlocks => true,
			ConnectStyle::HighlyRedundantTransactionsFirstSkippingBlocks => true,
			ConnectStyle::TransactionsFirstReorgsOnlyTip => true,
			ConnectStyle::FullBlockViaListen => false,
			ConnectStyle::FullBlockDisconnectionsSkippingViaListen => false,
		}
	}

	pub fn updates_best_block_first(&self) -> bool {
		match self {
			ConnectStyle::BestBlockFirst => true,
			ConnectStyle::BestBlockFirstSkippingBlocks => true,
			ConnectStyle::BestBlockFirstReorgsOnlyTip => true,
			ConnectStyle::TransactionsFirst => false,
			ConnectStyle::TransactionsFirstSkippingBlocks => false,
			ConnectStyle::TransactionsDuplicativelyFirstSkippingBlocks => false,
			ConnectStyle::HighlyRedundantTransactionsFirstSkippingBlocks => false,
			ConnectStyle::TransactionsFirstReorgsOnlyTip => false,
			ConnectStyle::FullBlockViaListen => false,
			ConnectStyle::FullBlockDisconnectionsSkippingViaListen => false,
		}
	}

	fn random_style() -> ConnectStyle {
		use core::hash::{BuildHasher, Hasher};
		// Get a random value using the only std API to do so - the DefaultHasher
		let rand_val = std::collections::hash_map::RandomState::new().build_hasher().finish();
		let res = match rand_val % 10 {
			0 => ConnectStyle::BestBlockFirst,
			1 => ConnectStyle::BestBlockFirstSkippingBlocks,
			2 => ConnectStyle::BestBlockFirstReorgsOnlyTip,
			3 => ConnectStyle::TransactionsFirst,
			4 => ConnectStyle::TransactionsFirstSkippingBlocks,
			5 => ConnectStyle::TransactionsDuplicativelyFirstSkippingBlocks,
			6 => ConnectStyle::HighlyRedundantTransactionsFirstSkippingBlocks,
			7 => ConnectStyle::TransactionsFirstReorgsOnlyTip,
			8 => ConnectStyle::FullBlockViaListen,
			9 => ConnectStyle::FullBlockDisconnectionsSkippingViaListen,
			_ => unreachable!(),
		};
		eprintln!("Using Block Connection Style: {:?}", res);
		res
	}
}

pub fn create_dummy_header(prev_blockhash: BlockHash, time: u32) -> Header {
	Header {
		version: BlockVersion::NO_SOFT_FORK_SIGNALLING,
		prev_blockhash,
		merkle_root: TxMerkleNode::all_zeros(),
		time,
		bits: CompactTarget::from_consensus(42),
		nonce: 42,
	}
}

pub fn create_dummy_block(prev_blockhash: BlockHash, time: u32, txdata: Vec<Transaction>) -> Block {
	Block { header: create_dummy_header(prev_blockhash, time), txdata }
}

pub fn connect_blocks<'a, 'b, 'c, 'd>(node: &'a Node<'b, 'c, 'd>, depth: u32) -> BlockHash {
	let skip_intermediaries = node.connect_style.borrow().skips_blocks();

	let height = node.best_block_info().1 + 1;
	let mut block = create_dummy_block(node.best_block_hash(), height, Vec::new());
	assert!(depth >= 1);
	for i in 1..depth {
		let prev_blockhash = block.header.block_hash();
		do_connect_block_with_consistency_checks(node, block, skip_intermediaries);
		block = create_dummy_block(prev_blockhash, height + i, Vec::new());
	}
	let hash = block.header.block_hash();
	do_connect_block_with_consistency_checks(node, block, false);
	hash
}

pub fn connect_block<'a, 'b, 'c, 'd>(node: &'a Node<'b, 'c, 'd>, block: &Block) {
	do_connect_block_with_consistency_checks(node, block.clone(), false);
}

fn call_claimable_balances<'a, 'b, 'c, 'd>(node: &'a Node<'b, 'c, 'd>) {
	// Ensure `get_claimable_balances`' self-tests never panic
	for channel_id in node.chain_monitor.chain_monitor.list_monitors() {
		node.chain_monitor.chain_monitor.get_monitor(channel_id).unwrap().get_claimable_balances();
	}
}

fn do_connect_block_with_consistency_checks<'a, 'b, 'c, 'd>(
	node: &'a Node<'b, 'c, 'd>, block: Block, skip_intermediaries: bool,
) {
	call_claimable_balances(node);
	do_connect_block_without_consistency_checks(node, block, skip_intermediaries);
	call_claimable_balances(node);
	node.node.test_process_background_events();
}

fn do_connect_block_without_consistency_checks<'a, 'b, 'c, 'd>(
	node: &'a Node<'b, 'c, 'd>, block: Block, skip_intermediaries: bool,
) {
	let height = node.best_block_info().1 + 1;
	eprintln!("Connecting block using Block Connection Style: {:?}", *node.connect_style.borrow());
	// Update the block internally before handing it over to LDK, to ensure our assertions regarding
	// transaction broadcast are correct.
	node.blocks.lock().unwrap().push((block.clone(), height));
	if !skip_intermediaries {
		let txdata: Vec<_> = block.txdata.iter().enumerate().collect();
		match *node.connect_style.borrow() {
			ConnectStyle::BestBlockFirst
			| ConnectStyle::BestBlockFirstSkippingBlocks
			| ConnectStyle::BestBlockFirstReorgsOnlyTip => {
				node.chain_monitor.chain_monitor.best_block_updated(&block.header, height);
				call_claimable_balances(node);
				node.chain_monitor.chain_monitor.transactions_confirmed(
					&block.header,
					&txdata,
					height,
				);
				node.node.best_block_updated(&block.header, height);
				node.node.transactions_confirmed(&block.header, &txdata, height);
			},
			ConnectStyle::TransactionsFirst
			| ConnectStyle::TransactionsFirstSkippingBlocks
			| ConnectStyle::TransactionsDuplicativelyFirstSkippingBlocks
			| ConnectStyle::HighlyRedundantTransactionsFirstSkippingBlocks
			| ConnectStyle::TransactionsFirstReorgsOnlyTip => {
				if *node.connect_style.borrow()
					== ConnectStyle::HighlyRedundantTransactionsFirstSkippingBlocks
				{
					let mut connections = Vec::new();
					for (block, height) in node.blocks.lock().unwrap().iter() {
						if !block.txdata.is_empty() {
							// Reconnect all transactions we've ever seen to ensure transaction connection
							// is *really* idempotent. This is a somewhat likely deployment for some
							// esplora implementations of chain sync which try to reduce state and
							// complexity as much as possible.
							//
							// Sadly we have to clone the block here to maintain lockorder. In the
							// future we should consider Arc'ing the blocks to avoid this.
							connections.push((block.clone(), *height));
						}
					}
					for (old_block, height) in connections {
						node.chain_monitor.chain_monitor.transactions_confirmed(
							&old_block.header,
							&old_block.txdata.iter().enumerate().collect::<Vec<_>>(),
							height,
						);
					}
				}
				node.chain_monitor.chain_monitor.transactions_confirmed(
					&block.header,
					&txdata,
					height,
				);
				if *node.connect_style.borrow()
					== ConnectStyle::TransactionsDuplicativelyFirstSkippingBlocks
				{
					node.chain_monitor.chain_monitor.transactions_confirmed(
						&block.header,
						&txdata,
						height,
					);
				}
				call_claimable_balances(node);
				node.chain_monitor.chain_monitor.best_block_updated(&block.header, height);
				node.node.transactions_confirmed(&block.header, &txdata, height);
				node.node.best_block_updated(&block.header, height);
			},
			ConnectStyle::FullBlockViaListen
			| ConnectStyle::FullBlockDisconnectionsSkippingViaListen => {
				node.chain_monitor.chain_monitor.block_connected(&block, height);
				node.node.block_connected(&block, height);
			},
		}
	}

	for tx in &block.txdata {
		for input in &tx.input {
			node.wallet_source.remove_utxo(input.previous_output);
		}
		let wallet_script = node.wallet_source.get_change_script().unwrap();
		for (idx, output) in tx.output.iter().enumerate() {
			if output.script_pubkey == wallet_script {
				let outpoint = bitcoin::OutPoint { txid: tx.compute_txid(), vout: idx as u32 };
				node.wallet_source.add_utxo(outpoint, output.value);
			}
		}
	}
}

pub fn provide_anchor_reserves<'a, 'b, 'c>(nodes: &[Node<'a, 'b, 'c>]) -> Transaction {
	provide_anchor_utxo_reserves(nodes, 1, Amount::ONE_BTC)
}

pub fn provide_anchor_utxo_reserves<'a, 'b, 'c>(
	nodes: &[Node<'a, 'b, 'c>], utxos: usize, amount: Amount,
) -> Transaction {
	let mut output = Vec::with_capacity(nodes.len());
	for node in nodes {
		let script_pubkey = node.wallet_source.get_change_script().unwrap();
		for _ in 0..utxos {
			output.push(TxOut { value: amount, script_pubkey: script_pubkey.clone() });
		}
	}
	let tx = Transaction {
		version: TxVersion::TWO,
		lock_time: LockTime::from_height(nodes[0].best_block_info().1).unwrap(),
		input: vec![TxIn { ..Default::default() }],
		output,
	};
	let height = nodes[0].best_block_info().1 + 1;
	let block = create_dummy_block(nodes[0].best_block_hash(), height, vec![tx.clone()]);
	for node in nodes {
		do_connect_block_with_consistency_checks(node, block.clone(), false);
	}
	tx
}

pub fn disconnect_blocks<'a, 'b, 'c, 'd>(node: &'a Node<'b, 'c, 'd>, count: u32) {
	call_claimable_balances(node);
	eprintln!(
		"Disconnecting {} blocks using Block Connection Style: {:?}",
		count,
		*node.connect_style.borrow()
	);
	for i in 0..count {
		let orig = node.blocks.lock().unwrap().pop().unwrap();
		assert!(orig.1 > 0); // Cannot disconnect genesis
		let prev = node.blocks.lock().unwrap().last().unwrap().clone();

		match *node.connect_style.borrow() {
			ConnectStyle::FullBlockViaListen => {
				let best_block = BestBlock::new(orig.0.header.prev_blockhash, orig.1 - 1);
				node.chain_monitor.chain_monitor.blocks_disconnected(best_block);
				Listen::blocks_disconnected(node.node, best_block);
			},
			ConnectStyle::FullBlockDisconnectionsSkippingViaListen => {
				if i == count - 1 {
					let best_block = BestBlock::new(orig.0.header.prev_blockhash, orig.1 - 1);
					node.chain_monitor.chain_monitor.blocks_disconnected(best_block);
					Listen::blocks_disconnected(node.node, best_block);
				}
			},
			ConnectStyle::BestBlockFirstSkippingBlocks
			| ConnectStyle::TransactionsFirstSkippingBlocks
			| ConnectStyle::HighlyRedundantTransactionsFirstSkippingBlocks
			| ConnectStyle::TransactionsDuplicativelyFirstSkippingBlocks => {
				if i == count - 1 {
					node.chain_monitor.chain_monitor.best_block_updated(&prev.0.header, prev.1);
					node.node.best_block_updated(&prev.0.header, prev.1);
				}
			},
			ConnectStyle::BestBlockFirstReorgsOnlyTip
			| ConnectStyle::TransactionsFirstReorgsOnlyTip => {
				for tx in orig.0.txdata {
					node.chain_monitor.chain_monitor.transaction_unconfirmed(&tx.compute_txid());
					node.node.transaction_unconfirmed(&tx.compute_txid());
				}
			},
			_ => {
				node.chain_monitor.chain_monitor.best_block_updated(&prev.0.header, prev.1);
				node.node.best_block_updated(&prev.0.header, prev.1);
			},
		}
		call_claimable_balances(node);
	}
}

pub fn disconnect_all_blocks<'a, 'b, 'c, 'd>(node: &'a Node<'b, 'c, 'd>) {
	let count = node.blocks.lock().unwrap().len() as u32 - 1;
	disconnect_blocks(node, count);
}

pub struct TestChanMonCfg {
	pub tx_broadcaster: test_utils::TestBroadcaster,
	pub fee_estimator: test_utils::TestFeeEstimator,
	pub chain_source: test_utils::TestChainSource,
	pub persister: test_utils::TestPersister,
	pub logger: test_utils::TestLogger,
	pub keys_manager: test_utils::TestKeysInterface,
	pub scorer: RwLock<test_utils::TestScorer>,
}

pub struct NodeCfg<'a> {
	pub chain_source: &'a test_utils::TestChainSource,
	pub tx_broadcaster: &'a test_utils::TestBroadcaster,
	pub fee_estimator: &'a test_utils::TestFeeEstimator,
	pub router: test_utils::TestRouter<'a>,
	pub message_router: test_utils::TestMessageRouter<'a>,
	pub chain_monitor: test_utils::TestChainMonitor<'a>,
	pub keys_manager: &'a test_utils::TestKeysInterface,
	pub logger: &'a test_utils::TestLogger,
	pub network_graph: Arc<NetworkGraph<&'a test_utils::TestLogger>>,
	pub node_seed: [u8; 32],
	pub override_init_features: Rc<RefCell<Option<InitFeatures>>>,
}

pub type TestChannelManager<'node_cfg, 'chan_mon_cfg> = ChannelManager<
	&'node_cfg TestChainMonitor<'chan_mon_cfg>,
	&'chan_mon_cfg test_utils::TestBroadcaster,
	&'node_cfg test_utils::TestKeysInterface,
	&'node_cfg test_utils::TestKeysInterface,
	&'node_cfg test_utils::TestKeysInterface,
	&'chan_mon_cfg test_utils::TestFeeEstimator,
	&'node_cfg test_utils::TestRouter<'chan_mon_cfg>,
	&'node_cfg test_utils::TestMessageRouter<'chan_mon_cfg>,
	&'chan_mon_cfg test_utils::TestLogger,
>;

#[cfg(not(feature = "dnssec"))]
type TestOnionMessenger<'chan_man, 'node_cfg, 'chan_mon_cfg> = OnionMessenger<
	DedicatedEntropy,
	&'node_cfg test_utils::TestKeysInterface,
	&'chan_mon_cfg test_utils::TestLogger,
	&'chan_man TestChannelManager<'node_cfg, 'chan_mon_cfg>,
	&'node_cfg test_utils::TestMessageRouter<'chan_mon_cfg>,
	&'chan_man TestChannelManager<'node_cfg, 'chan_mon_cfg>,
	&'chan_man TestChannelManager<'node_cfg, 'chan_mon_cfg>,
	IgnoringMessageHandler,
	IgnoringMessageHandler,
>;

#[cfg(feature = "dnssec")]
type TestOnionMessenger<'chan_man, 'node_cfg, 'chan_mon_cfg> = OnionMessenger<
	DedicatedEntropy,
	&'node_cfg test_utils::TestKeysInterface,
	&'chan_mon_cfg test_utils::TestLogger,
	&'chan_man TestChannelManager<'node_cfg, 'chan_mon_cfg>,
	&'node_cfg test_utils::TestMessageRouter<'chan_mon_cfg>,
	&'chan_man TestChannelManager<'node_cfg, 'chan_mon_cfg>,
	&'chan_man TestChannelManager<'node_cfg, 'chan_mon_cfg>,
	&'chan_man TestChannelManager<'node_cfg, 'chan_mon_cfg>,
	IgnoringMessageHandler,
>;

/// For use with [`OnionMessenger`] otherwise `test_restored_packages_retry` will fail. This is
/// because that test uses older serialized data produced by calling [`EntropySource`] in a specific
/// manner. Using the same [`EntropySource`] with [`OnionMessenger`] would introduce another call,
/// causing the produced data to no longer match.
pub struct DedicatedEntropy(RandomBytes);

impl Deref for DedicatedEntropy {
	type Target = RandomBytes;
	fn deref(&self) -> &Self::Target {
		&self.0
	}
}

pub struct Node<'chan_man, 'node_cfg: 'chan_man, 'chan_mon_cfg: 'node_cfg> {
	pub chain_source: &'chan_mon_cfg test_utils::TestChainSource,
	pub tx_broadcaster: &'chan_mon_cfg test_utils::TestBroadcaster,
	pub fee_estimator: &'chan_mon_cfg test_utils::TestFeeEstimator,
	pub router: &'node_cfg test_utils::TestRouter<'chan_mon_cfg>,
	pub message_router: &'node_cfg test_utils::TestMessageRouter<'chan_mon_cfg>,
	pub chain_monitor: &'node_cfg test_utils::TestChainMonitor<'chan_mon_cfg>,
	pub keys_manager: &'chan_mon_cfg test_utils::TestKeysInterface,
	pub node: &'chan_man TestChannelManager<'node_cfg, 'chan_mon_cfg>,
	pub onion_messenger: TestOnionMessenger<'chan_man, 'node_cfg, 'chan_mon_cfg>,
	pub network_graph: &'node_cfg NetworkGraph<&'chan_mon_cfg test_utils::TestLogger>,
	pub gossip_sync: P2PGossipSync<
		&'node_cfg NetworkGraph<&'chan_mon_cfg test_utils::TestLogger>,
		&'chan_mon_cfg test_utils::TestChainSource,
		&'chan_mon_cfg test_utils::TestLogger,
	>,
	pub node_seed: [u8; 32],
	pub network_payment_count: Rc<RefCell<u8>>,
	pub network_chan_count: Rc<RefCell<u32>>,
	pub logger: &'chan_mon_cfg test_utils::TestLogger,
	pub blocks: Arc<Mutex<Vec<(Block, u32)>>>,
	pub connect_style: Rc<RefCell<ConnectStyle>>,
	pub override_init_features: Rc<RefCell<Option<InitFeatures>>>,
	pub wallet_source: Arc<test_utils::TestWalletSource>,
	pub bump_tx_handler: BumpTransactionEventHandlerSync<
		&'chan_mon_cfg test_utils::TestBroadcaster,
		Arc<WalletSync<Arc<test_utils::TestWalletSource>, &'chan_mon_cfg test_utils::TestLogger>>,
		&'chan_mon_cfg test_utils::TestKeysInterface,
		&'chan_mon_cfg test_utils::TestLogger,
	>,
}

impl<'a, 'b, 'c> Node<'a, 'b, 'c> {
	pub fn init_features(&self, peer_node_id: PublicKey) -> InitFeatures {
		self.override_init_features.borrow().clone().unwrap_or_else(|| {
			self.node.init_features() | self.onion_messenger.provided_init_features(peer_node_id)
		})
	}
}

impl<'a, 'b, 'c> std::panic::UnwindSafe for Node<'a, 'b, 'c> {}
impl<'a, 'b, 'c> std::panic::RefUnwindSafe for Node<'a, 'b, 'c> {}
impl<'a, 'b, 'c> Node<'a, 'b, 'c> {
	pub fn best_block_hash(&self) -> BlockHash {
		self.blocks.lock().unwrap().last().unwrap().0.block_hash()
	}
	pub fn best_block_info(&self) -> (BlockHash, u32) {
		self.blocks.lock().unwrap().last().map(|(a, b)| (a.block_hash(), *b)).unwrap()
	}
	pub fn get_block_header(&self, height: u32) -> Header {
		self.blocks.lock().unwrap()[height as usize].0.header
	}

	/// Executes `enable_channel_signer_op` for every single signer operation for this channel.
	#[cfg(test)]
	pub fn enable_all_channel_signer_ops(&self, peer_id: &PublicKey, chan_id: &ChannelId) {
		for signer_op in SignerOp::all() {
			self.enable_channel_signer_op(peer_id, chan_id, signer_op);
		}
	}

	/// Executes `disable_channel_signer_op` for every single signer operation for this channel.
	#[cfg(test)]
	pub fn disable_all_channel_signer_ops(&self, peer_id: &PublicKey, chan_id: &ChannelId) {
		for signer_op in SignerOp::all() {
			self.disable_channel_signer_op(peer_id, chan_id, signer_op);
		}
	}

	/// Toggles this node's signer to be available for the given signer operation.
	/// This is useful for testing behavior for restoring an async signer that previously
	/// could not return a signature immediately.
	pub fn enable_channel_signer_op(
		&self, peer_id: &PublicKey, chan_id: &ChannelId, signer_op: SignerOp,
	) {
		self.set_channel_signer_ops(peer_id, chan_id, signer_op, true);
	}

	/// Toggles this node's signer to be unavailable, returning `Err` for the given signer operation.
	/// This is useful for testing behavior for an async signer that cannot return a signature
	/// immediately.
	#[cfg(test)]
	pub fn disable_channel_signer_op(
		&self, peer_id: &PublicKey, chan_id: &ChannelId, signer_op: SignerOp,
	) {
		self.set_channel_signer_ops(peer_id, chan_id, signer_op, false);
	}

	/// Changes the channel signer's availability for the specified peer, channel, and signer
	/// operation.
	///
	/// For the specified signer operation, when `available` is set to `true`, the channel signer
	/// will behave normally, returning `Ok`. When set to `false`, and the channel signer will
	/// act like an off-line remote signer, returning `Err`. This applies to the signer in all
	/// relevant places, i.e. the channel manager, chain monitor, and the keys manager.
	fn set_channel_signer_ops(
		&self, peer_id: &PublicKey, chan_id: &ChannelId, signer_op: SignerOp, available: bool,
	) {
		use crate::sign::ChannelSigner;
		log_debug!(
			self.logger,
			"Setting channel signer for {} as available={}",
			chan_id,
			available
		);

		let per_peer_state = self.node.per_peer_state.read().unwrap();
		let mut chan_lock = per_peer_state.get(peer_id).unwrap().lock().unwrap();

		let mut channel_keys_id = None;
		if let Some(context) =
			chan_lock.channel_by_id.get_mut(chan_id).map(|chan| chan.context_mut())
		{
			let signer = context.get_mut_signer().as_mut_ecdsa().unwrap();
			if available {
				signer.enable_op(signer_op);
			} else {
				signer.disable_op(signer_op);
			}
			channel_keys_id = Some(context.channel_keys_id);
		}

		let monitor = self.chain_monitor.chain_monitor.get_monitor(*chan_id).ok();
		if let Some(monitor) = monitor {
			monitor.do_mut_signer_call(|signer| {
				channel_keys_id = channel_keys_id.or(Some(signer.inner.channel_keys_id()));
				if available {
					signer.enable_op(signer_op);
				} else {
					signer.disable_op(signer_op);
				}
			});
		}

		let channel_keys_id = channel_keys_id.unwrap();
		let mut unavailable_signers_ops = self.keys_manager.unavailable_signers_ops.lock().unwrap();
		let entry = unavailable_signers_ops.entry(channel_keys_id).or_insert(new_hash_set());
		if available {
			entry.remove(&signer_op);
			if entry.is_empty() {
				unavailable_signers_ops.remove(&channel_keys_id);
			}
		} else {
			entry.insert(signer_op);
		};
	}

	#[cfg(test)]
	pub fn disable_next_channel_signer_op(&self, signer_op: SignerOp) {
		self.keys_manager.next_signer_disabled_ops.lock().unwrap().insert(signer_op);
	}
}

/// If we need an unsafe pointer to a `Node` (ie to reference it in a thread
/// pre-std::thread::scope), this provides that with `Sync`. Note that accessing some of the fields
/// in the `Node` are not safe to use (i.e. the ones behind an `Rc`), but that's left to the caller
/// to figure out.
pub struct NodePtr(pub *const Node<'static, 'static, 'static>);
impl NodePtr {
	pub fn from_node<'a, 'b: 'a, 'c: 'b>(node: &Node<'a, 'b, 'c>) -> Self {
		Self((node as *const Node<'a, 'b, 'c>).cast())
	}
}
unsafe impl Send for NodePtr {}
unsafe impl Sync for NodePtr {}

pub trait NodeHolder {
	type CM: AChannelManager;
	fn node(
		&self,
	) -> &ChannelManager<
		<Self::CM as AChannelManager>::Watch,
		<Self::CM as AChannelManager>::Broadcaster,
		<Self::CM as AChannelManager>::EntropySource,
		<Self::CM as AChannelManager>::NodeSigner,
		<Self::CM as AChannelManager>::SP,
		<Self::CM as AChannelManager>::FeeEstimator,
		<Self::CM as AChannelManager>::Router,
		<Self::CM as AChannelManager>::MessageRouter,
		<Self::CM as AChannelManager>::Logger,
	>;
	fn chain_monitor(&self) -> Option<&test_utils::TestChainMonitor<'_>>;
}
impl<H: NodeHolder> NodeHolder for &H {
	type CM = H::CM;
	fn node(
		&self,
	) -> &ChannelManager<
		<Self::CM as AChannelManager>::Watch,
		<Self::CM as AChannelManager>::Broadcaster,
		<Self::CM as AChannelManager>::EntropySource,
		<Self::CM as AChannelManager>::NodeSigner,
		<Self::CM as AChannelManager>::SP,
		<Self::CM as AChannelManager>::FeeEstimator,
		<Self::CM as AChannelManager>::Router,
		<Self::CM as AChannelManager>::MessageRouter,
		<Self::CM as AChannelManager>::Logger,
	> {
		(*self).node()
	}
	fn chain_monitor(&self) -> Option<&test_utils::TestChainMonitor<'_>> {
		(*self).chain_monitor()
	}
}
impl<'a, 'b: 'a, 'c: 'b> NodeHolder for Node<'a, 'b, 'c> {
	type CM = TestChannelManager<'b, 'c>;
	fn node(&self) -> &TestChannelManager<'b, 'c> {
		&self.node
	}
	fn chain_monitor(&self) -> Option<&test_utils::TestChainMonitor<'_>> {
		Some(self.chain_monitor)
	}
}

impl<'a, 'b, 'c> Drop for Node<'a, 'b, 'c> {
	fn drop(&mut self) {
		if !std::thread::panicking() {
			// Check that we processed all pending events
			let msg_events = self.node.get_and_clear_pending_msg_events();
			if !msg_events.is_empty() {
				panic!("Had excess message events on node {}: {:?}", self.logger.id, msg_events);
			}
			let events = self.node.get_and_clear_pending_events();
			if !events.is_empty() {
				panic!("Had excess events on node {}: {:?}", self.logger.id, events);
			}
			let added_monitors = self.chain_monitor.added_monitors.lock().unwrap().split_off(0);
			if !added_monitors.is_empty() {
				panic!(
					"Had {} excess added monitors on node {}",
					added_monitors.len(),
					self.logger.id
				);
			}

			let raa_blockers = self.node.get_and_clear_pending_raa_blockers();
			if !raa_blockers.is_empty() {
				panic!("Had excess RAA blockers on node {}: {:?}", self.logger.id, raa_blockers);
			}

			// Check that if we serialize the network graph, we can deserialize it again.
			let network_graph = {
				let mut w = test_utils::TestVecWriter(Vec::new());
				self.network_graph.write(&mut w).unwrap();
				let network_graph_deser =
					<NetworkGraph<_>>::read(&mut io::Cursor::new(&w.0), self.logger).unwrap();
				assert!(network_graph_deser == *self.network_graph);
				let gossip_sync =
					P2PGossipSync::new(&network_graph_deser, Some(self.chain_source), self.logger);
				let mut chan_progress = 0;
				loop {
					let orig_announcements =
						self.gossip_sync.get_next_channel_announcement(chan_progress);
					let deserialized_announcements =
						gossip_sync.get_next_channel_announcement(chan_progress);
					assert!(orig_announcements == deserialized_announcements);
					chan_progress = match orig_announcements {
						Some(announcement) => announcement.0.contents.short_channel_id + 1,
						None => break,
					};
				}
				let mut node_progress = None;
				loop {
					let orig_announcements =
						self.gossip_sync.get_next_node_announcement(node_progress.as_ref());
					let deserialized_announcements =
						gossip_sync.get_next_node_announcement(node_progress.as_ref());
					assert!(orig_announcements == deserialized_announcements);
					node_progress = match orig_announcements {
						Some(announcement) => Some(announcement.contents.node_id),
						None => break,
					};
				}
				Arc::new(network_graph_deser)
			};

			// Check that if we serialize and then deserialize all our channel monitors we get the
			// same set of outputs to watch for on chain as we have now. Note that if we write
			// tests that fully close channels and remove the monitors at some point this may break.
			let feeest = test_utils::TestFeeEstimator::new(253);
			let mut deserialized_monitors = Vec::new();
			{
				for channel_id in self.chain_monitor.chain_monitor.list_monitors() {
					let mut w = test_utils::TestVecWriter(Vec::new());
					let mon = self.chain_monitor.chain_monitor.get_monitor(channel_id).unwrap();
					mon.write(&mut w).unwrap();
					let (_, deserialized_monitor) =
						<(BlockHash, ChannelMonitor<TestChannelSigner>)>::read(
							&mut io::Cursor::new(&w.0),
							(self.keys_manager, self.keys_manager),
						)
						.unwrap();
					deserialized_monitors.push(deserialized_monitor);
				}
			}

			let broadcaster = test_utils::TestBroadcaster {
				txn_broadcasted: Mutex::new(
					self.tx_broadcaster.txn_broadcasted.lock().unwrap().clone(),
				),
				txn_types: Mutex::new(self.tx_broadcaster.txn_types.lock().unwrap().clone()),
				blocks: Arc::new(Mutex::new(self.tx_broadcaster.blocks.lock().unwrap().clone())),
			};

			// Before using all the new monitors to check the watch outpoints, use the full set of
			// them to ensure we can write and reload our ChannelManager.
			{
				let mut channel_monitors = new_hash_map();
				for monitor in deserialized_monitors.iter() {
					channel_monitors.insert(monitor.channel_id(), monitor);
				}

				let scorer = RwLock::new(test_utils::TestScorer::new());
				let mut w = test_utils::TestVecWriter(Vec::new());
				self.node.write(&mut w).unwrap();
				<(
					BlockHash,
					ChannelManager<
						&test_utils::TestChainMonitor,
						&test_utils::TestBroadcaster,
						&test_utils::TestKeysInterface,
						&test_utils::TestKeysInterface,
						&test_utils::TestKeysInterface,
						&test_utils::TestFeeEstimator,
						&test_utils::TestRouter,
						&test_utils::TestMessageRouter,
						&test_utils::TestLogger,
					>,
				)>::read(
					&mut io::Cursor::new(w.0),
					ChannelManagerReadArgs {
						config: self.node.get_current_config(),
						entropy_source: self.keys_manager,
						node_signer: self.keys_manager,
						signer_provider: self.keys_manager,
						fee_estimator: &test_utils::TestFeeEstimator::new(253),
						router: &test_utils::TestRouter::new(
							Arc::clone(&network_graph),
							&self.logger,
							&scorer,
						),
						message_router: &test_utils::TestMessageRouter::new_default(
							network_graph,
							self.keys_manager,
						),
						chain_monitor: self.chain_monitor,
						tx_broadcaster: &broadcaster,
						logger: &self.logger,
						channel_monitors,
					},
				)
				.unwrap();
			}

			let persister = test_utils::TestPersister::new();
			let chain_source = test_utils::TestChainSource::new(Network::Testnet);
			let chain_monitor = test_utils::TestChainMonitor::new(
				Some(&chain_source),
				&broadcaster,
				&self.logger,
				&feeest,
				&persister,
				&self.keys_manager,
			);
			for deserialized_monitor in deserialized_monitors.drain(..) {
				let channel_id = deserialized_monitor.channel_id();
				if chain_monitor.watch_channel(channel_id, deserialized_monitor)
					!= Ok(ChannelMonitorUpdateStatus::Completed)
				{
					panic!();
				}
			}
			assert_eq!(
				*chain_source.watched_txn.unsafe_well_ordered_double_lock_self(),
				*self.chain_source.watched_txn.unsafe_well_ordered_double_lock_self()
			);
			assert_eq!(
				*chain_source.watched_outputs.unsafe_well_ordered_double_lock_self(),
				*self.chain_source.watched_outputs.unsafe_well_ordered_double_lock_self()
			);
		}
	}
}

pub fn create_chan_between_nodes<'a, 'b, 'c: 'd, 'd>(
	node_a: &'a Node<'b, 'c, 'd>, node_b: &'a Node<'b, 'c, 'd>,
) -> (msgs::ChannelAnnouncement, msgs::ChannelUpdate, msgs::ChannelUpdate, ChannelId, Transaction) {
	create_chan_between_nodes_with_value(node_a, node_b, 100000, 10001)
}

pub fn create_chan_between_nodes_with_value<'a, 'b, 'c: 'd, 'd>(
	node_a: &'a Node<'b, 'c, 'd>, node_b: &'a Node<'b, 'c, 'd>, channel_value: u64, push_msat: u64,
) -> (msgs::ChannelAnnouncement, msgs::ChannelUpdate, msgs::ChannelUpdate, ChannelId, Transaction) {
	let (channel_ready, channel_id, tx) =
		create_chan_between_nodes_with_value_a(node_a, node_b, channel_value, push_msat);
	let (announcement, as_update, bs_update) =
		create_chan_between_nodes_with_value_b(node_a, node_b, &channel_ready);
	(announcement, as_update, bs_update, channel_id, tx)
}

/// Gets an RAA and CS which were sent in response to a commitment update
pub fn get_revoke_commit_msgs<CM: AChannelManager, H: NodeHolder<CM = CM>>(
	node: &H, recipient: &PublicKey,
) -> (msgs::RevokeAndACK, Vec<msgs::CommitmentSigned>) {
	let events = node.node().get_and_clear_pending_msg_events();
	assert_eq!(events.len(), 2);
	(
		match events[0] {
			MessageSendEvent::SendRevokeAndACK { ref node_id, ref msg } => {
				assert_eq!(node_id, recipient);
				(*msg).clone()
			},
			_ => panic!("Unexpected event: {events:?}"),
		},
		match events[1] {
			MessageSendEvent::UpdateHTLCs { ref node_id, ref channel_id, ref updates } => {
				assert_eq!(node_id, recipient);
				assert!(updates.update_add_htlcs.is_empty());
				assert!(updates.update_fulfill_htlcs.is_empty());
				assert!(updates.update_fail_htlcs.is_empty());
				assert!(updates.update_fail_malformed_htlcs.is_empty());
				assert!(updates.update_fee.is_none());
				assert!(updates.commitment_signed.iter().all(|cs| cs.channel_id == *channel_id));
				updates.commitment_signed.clone()
			},
			_ => panic!("Unexpected event: {events:?}"),
		},
	)
}

/// Gets a `UpdateHTLCs` and `revoke_and_ack` (i.e. after we get a responding `commitment_signed`
/// while we have updates in the holding cell).
pub fn get_updates_and_revoke<CM: AChannelManager, H: NodeHolder<CM = CM>>(
	node: &H, recipient: &PublicKey,
) -> (msgs::CommitmentUpdate, msgs::RevokeAndACK) {
	let events = node.node().get_and_clear_pending_msg_events();
	assert_eq!(events.len(), 2);
	(
		match events[0] {
			MessageSendEvent::UpdateHTLCs { ref node_id, channel_id: _, ref updates } => {
				assert_eq!(node_id, recipient);
				(*updates).clone()
			},
			_ => panic!("Unexpected event"),
		},
		match events[1] {
			MessageSendEvent::SendRevokeAndACK { ref node_id, ref msg } => {
				assert_eq!(node_id, recipient);
				(*msg).clone()
			},
			_ => panic!("Unexpected event"),
		},
	)
}

/// Get an specific event message from the pending events queue.
#[macro_export]
macro_rules! get_event_msg {
	($node: expr, $event_type: path, $node_id: expr) => {{
		let events = $node.node.get_and_clear_pending_msg_events();
		assert_eq!(events.len(), 1);
		match events[0] {
			$event_type { ref node_id, ref msg } => {
				assert_eq!(*node_id, $node_id);
				(*msg).clone()
			},
			_ => panic!("Unexpected event {:?}", events[0]),
		}
	}};
}

/// Get an error message from the pending events queue.
pub fn get_err_msg(node: &Node, recipient: &PublicKey) -> msgs::ErrorMessage {
	let events = node.node.get_and_clear_pending_msg_events();
	assert_eq!(events.len(), 1);
	match events[0] {
		MessageSendEvent::HandleError {
			action: msgs::ErrorAction::SendErrorMessage { ref msg },
			ref node_id,
		} => {
			assert_eq!(node_id, recipient);
			(*msg).clone()
		},
		MessageSendEvent::HandleError {
			action: msgs::ErrorAction::DisconnectPeer { ref msg },
			ref node_id,
		} => {
			assert_eq!(node_id, recipient);
			msg.as_ref().unwrap().clone()
		},
		_ => panic!("Unexpected event"),
	}
}

/// Get a warning message from the pending events queue.
pub fn get_warning_msg(node: &Node, recipient: &PublicKey) -> msgs::WarningMessage {
	let events = node.node.get_and_clear_pending_msg_events();
	assert_eq!(events.len(), 1);
	match events[0] {
		MessageSendEvent::HandleError {
			action: msgs::ErrorAction::DisconnectPeerWithWarning { ref msg },
			ref node_id,
		} => {
			assert_eq!(node_id, recipient);
			(*msg).clone()
		},
		MessageSendEvent::HandleError {
			action: msgs::ErrorAction::SendWarningMessage { ref msg, .. },
			ref node_id,
		} => {
			assert_eq!(node_id, recipient);
			msg.clone()
		},
		_ => panic!("Unexpected event"),
	}
}

/// Get a specific event from the pending events queue.
#[macro_export]
macro_rules! get_event {
	($node: expr, $event_type: path) => {{
		let mut events = $node.node.get_and_clear_pending_events();
		assert_eq!(events.len(), 1);
		let ev = events.pop().unwrap();
		match ev {
			$event_type { .. } => ev,
			_ => panic!("Unexpected event {ev:?}"),
		}
	}};
}

/// Gets an UpdateHTLCs MessageSendEvent
pub fn get_htlc_update_msgs(node: &Node, recipient: &PublicKey) -> msgs::CommitmentUpdate {
	let events = node.node.get_and_clear_pending_msg_events();
	assert_eq!(events.len(), 1);
	match events[0] {
		MessageSendEvent::UpdateHTLCs { ref node_id, channel_id: _, ref updates } => {
			assert_eq!(node_id, recipient);
			(*updates).clone()
		},
		_ => panic!("Unexpected event {events:?}"),
	}
}

/// Fetches the first `msg_event` to the passed `node_id` in the passed `msg_events` vec.
/// Returns the `msg_event`.
///
/// Note that even though `BroadcastChannelAnnouncement` and `BroadcastChannelUpdate`
/// `msg_events` are stored under specific peers, this function does not fetch such `msg_events` as
/// such messages are intended to all peers.
pub fn remove_first_msg_event_to_node(
	msg_node_id: &PublicKey, msg_events: &mut Vec<MessageSendEvent>,
) -> MessageSendEvent {
	let ev_index = msg_events.iter().position(|e| match e {
		MessageSendEvent::SendPeerStorage { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendPeerStorageRetrieval { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendAcceptChannel { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendOpenChannel { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendFundingCreated { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendFundingSigned { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendChannelReady { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendAnnouncementSignatures { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::UpdateHTLCs { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendRevokeAndACK { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendClosingSigned { node_id, .. } => node_id == msg_node_id,
		#[cfg(simple_close)]
		MessageSendEvent::SendClosingComplete { node_id, .. } => node_id == msg_node_id,
		#[cfg(simple_close)]
		MessageSendEvent::SendClosingSig { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendShutdown { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendChannelReestablish { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendChannelAnnouncement { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::BroadcastChannelAnnouncement { .. } => false,
		MessageSendEvent::BroadcastChannelUpdate { .. } => false,
		MessageSendEvent::BroadcastNodeAnnouncement { .. } => false,
		MessageSendEvent::SendChannelUpdate { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::HandleError { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendChannelRangeQuery { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendShortIdsQuery { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendReplyChannelRange { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendGossipTimestampFilter { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendAcceptChannelV2 { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendOpenChannelV2 { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendStfu { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendSpliceInit { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendSpliceAck { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendSpliceLocked { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendTxAddInput { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendTxAddOutput { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendTxRemoveInput { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendTxRemoveOutput { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendTxComplete { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendTxSignatures { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendTxInitRbf { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendTxAckRbf { node_id, .. } => node_id == msg_node_id,
		MessageSendEvent::SendTxAbort { node_id, .. } => node_id == msg_node_id,
	});
	if ev_index.is_some() {
		msg_events.remove(ev_index.unwrap())
	} else {
		panic!("Couldn't find any MessageSendEvent to the node!")
	}
}

#[cfg(any(test, feature = "_externalize_tests"))]
macro_rules! get_channel_ref {
	($node: expr, $counterparty_node: expr, $per_peer_state_lock: ident, $peer_state_lock: ident, $channel_id: expr) => {{
		$per_peer_state_lock = $node.node.per_peer_state.read().unwrap();
		$peer_state_lock = $per_peer_state_lock
			.get(&$counterparty_node.node.get_our_node_id())
			.unwrap()
			.lock()
			.unwrap();
		$peer_state_lock.channel_by_id.get_mut(&$channel_id).unwrap()
	}};
}

#[cfg(any(test, feature = "_externalize_tests"))]
macro_rules! get_feerate {
	($node: expr, $counterparty_node: expr, $channel_id: expr) => {{
		let mut per_peer_state_lock;
		let mut peer_state_lock;
		let chan = get_channel_ref!(
			$node,
			$counterparty_node,
			per_peer_state_lock,
			peer_state_lock,
			$channel_id
		);
		chan.context().get_feerate_sat_per_1000_weight()
	}};
}

#[cfg(any(test, feature = "_externalize_tests"))]
macro_rules! get_channel_type_features {
	($node: expr, $counterparty_node: expr, $channel_id: expr) => {{
		let mut per_peer_state_lock;
		let mut peer_state_lock;
		let chan = get_channel_ref!(
			$node,
			$counterparty_node,
			per_peer_state_lock,
			peer_state_lock,
			$channel_id
		);
		chan.funding().get_channel_type().clone()
	}};
}

/// Returns a channel monitor given a channel id, making some naive assumptions
#[macro_export]
macro_rules! get_monitor {
	($node: expr, $channel_id: expr) => {{
		$node.chain_monitor.chain_monitor.get_monitor($channel_id).unwrap()
	}};
}

/// Returns any local commitment transactions for the channel.
#[macro_export]
macro_rules! get_local_commitment_txn {
	($node: expr, $channel_id: expr) => {{
		$crate::get_monitor!($node, $channel_id)
			.unsafe_get_latest_holder_commitment_txn(&$node.logger)
	}};
}

/// Check the error from attempting a payment.
#[macro_export]
macro_rules! unwrap_send_err {
	($node: expr, $res: expr, $all_failed: expr, $type: pat, $check: expr) => {
		assert!($res.is_ok());
		let events = $node.node.get_and_clear_pending_events();
		assert!(events.len() == 2);
		match &events[0] {
			$crate::events::Event::PaymentPathFailed { failure, .. } => match failure {
				$crate::events::PathFailure::InitialSend { err } => match err {
					$type => $check,
					_ => panic!(),
				},
				_ => panic!(),
			},
			_ => panic!(),
		}
		match &events[1] {
			$crate::events::Event::PaymentFailed { .. } => {},
			_ => panic!(),
		}
	};
}

pub fn commit_tx_fee_msat(
	feerate: u32, num_htlcs: u64, channel_type_features: &ChannelTypeFeatures,
) -> u64 {
	(commitment_tx_base_weight(channel_type_features) + num_htlcs * COMMITMENT_TX_WEIGHT_PER_HTLC)
		* feerate as u64
		/ 1000 * 1000
}

/// Check whether N channel monitor(s) have been added.
pub fn check_added_monitors<CM: AChannelManager, H: NodeHolder<CM = CM>>(node: &H, count: usize) {
	if let Some(chain_monitor) = node.chain_monitor() {
		let mut added_monitors = chain_monitor.added_monitors.lock().unwrap();
		let n = added_monitors.len();
		assert_eq!(n, count, "expected {} monitors to be added, not {}", count, n);
		added_monitors.clear();
	}
}

fn claimed_htlc_matches_path<'a, 'b, 'c>(
	origin_node: &Node<'a, 'b, 'c>, path: &[&Node<'a, 'b, 'c>], htlc: &ClaimedHTLC,
) -> bool {
	let mut nodes = path.iter().rev();
	let dest = nodes.next().expect("path should have a destination").node;
	let prev = nodes.next().unwrap_or(&origin_node).node;
	let dest_channels = dest.list_channels();
	let ch = dest_channels
		.iter()
		.find(|ch| ch.channel_id == htlc.channel_id)
		.expect("HTLC's channel should be one of destination node's channels");
	htlc.user_channel_id == ch.user_channel_id && ch.counterparty.node_id == prev.get_our_node_id()
}

fn check_claimed_htlcs_match_route<'a, 'b, 'c>(
	origin_node: &Node<'a, 'b, 'c>, route: &[&[&Node<'a, 'b, 'c>]], htlcs: &[ClaimedHTLC],
) {
	assert_eq!(route.len(), htlcs.len());
	for path in route {
		let mut found_matching_htlc = false;
		for htlc in htlcs {
			if claimed_htlc_matches_path(origin_node, path, htlc) {
				found_matching_htlc = true;
				break;
			}
		}
		assert!(found_matching_htlc);
	}
}

pub fn _reload_node<'a, 'b, 'c>(
	node: &'a Node<'a, 'b, 'c>, config: UserConfig, chanman_encoded: &[u8],
	monitors_encoded: &[&[u8]],
) -> TestChannelManager<'b, 'c> {
	let mut monitors_read = Vec::with_capacity(monitors_encoded.len());
	for encoded in monitors_encoded {
		let mut monitor_read = &encoded[..];
		let (_, monitor) = <(BlockHash, ChannelMonitor<TestChannelSigner>)>::read(
			&mut monitor_read,
			(node.keys_manager, node.keys_manager),
		)
		.unwrap();
		assert!(monitor_read.is_empty());
		monitors_read.push(monitor);
	}

	let mut node_read = &chanman_encoded[..];
	let (_, node_deserialized) = {
		let mut channel_monitors = new_hash_map();
		for monitor in monitors_read.iter() {
			assert!(channel_monitors.insert(monitor.channel_id(), monitor).is_none());
		}
		<(BlockHash, TestChannelManager<'b, 'c>)>::read(
			&mut node_read,
			ChannelManagerReadArgs {
				config,
				entropy_source: node.keys_manager,
				node_signer: node.keys_manager,
				signer_provider: node.keys_manager,
				fee_estimator: node.fee_estimator,
				router: node.router,
				message_router: node.message_router,
				chain_monitor: node.chain_monitor,
				tx_broadcaster: node.tx_broadcaster,
				logger: node.logger,
				channel_monitors,
			},
		)
		.unwrap()
	};
	assert!(node_read.is_empty());

	for monitor in monitors_read.drain(..) {
		let channel_id = monitor.channel_id();
		assert_eq!(
			node.chain_monitor.load_existing_monitor(channel_id, monitor),
			Ok(ChannelMonitorUpdateStatus::Completed),
		);
		check_added_monitors(&node, 1);
	}

	node_deserialized
}

#[macro_export]
macro_rules! reload_node {
	($node: expr, $new_config: expr, $chanman_encoded: expr, $monitors_encoded: expr, $persister: ident, $new_chain_monitor: ident, $new_channelmanager: ident) => {
		let chanman_encoded = $chanman_encoded;

		$persister = $crate::util::test_utils::TestPersister::new();
		$new_chain_monitor = $crate::util::test_utils::TestChainMonitor::new(
			Some($node.chain_source),
			$node.tx_broadcaster.clone(),
			$node.logger,
			$node.fee_estimator,
			&$persister,
			&$node.keys_manager,
		);
		$node.chain_monitor = &$new_chain_monitor;

		$new_channelmanager =
			_reload_node(&$node, $new_config, &chanman_encoded, $monitors_encoded);
		$node.node = &$new_channelmanager;
		$node.onion_messenger.set_offers_handler(&$new_channelmanager);
		$node.onion_messenger.set_async_payments_handler(&$new_channelmanager);
	};
	($node: expr, $chanman_encoded: expr, $monitors_encoded: expr, $persister: ident, $new_chain_monitor: ident, $new_channelmanager: ident) => {
		let config = $node.node.get_current_config();
		reload_node!(
			$node,
			config,
			$chanman_encoded,
			$monitors_encoded,
			$persister,
			$new_chain_monitor,
			$new_channelmanager
		);
	};
}

pub fn create_funding_transaction<'a, 'b, 'c>(
	node: &Node<'a, 'b, 'c>, expected_counterparty_node_id: &PublicKey, expected_chan_value: u64,
	expected_user_chan_id: u128,
) -> (ChannelId, Transaction, OutPoint) {
	internal_create_funding_transaction(
		node,
		expected_counterparty_node_id,
		expected_chan_value,
		expected_user_chan_id,
		false,
	)
}

pub fn create_coinbase_funding_transaction<'a, 'b, 'c>(
	node: &Node<'a, 'b, 'c>, expected_counterparty_node_id: &PublicKey, expected_chan_value: u64,
	expected_user_chan_id: u128,
) -> (ChannelId, Transaction, OutPoint) {
	internal_create_funding_transaction(
		node,
		expected_counterparty_node_id,
		expected_chan_value,
		expected_user_chan_id,
		true,
	)
}

fn internal_create_funding_transaction<'a, 'b, 'c>(
	node: &Node<'a, 'b, 'c>, expected_counterparty_node_id: &PublicKey, expected_chan_value: u64,
	expected_user_chan_id: u128, coinbase: bool,
) -> (ChannelId, Transaction, OutPoint) {
	let chan_id = *node.network_chan_count.borrow();

	let events = node.node.get_and_clear_pending_events();
	assert_eq!(events.len(), 1);
	match events[0] {
		Event::FundingGenerationReady {
			ref temporary_channel_id,
			ref counterparty_node_id,
			ref channel_value_satoshis,
			ref output_script,
			user_channel_id,
		} => {
			assert_eq!(counterparty_node_id, expected_counterparty_node_id);
			assert_eq!(*channel_value_satoshis, expected_chan_value);
			assert_eq!(user_channel_id, expected_user_chan_id);

			let input = if coinbase {
				vec![TxIn { previous_output: bitcoin::OutPoint::null(), ..Default::default() }]
			} else {
				Vec::new()
			};

			let tx = Transaction {
				version: transaction::Version(chan_id as i32),
				lock_time: LockTime::ZERO,
				input,
				output: vec![TxOut {
					value: Amount::from_sat(*channel_value_satoshis),
					script_pubkey: output_script.clone(),
				}],
			};
			let funding_outpoint = OutPoint { txid: tx.compute_txid(), index: 0 };
			(*temporary_channel_id, tx, funding_outpoint)
		},
		_ => panic!("Unexpected event"),
	}
}

/// Create test inputs for a funding transaction.
/// Return the inputs (with prev tx), and the total witness weight for these inputs
pub fn create_dual_funding_utxos_with_prev_txs(
	node: &Node<'_, '_, '_>, utxo_values_in_satoshis: &[u64],
) -> Vec<FundingTxInput> {
	// Ensure we have unique transactions per node by using the locktime.
	let tx = Transaction {
		version: TxVersion::TWO,
		lock_time: LockTime::from_height(
			u32::from_be_bytes(
				node.keys_manager.get_secure_random_bytes()[0..4].try_into().unwrap(),
			) % LOCK_TIME_THRESHOLD,
		)
		.unwrap(),
		input: vec![],
		output: utxo_values_in_satoshis
			.iter()
			.map(|value_satoshis| TxOut {
				value: Amount::from_sat(*value_satoshis),
				script_pubkey: ScriptBuf::new_p2wpkh(&WPubkeyHash::all_zeros()),
			})
			.collect(),
	};

	tx.output
		.iter()
		.enumerate()
		.map(|(index, _)| index as u32)
		.map(|vout| FundingTxInput::new_p2wpkh(tx.clone(), vout).unwrap())
		.collect()
}

pub fn sign_funding_transaction<'a, 'b, 'c>(
	node_a: &Node<'a, 'b, 'c>, node_b: &Node<'a, 'b, 'c>, channel_value: u64,
	expected_temporary_channel_id: ChannelId,
) -> Transaction {
	let node_b_id = node_b.node.get_our_node_id();
	let node_a_id = node_a.node.get_our_node_id();

	let (temporary_channel_id, tx, _) =
		create_funding_transaction(node_a, &node_b_id, channel_value, 42);
	assert_eq!(temporary_channel_id, expected_temporary_channel_id);

	assert!(node_a
		.node
		.funding_transaction_generated(temporary_channel_id, node_b_id, tx.clone())
		.is_ok());
	check_added_monitors(&node_a, 0);

	let funding_created_msg =
		get_event_msg!(node_a, MessageSendEvent::SendFundingCreated, node_b_id);
	assert_eq!(funding_created_msg.temporary_channel_id, expected_temporary_channel_id);

	let channel_id = ChannelId::v1_from_funding_txid(
		funding_created_msg.funding_txid.as_byte_array(),
		funding_created_msg.funding_output_index,
	);

	node_b.node.handle_funding_created(node_a_id, &funding_created_msg);
	{
		let mut added_monitors = node_b.chain_monitor.added_monitors.lock().unwrap();
		assert_eq!(added_monitors.len(), 1);
		assert_eq!(added_monitors[0].0, channel_id);
		added_monitors.clear();
	}
	expect_channel_pending_event(&node_b, &node_a_id);

	let bs_funding_signed = get_event_msg!(node_b, MessageSendEvent::SendFundingSigned, node_a_id);
	node_a.node.handle_funding_signed(node_b_id, &bs_funding_signed);
	{
		let mut added_monitors = node_a.chain_monitor.added_monitors.lock().unwrap();
		assert_eq!(added_monitors.len(), 1);
		assert_eq!(added_monitors[0].0, channel_id);
		added_monitors.clear();
	}
	expect_channel_pending_event(&node_a, &node_b_id);

	let events_4 = node_a.node.get_and_clear_pending_events();
	assert_eq!(events_4.len(), 0);

	assert_eq!(node_a.tx_broadcaster.txn_broadcasted.lock().unwrap().len(), 1);
	assert_eq!(node_a.tx_broadcaster.txn_broadcasted.lock().unwrap()[0], tx);
	node_a.tx_broadcaster.clear();

	// Ensure that funding_transaction_generated is idempotent.
	assert!(node_a
		.node
		.funding_transaction_generated(temporary_channel_id, node_b_id, tx.clone())
		.is_err());
	assert!(node_a.node.get_and_clear_pending_msg_events().is_empty());
	check_added_monitors(&node_a, 0);

	tx
}

pub fn open_zero_conf_channel<'a, 'b, 'c, 'd>(
	initiator: &'a Node<'b, 'c, 'd>, receiver: &'a Node<'b, 'c, 'd>,
	initiator_config: Option<UserConfig>,
) -> (bitcoin::Transaction, ChannelId) {
	open_zero_conf_channel_with_value(initiator, receiver, initiator_config, 100_000, 10_001)
}

pub fn exchange_open_accept_zero_conf_chan<'a, 'b, 'c, 'd>(
	initiator: &'a Node<'b, 'c, 'd>, receiver: &'a Node<'b, 'c, 'd>,
	initiator_config: Option<UserConfig>, channel_value_sat: u64, push_msat: u64,
) -> ChannelId {
	let receiver_node_id = receiver.node.get_our_node_id();
	let initiator_node_id = initiator.node.get_our_node_id();

	initiator
		.node
		.create_channel(receiver_node_id, channel_value_sat, push_msat, 42, None, initiator_config)
		.unwrap();
	let open_channel =
		get_event_msg!(initiator, MessageSendEvent::SendOpenChannel, receiver_node_id);

	receiver.node.handle_open_channel(initiator_node_id, &open_channel);
	let events = receiver.node.get_and_clear_pending_events();
	assert_eq!(events.len(), 1);
	match events[0] {
		Event::OpenChannelRequest { temporary_channel_id, .. } => {
			receiver
				.node
				.accept_inbound_channel_from_trusted_peer_0conf(
					&temporary_channel_id,
					&initiator_node_id,
					0,
					None,
				)
				.unwrap();
		},
		_ => panic!("Unexpected event"),
	};

	let accept_channel =
		get_event_msg!(receiver, MessageSendEvent::SendAcceptChannel, initiator_node_id);
	assert_eq!(accept_channel.common_fields.minimum_depth, 0);
	initiator.node.handle_accept_channel(receiver_node_id, &accept_channel);

	accept_channel.common_fields.temporary_channel_id
}

pub fn open_zero_conf_channel_with_value<'a, 'b, 'c, 'd>(
	initiator: &'a Node<'b, 'c, 'd>, receiver: &'a Node<'b, 'c, 'd>,
	initiator_config: Option<UserConfig>, channel_value_sat: u64, push_msat: u64,
) -> (bitcoin::Transaction, ChannelId) {
	let initiator_channels = initiator.node.list_usable_channels().len();
	let receiver_channels = receiver.node.list_usable_channels().len();

	let receiver_node_id = receiver.node.get_our_node_id();
	let initiator_node_id = initiator.node.get_our_node_id();

	exchange_open_accept_zero_conf_chan(
		initiator,
		receiver,
		initiator_config,
		channel_value_sat,
		push_msat,
	);

	let (temporary_channel_id, tx, _) =
		create_funding_transaction(&initiator, &receiver_node_id, channel_value_sat, 42);
	initiator
		.node
		.funding_transaction_generated(temporary_channel_id, receiver_node_id, tx.clone())
		.unwrap();
	let funding_created =
		get_event_msg!(initiator, MessageSendEvent::SendFundingCreated, receiver_node_id);

	receiver.node.handle_funding_created(initiator_node_id, &funding_created);
	check_added_monitors(&receiver, 1);
	let bs_signed_locked = receiver.node.get_and_clear_pending_msg_events();
	assert_eq!(bs_signed_locked.len(), 2);
	let as_channel_ready;
	match &bs_signed_locked[0] {
		MessageSendEvent::SendFundingSigned { node_id, msg } => {
			assert_eq!(*node_id, initiator_node_id);
			initiator.node.handle_funding_signed(receiver_node_id, &msg);
			expect_channel_pending_event(&initiator, &receiver_node_id);
			expect_channel_pending_event(&receiver, &initiator_node_id);
			check_added_monitors(&initiator, 1);

			assert_eq!(initiator.tx_broadcaster.txn_broadcasted.lock().unwrap().len(), 1);
			assert_eq!(initiator.tx_broadcaster.txn_broadcasted.lock().unwrap()[0], tx);
			initiator.tx_broadcaster.clear();

			as_channel_ready =
				get_event_msg!(initiator, MessageSendEvent::SendChannelReady, receiver_node_id);
		},
		_ => panic!("Unexpected event"),
	}
	match &bs_signed_locked[1] {
		MessageSendEvent::SendChannelReady { node_id, msg } => {
			assert_eq!(*node_id, initiator_node_id);
			initiator.node.handle_channel_ready(receiver_node_id, &msg);
			expect_channel_ready_event(&initiator, &receiver_node_id);
		},
		_ => panic!("Unexpected event"),
	}

	receiver.node.handle_channel_ready(initiator_node_id, &as_channel_ready);
	expect_channel_ready_event(&receiver, &initiator_node_id);

	let as_channel_update =
		get_event_msg!(initiator, MessageSendEvent::SendChannelUpdate, receiver_node_id);
	let bs_channel_update =
		get_event_msg!(receiver, MessageSendEvent::SendChannelUpdate, initiator_node_id);

	initiator.node.handle_channel_update(receiver_node_id, &bs_channel_update);
	receiver.node.handle_channel_update(initiator_node_id, &as_channel_update);

	assert_eq!(initiator.node.list_usable_channels().len(), initiator_channels + 1);
	assert_eq!(receiver.node.list_usable_channels().len(), receiver_channels + 1);

	(tx, as_channel_ready.channel_id)
}

pub fn exchange_open_accept_chan<'a, 'b, 'c>(
	node_a: &Node<'a, 'b, 'c>, node_b: &Node<'a, 'b, 'c>, channel_value: u64, push_msat: u64,
) -> ChannelId {
	let node_a_id = node_a.node.get_our_node_id();
	let node_b_id = node_b.node.get_our_node_id();

	let create_chan_id =
		node_a.node.create_channel(node_b_id, channel_value, push_msat, 42, None, None).unwrap();
	let open_channel_msg = get_event_msg!(node_a, MessageSendEvent::SendOpenChannel, node_b_id);
	assert_eq!(open_channel_msg.common_fields.temporary_channel_id, create_chan_id);
	assert_eq!(
		node_a
			.node
			.list_channels()
			.iter()
			.find(|channel| channel.channel_id == create_chan_id)
			.unwrap()
			.user_channel_id,
		42
	);
	handle_and_accept_open_channel(&node_b, node_a_id, &open_channel_msg);

	let accept_channel_msg = get_event_msg!(node_b, MessageSendEvent::SendAcceptChannel, node_a_id);
	assert_eq!(accept_channel_msg.common_fields.temporary_channel_id, create_chan_id);
	node_a.node.handle_accept_channel(node_b_id, &accept_channel_msg);
	assert_ne!(
		node_b
			.node
			.list_channels()
			.iter()
			.find(|channel| channel.channel_id == create_chan_id)
			.unwrap()
			.user_channel_id,
		0
	);

	create_chan_id
}

pub fn create_chan_between_nodes_with_value_init<'a, 'b, 'c>(
	node_a: &Node<'a, 'b, 'c>, node_b: &Node<'a, 'b, 'c>, channel_value: u64, push_msat: u64,
) -> Transaction {
	let create_chan_id = exchange_open_accept_chan(node_a, node_b, channel_value, push_msat);
	sign_funding_transaction(node_a, node_b, channel_value, create_chan_id)
}

pub fn create_chan_between_nodes_with_value_confirm_first<'a, 'b, 'c, 'd>(
	node_recv: &'a Node<'b, 'c, 'c>, node_conf: &'a Node<'b, 'c, 'd>, tx: &Transaction,
	conf_height: u32,
) {
	confirm_transaction_at(node_conf, tx, conf_height);
	connect_blocks(node_conf, CHAN_CONFIRM_DEPTH - 1);
	let channel_ready = get_event_msg!(
		node_conf,
		MessageSendEvent::SendChannelReady,
		node_recv.node.get_our_node_id()
	);
	node_recv.node.handle_channel_ready(node_conf.node.get_our_node_id(), &channel_ready);
}

pub fn create_chan_between_nodes_with_value_confirm_second<'a, 'b, 'c>(
	node_recv: &Node<'a, 'b, 'c>, node_conf: &Node<'a, 'b, 'c>,
) -> ((msgs::ChannelReady, msgs::AnnouncementSignatures), ChannelId) {
	let channel_id;
	let events_6 = node_conf.node.get_and_clear_pending_msg_events();
	assert_eq!(events_6.len(), 3);
	let announcement_sigs_idx =
		if let MessageSendEvent::SendChannelUpdate { ref node_id, msg: _ } = events_6[1] {
			assert_eq!(*node_id, node_recv.node.get_our_node_id());
			2
		} else if let MessageSendEvent::SendChannelUpdate { ref node_id, msg: _ } = events_6[2] {
			assert_eq!(*node_id, node_recv.node.get_our_node_id());
			1
		} else {
			panic!("Unexpected event: {:?}", events_6[1]);
		};
	(
		(
			match events_6[0] {
				MessageSendEvent::SendChannelReady { ref node_id, ref msg } => {
					channel_id = msg.channel_id.clone();
					assert_eq!(*node_id, node_recv.node.get_our_node_id());
					msg.clone()
				},
				_ => panic!("Unexpected event"),
			},
			match events_6[announcement_sigs_idx] {
				MessageSendEvent::SendAnnouncementSignatures { ref node_id, ref msg } => {
					assert_eq!(*node_id, node_recv.node.get_our_node_id());
					msg.clone()
				},
				_ => panic!("Unexpected event"),
			},
		),
		channel_id,
	)
}

pub fn create_chan_between_nodes_with_value_confirm<'a, 'b, 'c: 'd, 'd>(
	node_a: &'a Node<'b, 'c, 'd>, node_b: &'a Node<'b, 'c, 'd>, tx: &Transaction,
) -> ((msgs::ChannelReady, msgs::AnnouncementSignatures), ChannelId) {
	let conf_height =
		core::cmp::max(node_a.best_block_info().1 + 1, node_b.best_block_info().1 + 1);
	create_chan_between_nodes_with_value_confirm_first(node_a, node_b, tx, conf_height);
	confirm_transaction_at(node_a, tx, conf_height);
	connect_blocks(node_a, CHAN_CONFIRM_DEPTH - 1);
	expect_channel_ready_event(&node_a, &node_b.node.get_our_node_id());
	create_chan_between_nodes_with_value_confirm_second(node_b, node_a)
}

pub fn create_chan_between_nodes_with_value_a<'a, 'b, 'c: 'd, 'd>(
	node_a: &'a Node<'b, 'c, 'd>, node_b: &'a Node<'b, 'c, 'd>, channel_value: u64, push_msat: u64,
) -> ((msgs::ChannelReady, msgs::AnnouncementSignatures), ChannelId, Transaction) {
	let tx = create_chan_between_nodes_with_value_init(node_a, node_b, channel_value, push_msat);
	let (msgs, chan_id) = create_chan_between_nodes_with_value_confirm(node_a, node_b, &tx);
	(msgs, chan_id, tx)
}

pub fn create_channel_manual_funding<'a, 'b, 'c: 'd, 'd>(
	nodes: &'a Vec<Node<'b, 'c, 'd>>, initiator: usize, counterparty: usize, channel_value: u64,
	push_msat: u64, zero_conf: bool,
) -> (ChannelId, Transaction, OutPoint) {
	let node_a = &nodes[initiator];
	let node_b = &nodes[counterparty];
	let node_a_id = node_a.node.get_our_node_id();
	let node_b_id = node_b.node.get_our_node_id();

	let temp_channel_id = if zero_conf {
		exchange_open_accept_zero_conf_chan(node_a, node_b, None, channel_value, push_msat)
	} else {
		exchange_open_accept_chan(node_a, node_b, channel_value, push_msat)
	};

	let (funding_temp_id, funding_tx, funding_outpoint) =
		create_funding_transaction(node_a, &node_b_id, channel_value, 42);
	assert_eq!(temp_channel_id, funding_temp_id);

	node_a
		.node
		.funding_transaction_generated_manual_broadcast(
			funding_temp_id,
			node_b_id,
			funding_tx.clone(),
		)
		.unwrap();
	check_added_monitors(&node_a, 0);

	let funding_created = get_event_msg!(node_a, MessageSendEvent::SendFundingCreated, node_b_id);
	node_b.node.handle_funding_created(node_a_id, &funding_created);
	check_added_monitors(&node_b, 1);
	let channel_id_b = expect_channel_pending_event(node_b, &node_a_id);

	if zero_conf {
		let bs_signed_locked = node_b.node.get_and_clear_pending_msg_events();
		assert_eq!(bs_signed_locked.len(), 2);
		match &bs_signed_locked[0] {
			MessageSendEvent::SendFundingSigned { node_id, msg } => {
				assert_eq!(*node_id, node_a_id);
				node_a.node.handle_funding_signed(node_b_id, &msg);
				check_added_monitors(node_a, 1);

				assert!(node_a.tx_broadcaster.txn_broadcast().is_empty());

				let as_channel_ready =
					get_event_msg!(node_a, MessageSendEvent::SendChannelReady, node_b_id);
				node_b.node.handle_channel_ready(node_a_id, &as_channel_ready);
				expect_channel_ready_event(node_b, &node_a_id);
			},
			_ => panic!("Unexpected event"),
		}
		match &bs_signed_locked[1] {
			MessageSendEvent::SendChannelReady { node_id, msg } => {
				assert_eq!(*node_id, node_a_id);
				node_a.node.handle_channel_ready(node_b_id, &msg);
			},
			_ => panic!("Unexpected event"),
		}
	} else {
		let funding_signed = get_event_msg!(node_b, MessageSendEvent::SendFundingSigned, node_a_id);
		node_a.node.handle_funding_signed(node_b_id, &funding_signed);
		check_added_monitors(node_a, 1)
	}

	let events = node_a.node.get_and_clear_pending_events();
	assert_eq!(events.len(), if zero_conf { 3 } else { 2 });
	let funding_txid = funding_tx.compute_txid();
	let mut channel_id = None;
	for event in events {
		match event {
			Event::FundingTxBroadcastSafe { funding_txo, counterparty_node_id, .. } => {
				assert_eq!(counterparty_node_id, node_b_id);
				assert_eq!(funding_txo.txid, funding_txid);
				assert_eq!(funding_txo.vout, u32::from(funding_outpoint.index));
			},
			Event::ChannelPending { channel_id: pending_id, counterparty_node_id, .. } => {
				assert_eq!(counterparty_node_id, node_b_id);
				channel_id = Some(pending_id);
			},
			Event::ChannelReady { channel_id: pending_id, counterparty_node_id, .. } => {
				assert_eq!(counterparty_node_id, node_b_id);
				channel_id = Some(pending_id);
			},
			_ => panic!("Unexpected event"),
		}
	}
	let channel_id = channel_id.expect("channel pending event missing");
	assert_eq!(channel_id, channel_id_b);

	assert!(node_a.tx_broadcaster.txn_broadcasted.lock().unwrap().is_empty());

	if zero_conf {
		let as_channel_update =
			get_event_msg!(node_a, MessageSendEvent::SendChannelUpdate, node_b_id);
		let bs_channel_update =
			get_event_msg!(node_b, MessageSendEvent::SendChannelUpdate, node_a_id);

		node_a.node.handle_channel_update(node_b_id, &bs_channel_update);
		node_b.node.handle_channel_update(node_a_id, &as_channel_update);
	}

	(channel_id, funding_tx, funding_outpoint)
}

pub fn create_chan_between_nodes_with_value_b<'a, 'b, 'c>(
	node_a: &Node<'a, 'b, 'c>, node_b: &Node<'a, 'b, 'c>,
	as_funding_msgs: &(msgs::ChannelReady, msgs::AnnouncementSignatures),
) -> (msgs::ChannelAnnouncement, msgs::ChannelUpdate, msgs::ChannelUpdate) {
	let node_a_id = node_a.node.get_our_node_id();
	let node_b_id = node_b.node.get_our_node_id();

	node_b.node.handle_channel_ready(node_a_id, &as_funding_msgs.0);
	let bs_announcement_sigs =
		get_event_msg!(node_b, MessageSendEvent::SendAnnouncementSignatures, node_a_id);
	node_b.node.handle_announcement_signatures(node_a_id, &as_funding_msgs.1);

	let events_7 = node_b.node.get_and_clear_pending_msg_events();
	assert_eq!(events_7.len(), 1);
	let (announcement, bs_update) = match events_7[0] {
		MessageSendEvent::BroadcastChannelAnnouncement { ref msg, ref update_msg } => {
			(msg, update_msg.clone().unwrap())
		},
		_ => panic!("Unexpected event"),
	};

	node_a.node.handle_announcement_signatures(node_b_id, &bs_announcement_sigs);
	let events_8 = node_a.node.get_and_clear_pending_msg_events();
	assert_eq!(events_8.len(), 1);
	let as_update = match events_8[0] {
		MessageSendEvent::BroadcastChannelAnnouncement { ref msg, ref update_msg } => {
			assert!(*announcement == *msg);
			let update_msg = update_msg.clone().unwrap();
			assert_eq!(
				update_msg.contents.short_channel_id,
				announcement.contents.short_channel_id
			);
			assert_eq!(update_msg.contents.short_channel_id, bs_update.contents.short_channel_id);
			update_msg
		},
		_ => panic!("Unexpected event"),
	};

	*node_a.network_chan_count.borrow_mut() += 1;

	expect_channel_ready_event(&node_b, &node_a_id);
	((*announcement).clone(), as_update, bs_update)
}

pub fn create_announced_chan_between_nodes<'a, 'b, 'c: 'd, 'd>(
	nodes: &'a Vec<Node<'b, 'c, 'd>>, a: usize, b: usize,
) -> (msgs::ChannelUpdate, msgs::ChannelUpdate, ChannelId, Transaction) {
	create_announced_chan_between_nodes_with_value(nodes, a, b, 100000, 10001)
}

pub fn create_announced_chan_between_nodes_with_value<'a, 'b, 'c: 'd, 'd>(
	nodes: &'a Vec<Node<'b, 'c, 'd>>, a: usize, b: usize, channel_value: u64, push_msat: u64,
) -> (msgs::ChannelUpdate, msgs::ChannelUpdate, ChannelId, Transaction) {
	let chan_announcement =
		create_chan_between_nodes_with_value(&nodes[a], &nodes[b], channel_value, push_msat);
	update_nodes_with_chan_announce(
		nodes,
		a,
		b,
		&chan_announcement.0,
		&chan_announcement.1,
		&chan_announcement.2,
	);
	(chan_announcement.1, chan_announcement.2, chan_announcement.3, chan_announcement.4)
}

pub fn create_unannounced_chan_between_nodes_with_value<'a, 'b, 'c, 'd>(
	nodes: &'a Vec<Node<'b, 'c, 'd>>, a: usize, b: usize, channel_value: u64, push_msat: u64,
) -> (msgs::ChannelReady, Transaction) {
	let node_a_id = nodes[a].node.get_our_node_id();
	let node_b_id = nodes[b].node.get_our_node_id();

	let mut no_announce_cfg = nodes[a].node.get_current_config();
	no_announce_cfg.channel_handshake_config.announce_for_forwarding = false;
	nodes[a]
		.node
		.create_channel(node_b_id, channel_value, push_msat, 42, None, Some(no_announce_cfg))
		.unwrap();
	let open_channel = get_event_msg!(nodes[a], MessageSendEvent::SendOpenChannel, node_b_id);
	handle_and_accept_open_channel(&nodes[b], node_a_id, &open_channel);

	let accept_channel = get_event_msg!(nodes[b], MessageSendEvent::SendAcceptChannel, node_a_id);
	nodes[a].node.handle_accept_channel(node_b_id, &accept_channel);

	let (temporary_channel_id, tx, _) =
		create_funding_transaction(&nodes[a], &node_b_id, channel_value, 42);
	nodes[a]
		.node
		.funding_transaction_generated(temporary_channel_id, node_b_id, tx.clone())
		.unwrap();
	let as_funding_created =
		get_event_msg!(nodes[a], MessageSendEvent::SendFundingCreated, node_b_id);
	nodes[b].node.handle_funding_created(node_a_id, &as_funding_created);
	check_added_monitors(&nodes[b], 1);

	let cs_funding_signed =
		get_event_msg!(nodes[b], MessageSendEvent::SendFundingSigned, node_a_id);
	expect_channel_pending_event(&nodes[b], &node_a_id);

	nodes[a].node.handle_funding_signed(node_b_id, &cs_funding_signed);
	expect_channel_pending_event(&nodes[a], &node_b_id);
	check_added_monitors(&nodes[a], 1);

	assert_eq!(nodes[a].tx_broadcaster.txn_broadcasted.lock().unwrap().len(), 1);
	assert_eq!(nodes[a].tx_broadcaster.txn_broadcasted.lock().unwrap()[0], tx);
	nodes[a].tx_broadcaster.clear();

	let conf_height =
		core::cmp::max(nodes[a].best_block_info().1 + 1, nodes[b].best_block_info().1 + 1);
	confirm_transaction_at(&nodes[a], &tx, conf_height);
	connect_blocks(&nodes[a], CHAN_CONFIRM_DEPTH - 1);
	confirm_transaction_at(&nodes[b], &tx, conf_height);
	connect_blocks(&nodes[b], CHAN_CONFIRM_DEPTH - 1);
	let as_channel_ready = get_event_msg!(nodes[a], MessageSendEvent::SendChannelReady, node_b_id);
	let bs_channel_ready = get_event_msg!(nodes[b], MessageSendEvent::SendChannelReady, node_a_id);
	nodes[a].node.handle_channel_ready(node_b_id, &bs_channel_ready);
	expect_channel_ready_event(&nodes[a], &node_b_id);
	let as_update = get_event_msg!(nodes[a], MessageSendEvent::SendChannelUpdate, node_b_id);
	nodes[b].node.handle_channel_ready(node_a_id, &as_channel_ready);
	expect_channel_ready_event(&nodes[b], &node_a_id);
	let bs_update = get_event_msg!(nodes[b], MessageSendEvent::SendChannelUpdate, node_a_id);

	nodes[a].node.handle_channel_update(node_b_id, &bs_update);
	nodes[b].node.handle_channel_update(node_a_id, &as_update);

	let mut found_a = false;
	for chan in nodes[a].node.list_usable_channels() {
		if chan.channel_id == as_channel_ready.channel_id {
			assert!(!found_a);
			found_a = true;
			assert!(!chan.is_announced);
		}
	}
	assert!(found_a);

	let mut found_b = false;
	for chan in nodes[b].node.list_usable_channels() {
		if chan.channel_id == as_channel_ready.channel_id {
			assert!(!found_b);
			found_b = true;
			assert!(!chan.is_announced);
		}
	}
	assert!(found_b);

	(as_channel_ready, tx)
}

pub fn handle_and_accept_open_channel(node: &Node, counterparty_id: PublicKey, msg: &OpenChannel) {
	node.node.handle_open_channel(counterparty_id, &msg);
	let events = node.node.get_and_clear_pending_events();
	assert_eq!(events.len(), 1);
	match &events[0] {
		Event::OpenChannelRequest { temporary_channel_id, counterparty_node_id, .. } => {
			node.node
				.accept_inbound_channel(temporary_channel_id, counterparty_node_id, 42, None)
				.unwrap();
		},
		_ => panic!("Unexpected event"),
	};
}

pub fn update_nodes_with_chan_announce<'a, 'b, 'c, 'd>(
	nodes: &'a Vec<Node<'b, 'c, 'd>>, a: usize, b: usize, ann: &msgs::ChannelAnnouncement,
	upd_1: &msgs::ChannelUpdate, upd_2: &msgs::ChannelUpdate,
) {
	for node in nodes {
		let node_id_a = nodes[a].node.get_our_node_id();
		let node_id_b = nodes[b].node.get_our_node_id();
		assert!(node.gossip_sync.handle_channel_announcement(None, ann).unwrap());
		node.gossip_sync.handle_channel_update(Some(node_id_a), upd_1).unwrap();
		node.gossip_sync.handle_channel_update(Some(node_id_b), upd_2).unwrap();

		// Note that channel_updates are also delivered to ChannelManagers to ensure we have
		// forwarding info for local channels even if its not accepted in the network graph.
		node.node.handle_channel_update(node_id_a, &upd_1);
		node.node.handle_channel_update(node_id_b, &upd_2);
	}
}

pub fn do_check_spends<F: Fn(&bitcoin::transaction::OutPoint) -> Option<TxOut>>(
	tx: &Transaction, get_output: F,
) {
	if tx.version == TxVersion::non_standard(3) {
		assert!(tx.weight().to_wu() <= TRUC_MAX_WEIGHT);
	} else {
		assert!(tx.weight().to_wu() <= MAX_STANDARD_TX_WEIGHT as u64);
	}
	let mut p2a_output_below_dust = false;
	let mut has_p2a_output = false;
	for outp in tx.output.iter() {
		let is_p2a = outp.script_pubkey == crate::ln::chan_utils::shared_anchor_script_pubkey();
		has_p2a_output |= is_p2a;
		if outp.value < outp.script_pubkey.minimal_non_dust() {
			if p2a_output_below_dust || !is_p2a {
				panic!("Spending tx output didn't meet dust limit");
			}
			p2a_output_below_dust = true;
		};
	}
	let mut total_value_in = 0;
	for input in tx.input.iter() {
		let output = get_output(&input.previous_output).unwrap();
		if output.script_pubkey == crate::ln::chan_utils::shared_anchor_script_pubkey() {
			assert!(input.witness.is_empty());
		}
		total_value_in += output.value.to_sat();
	}
	let mut total_value_out = 0;
	for output in tx.output.iter() {
		total_value_out += output.value.to_sat();
	}
	if p2a_output_below_dust {
		assert_eq!(
			total_value_in, total_value_out,
			"Spending tx has one output below dust, while not zero fee"
		);
	// 0FC commitment transactions will have their fee bumped by a child, so don't require that
	// they meet the 1sat/vB minimum.
	} else if !has_p2a_output {
		let min_fee = (tx.weight().to_wu() as u64).div_ceil(4); // One sat per vbyte (ie per weight/4, rounded up)
		assert!(total_value_out + min_fee <= total_value_in);
	}
	tx.verify(get_output).unwrap();
}

#[macro_export]
macro_rules! check_spends {
	($tx: expr, $($spends_txn: expr),*) => {
		{
			$(
			let mut single_output_below_dust = false;
			for outp in $spends_txn.output.iter() {
				if outp.value < outp.script_pubkey.minimal_non_dust() {
					if single_output_below_dust || outp.script_pubkey != $crate::ln::chan_utils::shared_anchor_script_pubkey() {
						panic!("Input tx output didn't meet dust limit");
					} else {
						single_output_below_dust = true;
					}
				}
			}
			)*
			let get_output = |out_point: &bitcoin::transaction::OutPoint| {
				$(
					if out_point.txid == $spends_txn.compute_txid() {
						return $spends_txn.output.get(out_point.vout as usize).cloned()
					}
				)*
				None
			};
			$crate::ln::functional_test_utils::do_check_spends(&$tx, get_output);
		}
	}
}

macro_rules! get_closing_signed_broadcast {
	($node: expr, $dest_pubkey: expr) => {{
		let events = $node.get_and_clear_pending_msg_events();
		assert!(events.len() == 1 || events.len() == 2);
		(
			match events[events.len() - 1] {
				MessageSendEvent::BroadcastChannelUpdate { ref msg, .. } => {
					assert_eq!(msg.contents.channel_flags & 2, 2);
					msg.clone()
				},
				_ => panic!("Unexpected event"),
			},
			if events.len() == 2 {
				match events[0] {
					MessageSendEvent::SendClosingSigned { ref node_id, ref msg } => {
						assert_eq!(*node_id, $dest_pubkey);
						Some(msg.clone())
					},
					_ => panic!("Unexpected event"),
				}
			} else {
				None
			},
		)
	}};
}

#[cfg(test)]
macro_rules! check_warn_msg {
	($node: expr, $recipient_node_id: expr, $chan_id: expr) => {{
		let msg_events = $node.node.get_and_clear_pending_msg_events();
		assert_eq!(msg_events.len(), 1);
		match msg_events[0] {
			MessageSendEvent::HandleError {
				action: ErrorAction::SendWarningMessage { ref msg, log_level: _ },
				node_id,
			} => {
				assert_eq!(node_id, $recipient_node_id);
				assert_eq!(msg.channel_id, $chan_id);
				msg.data.clone()
			},
			_ => panic!("Unexpected event"),
		}
	}};
}

/// Checks if at least one peer is connected.
fn is_any_peer_connected(node: &Node) -> bool {
	let peer_state = node.node.per_peer_state.read().unwrap();
	for (_, peer_mutex) in peer_state.iter() {
		let peer = peer_mutex.lock().unwrap();
		if peer.is_connected {
			return true;
		}
	}
	false
}

/// Check that a channel's closing channel update has been broadcasted, and optionally
/// check whether an error message event has occurred.
pub fn check_closed_broadcast(
	node: &Node, num_channels: usize, with_error_msg: bool,
) -> Vec<msgs::ErrorMessage> {
	let mut dummy_connected = false;
	if !is_any_peer_connected(&node) {
		connect_dummy_node(&node);
		dummy_connected = true;
	}
	let msg_events = node.node.get_and_clear_pending_msg_events();
	assert_eq!(msg_events.len(), if with_error_msg { num_channels * 2 } else { num_channels });
	if dummy_connected {
		disconnect_dummy_node(&node);
	}
	msg_events
		.into_iter()
		.filter_map(|msg_event| {
			match msg_event {
				MessageSendEvent::BroadcastChannelUpdate { ref msg, .. } => {
					assert_eq!(msg.contents.channel_flags & 2, 2);
					None
				},
				MessageSendEvent::HandleError {
					action: msgs::ErrorAction::SendErrorMessage { msg },
					node_id: _,
				} => {
					assert!(with_error_msg);
					// TODO: Check node_id
					Some(msg)
				},
				MessageSendEvent::HandleError {
					action: msgs::ErrorAction::DisconnectPeer { msg },
					node_id: _,
				} => {
					assert!(with_error_msg);
					// TODO: Check node_id
					Some(msg.unwrap())
				},
				_ => panic!("Unexpected event"),
			}
		})
		.collect()
}

/// Check that a channel's closing channel update has been broadcasted, and optionally
/// check whether an error message event has occurred.
///
/// Don't use this, use the identically-named function instead.
#[macro_export]
macro_rules! check_closed_broadcast {
	($node: expr, $with_error_msg: expr) => {
		$crate::ln::functional_test_utils::check_closed_broadcast(&$node, 1, $with_error_msg).pop()
	};
}

#[derive(Default)]
pub struct ExpectedCloseEvent {
	pub channel_capacity_sats: Option<u64>,
	pub channel_id: Option<ChannelId>,
	pub counterparty_node_id: Option<PublicKey>,
	pub discard_funding: bool,
	pub splice_failed: bool,
	pub reason: Option<ClosureReason>,
	pub channel_funding_txo: Option<OutPoint>,
	pub user_channel_id: Option<u128>,
}

impl ExpectedCloseEvent {
	pub fn from_id_reason(
		channel_id: ChannelId, discard_funding: bool, reason: ClosureReason,
	) -> Self {
		Self {
			channel_capacity_sats: None,
			channel_id: Some(channel_id),
			counterparty_node_id: None,
			discard_funding,
			splice_failed: false,
			reason: Some(reason),
			channel_funding_txo: None,
			user_channel_id: None,
		}
	}
}

/// Check that multiple channel closing events have been issued.
pub fn check_closed_events(node: &Node, expected_close_events: &[ExpectedCloseEvent]) {
	let closed_events_count = expected_close_events.len();
	let discard_events_count = expected_close_events.iter().filter(|e| e.discard_funding).count();
	let splice_events_count = expected_close_events.iter().filter(|e| e.splice_failed).count();
	let events = node.node.get_and_clear_pending_events();
	assert_eq!(
		events.len(),
		closed_events_count + discard_events_count + splice_events_count,
		"{:?}",
		events
	);
	for expected_event in expected_close_events {
		assert!(events.iter().any(|e| matches!(
			e,
			Event::ChannelClosed {
				channel_id,
				reason,
				counterparty_node_id,
				channel_capacity_sats,
				channel_funding_txo,
				user_channel_id,
				..
			} if (
				expected_event.channel_id.map(|expected| *channel_id == expected).unwrap_or(true) &&
				expected_event.reason.as_ref().map(|expected| reason == expected).unwrap_or(true) &&
				expected_event.
					counterparty_node_id.map(|expected| *counterparty_node_id == Some(expected)).unwrap_or(true) &&
				expected_event.channel_capacity_sats
					.map(|expected| *channel_capacity_sats == Some(expected)).unwrap_or(true) &&
				expected_event.channel_funding_txo
					.map(|expected| *channel_funding_txo == Some(expected)).unwrap_or(true) &&
				expected_event.user_channel_id
					.map(|expected| *user_channel_id == expected).unwrap_or(true)
			)
		)));
	}
	assert_eq!(
		events.iter().filter(|e| matches!(e, Event::DiscardFunding { .. },)).count(),
		discard_events_count
	);
	assert_eq!(
		events.iter().filter(|e| matches!(e, Event::SpliceFailed { .. },)).count(),
		splice_events_count
	);
}

/// Check that a channel's closing channel events has been issued
pub fn check_closed_event(
	node: &Node, events_count: usize, expected_reason: ClosureReason,
	expected_counterparty_node_ids: &[PublicKey], expected_channel_capacity: u64,
) {
	check_closed_event_internal(
		node,
		events_count,
		expected_reason,
		false,
		expected_counterparty_node_ids,
		expected_channel_capacity,
	);
}

pub fn check_closed_event_internal(
	node: &Node, events_count: usize, expected_reason: ClosureReason,
	is_check_discard_funding: bool, expected_counterparty_node_ids: &[PublicKey],
	expected_channel_capacity: u64,
) {
	let expected_events_count = if is_check_discard_funding {
		2 * expected_counterparty_node_ids.len()
	} else {
		expected_counterparty_node_ids.len()
	};
	assert_eq!(events_count, expected_events_count);
	let expected_close_events = expected_counterparty_node_ids
		.iter()
		.map(|node_id| ExpectedCloseEvent {
			channel_capacity_sats: Some(expected_channel_capacity),
			channel_id: None,
			counterparty_node_id: Some(*node_id),
			discard_funding: is_check_discard_funding,
			splice_failed: false,
			reason: Some(expected_reason.clone()),
			channel_funding_txo: None,
			user_channel_id: None,
		})
		.collect::<Vec<_>>();
	check_closed_events(node, expected_close_events.as_slice());
}

pub fn handle_bump_events(node: &Node, expected_close: bool, expected_htlc_count: usize) {
	let events = node.chain_monitor.chain_monitor.get_and_clear_pending_events();
	let mut close = false;
	let mut htlc_count = 0;
	for event in &events {
		match event {
			Event::BumpTransaction(bump @ BumpTransactionEvent::ChannelClose { .. }) => {
				close = true;
				node.bump_tx_handler.handle_event(&bump);
			},
			Event::BumpTransaction(bump @ BumpTransactionEvent::HTLCResolution { .. }) => {
				htlc_count += 1;
				node.bump_tx_handler.handle_event(&bump);
			},
			_ => panic!("Unexpected non-bump event: {:?}.", event),
		}
	}
	assert_eq!(close, expected_close, "Expected a bump close event, found {:?}.", events);
	assert_eq!(
		htlc_count, expected_htlc_count,
		"Expected {} bump HTLC events, found {:?}",
		expected_htlc_count, events
	);
}

pub fn handle_bump_close_event(node: &Node) {
	handle_bump_events(node, true, 0);
}

pub fn handle_bump_htlc_event(node: &Node, count: usize) {
	handle_bump_events(node, false, count);
}

pub fn close_channel<'a, 'b, 'c>(
	outbound_node: &Node<'a, 'b, 'c>, inbound_node: &Node<'a, 'b, 'c>, channel_id: &ChannelId,
	funding_tx: Transaction, close_inbound_first: bool,
) -> (msgs::ChannelUpdate, msgs::ChannelUpdate, Transaction) {
	let (node_a, broadcaster_a, struct_a) = if close_inbound_first {
		(&inbound_node.node, &inbound_node.tx_broadcaster, inbound_node)
	} else {
		(&outbound_node.node, &outbound_node.tx_broadcaster, outbound_node)
	};
	let (node_b, broadcaster_b, struct_b) = if close_inbound_first {
		(&outbound_node.node, &outbound_node.tx_broadcaster, outbound_node)
	} else {
		(&inbound_node.node, &inbound_node.tx_broadcaster, inbound_node)
	};
	let (tx_a, tx_b);

	node_a.close_channel(channel_id, &node_b.get_our_node_id()).unwrap();
	let as_shutdown =
		get_event_msg!(struct_a, MessageSendEvent::SendShutdown, node_b.get_our_node_id());
	node_b.handle_shutdown(node_a.get_our_node_id(), &as_shutdown);

	let events_1 = node_b.get_and_clear_pending_msg_events();
	assert!(events_1.len() >= 1);
	let shutdown_b = match events_1[0] {
		MessageSendEvent::SendShutdown { ref node_id, ref msg } => {
			assert_eq!(node_id, &node_a.get_our_node_id());
			msg.clone()
		},
		_ => panic!("Unexpected event"),
	};

	let closing_signed_b = if !close_inbound_first {
		assert_eq!(events_1.len(), 1);
		None
	} else {
		Some(match events_1[1] {
			MessageSendEvent::SendClosingSigned { ref node_id, ref msg } => {
				assert_eq!(node_id, &node_a.get_our_node_id());
				msg.clone()
			},
			_ => panic!("Unexpected event"),
		})
	};

	node_a.handle_shutdown(node_b.get_our_node_id(), &shutdown_b);
	let (as_update, bs_update) = if close_inbound_first {
		assert!(node_a.get_and_clear_pending_msg_events().is_empty());
		node_a.handle_closing_signed(node_b.get_our_node_id(), &closing_signed_b.unwrap());

		let as_closing_signed =
			get_event_msg!(struct_a, MessageSendEvent::SendClosingSigned, node_b.get_our_node_id());
		node_b.handle_closing_signed(node_a.get_our_node_id(), &as_closing_signed);
		assert_eq!(broadcaster_b.txn_broadcasted.lock().unwrap().len(), 1);
		tx_b = broadcaster_b.txn_broadcasted.lock().unwrap().remove(0);
		let (bs_update, closing_signed_b) =
			get_closing_signed_broadcast!(node_b, node_a.get_our_node_id());

		node_a.handle_closing_signed(node_b.get_our_node_id(), &closing_signed_b.unwrap());
		let (as_update, none_a) = get_closing_signed_broadcast!(node_a, node_b.get_our_node_id());
		assert!(none_a.is_none());
		assert_eq!(broadcaster_a.txn_broadcasted.lock().unwrap().len(), 1);
		tx_a = broadcaster_a.txn_broadcasted.lock().unwrap().remove(0);
		(as_update, bs_update)
	} else {
		let closing_signed_a =
			get_event_msg!(struct_a, MessageSendEvent::SendClosingSigned, node_b.get_our_node_id());
		node_b.handle_closing_signed(node_a.get_our_node_id(), &closing_signed_a);

		let closing_signed_b =
			get_event_msg!(struct_b, MessageSendEvent::SendClosingSigned, node_a.get_our_node_id());
		node_a.handle_closing_signed(node_b.get_our_node_id(), &closing_signed_b);

		assert_eq!(broadcaster_a.txn_broadcasted.lock().unwrap().len(), 1);
		tx_a = broadcaster_a.txn_broadcasted.lock().unwrap().remove(0);
		let (as_update, closing_signed_a) =
			get_closing_signed_broadcast!(node_a, node_b.get_our_node_id());

		node_b.handle_closing_signed(node_a.get_our_node_id(), &closing_signed_a.unwrap());
		let (bs_update, none_b) = get_closing_signed_broadcast!(node_b, node_a.get_our_node_id());
		assert!(none_b.is_none());
		assert_eq!(broadcaster_b.txn_broadcasted.lock().unwrap().len(), 1);
		tx_b = broadcaster_b.txn_broadcasted.lock().unwrap().remove(0);
		(as_update, bs_update)
	};
	assert_eq!(tx_a, tx_b);
	check_spends!(tx_a, funding_tx);

	(as_update, bs_update, tx_a)
}

pub struct SendEvent {
	pub node_id: PublicKey,
	pub channel_id: ChannelId,
	pub msgs: Vec<msgs::UpdateAddHTLC>,
	pub commitment_msg: Vec<msgs::CommitmentSigned>,
}
impl SendEvent {
	pub fn from_commitment_update(
		node_id: PublicKey, channel_id: ChannelId, updates: msgs::CommitmentUpdate,
	) -> SendEvent {
		assert!(updates.update_fulfill_htlcs.is_empty());
		assert!(updates.update_fail_htlcs.is_empty());
		assert!(updates.update_fail_malformed_htlcs.is_empty());
		assert!(updates.update_fee.is_none());
		SendEvent {
			node_id,
			channel_id,
			msgs: updates.update_add_htlcs,
			commitment_msg: updates.commitment_signed,
		}
	}

	pub fn from_event(event: MessageSendEvent) -> SendEvent {
		match event {
			MessageSendEvent::UpdateHTLCs { node_id, channel_id, updates } => {
				SendEvent::from_commitment_update(node_id, channel_id, updates)
			},
			_ => panic!("Unexpected event type!"),
		}
	}

	pub fn from_node<'a, 'b, 'c>(node: &Node<'a, 'b, 'c>) -> SendEvent {
		let mut events = node.node.get_and_clear_pending_msg_events();
		assert_eq!(events.len(), 1);
		SendEvent::from_event(events.pop().unwrap())
	}
}

#[macro_export]
macro_rules! expect_htlc_handling_failed_destinations {
	($events: expr, $expected_failures: expr) => {{
		let mut num_expected_failures = $expected_failures.len();
		for event in $events {
			match event {
				$crate::events::Event::HTLCHandlingFailed { ref failure_type, .. } => {
					assert!($expected_failures.contains(&failure_type));
					num_expected_failures -= 1;
				},
				_ => panic!("Unexpected destination"),
			}
		}
		assert_eq!(num_expected_failures, 0);
	}};
}

/// Checks that, if there are any [`Event::HTLCHandlingFailed`] events, their
/// [`HTLCHandlingFailureType`] is included in the `expected_failures` set.
pub fn expect_htlc_failure_conditions(
	events: Vec<Event>, expected_failures: &[HTLCHandlingFailureType],
) {
	assert_eq!(events.len(), expected_failures.len(), "{:?}", events);
	if expected_failures.len() > 0 {
		expect_htlc_handling_failed_destinations!(events, expected_failures)
	}
}

pub fn expect_and_process_pending_htlcs_and_htlc_handling_failed(
	node: &Node<'_, '_, '_>, expected_failures: &[HTLCHandlingFailureType],
) {
	let events = node.node.get_and_clear_pending_events();
	expect_htlc_failure_conditions(events, expected_failures);
	expect_and_process_pending_htlcs(node, false);
	assert!(node.node.get_and_clear_pending_events().is_empty());
}

pub fn expect_and_process_pending_htlcs(node: &Node<'_, '_, '_>, process_twice: bool) {
	assert!(node.node.needs_pending_htlc_processing());
	node.node.process_pending_htlc_forwards();
	if process_twice {
		// We expect that further processing steps became necessary, e.g., because we have to
		// process the failure, or retry a payment.
		assert!(node.node.needs_pending_htlc_processing());
		node.node.process_pending_htlc_forwards();
	}
	assert!(!node.node.needs_pending_htlc_processing());
}

/// Processes an HTLC which is pending forward but will fail to forward when we process it here.
pub fn expect_htlc_forwarding_fails(
	node: &Node<'_, '_, '_>, expected_failure: &[HTLCHandlingFailureType],
) {
	expect_and_process_pending_htlcs(node, false);
	let events = node.node.get_and_clear_pending_events();
	expect_htlc_failure_conditions(events, expected_failure);
}

/// Runs the commitment_signed dance after the initial commitment_signed is delivered through to
/// the initiator's `revoke_and_ack` response. i.e. [`do_main_commitment_signed_dance`] plus the
/// `revoke_and_ack` response to it.
///
/// An HTLC claim on one channel blocks the RAA channel monitor update for the outbound edge
/// channel until the inbound edge channel preimage monitor update completes. Thus, when checking
/// for channel monitor updates, we need to know if an `update_fulfill_htlc` was included in the
/// the commitment we're exchanging. `includes_claim` provides that information.
///
/// Returns any additional message `node_b` generated in addition to the `revoke_and_ack` response.
pub fn commitment_signed_dance_through_cp_raa(
	node_a: &Node<'_, '_, '_>, node_b: &Node<'_, '_, '_>, fail_backwards: bool,
	includes_claim: bool,
) -> Option<MessageSendEvent> {
	let (extra_msg_option, bs_revoke_and_ack) =
		do_main_commitment_signed_dance(node_a, node_b, fail_backwards);
	node_a.node.handle_revoke_and_ack(node_b.node.get_our_node_id(), &bs_revoke_and_ack);
	check_added_monitors(node_a, if includes_claim { 0 } else { 1 });
	extra_msg_option
}

/// Does the main logic in the commitment_signed dance. After the first `commitment_signed` has
/// been delivered, this method picks up and delivers the response `revoke_and_ack` and
/// `commitment_signed`, returning the recipient's `revoke_and_ack` and any extra message it may
/// have included.
pub fn do_main_commitment_signed_dance(
	node_a: &Node<'_, '_, '_>, node_b: &Node<'_, '_, '_>, fail_backwards: bool,
) -> (Option<MessageSendEvent>, msgs::RevokeAndACK) {
	let node_a_id = node_a.node.get_our_node_id();
	let node_b_id = node_b.node.get_our_node_id();

	let (as_revoke_and_ack, as_commitment_signed) = get_revoke_commit_msgs(node_a, &node_b_id);
	check_added_monitors(&node_b, 0);
	assert!(node_b.node.get_and_clear_pending_msg_events().is_empty());
	node_b.node.handle_revoke_and_ack(node_a_id, &as_revoke_and_ack);
	assert!(node_b.node.get_and_clear_pending_msg_events().is_empty());
	check_added_monitors(&node_b, 1);
	node_b.node.handle_commitment_signed_batch_test(node_a_id, &as_commitment_signed);
	let (bs_revoke_and_ack, extra_msg_option) = {
		let mut events = node_b.node.get_and_clear_pending_msg_events();
		assert!(events.len() <= 2);
		let node_a_event = remove_first_msg_event_to_node(&node_a_id, &mut events);
		(
			match node_a_event {
				MessageSendEvent::SendRevokeAndACK { ref node_id, ref msg } => {
					assert_eq!(*node_id, node_a_id);
					(*msg).clone()
				},
				_ => panic!("Unexpected event"),
			},
			events.get(0).map(|e| e.clone()),
		)
	};
	check_added_monitors(&node_b, 1);
	if fail_backwards {
		assert!(node_a.node.get_and_clear_pending_events().is_empty());
		assert!(node_a.node.get_and_clear_pending_msg_events().is_empty());
	}
	(extra_msg_option, bs_revoke_and_ack)
}

/// Runs the commitment_signed dance by delivering the commitment_signed and handling the
/// responding `revoke_and_ack` and `commitment_signed`.
///
/// Returns the recipient's `revoke_and_ack`.
pub fn commitment_signed_dance_return_raa(
	node_a: &Node<'_, '_, '_>, node_b: &Node<'_, '_, '_>,
	commitment_signed: &Vec<msgs::CommitmentSigned>, fail_backwards: bool,
) -> msgs::RevokeAndACK {
	check_added_monitors(&node_a, 0);
	assert!(node_a.node.get_and_clear_pending_msg_events().is_empty());
	node_a
		.node
		.handle_commitment_signed_batch_test(node_b.node.get_our_node_id(), commitment_signed);
	check_added_monitors(&node_a, 1);
	let (extra_msg_option, bs_revoke_and_ack) =
		do_main_commitment_signed_dance(&node_a, &node_b, fail_backwards);
	assert!(extra_msg_option.is_none());
	bs_revoke_and_ack
}

/// Runs a full commitment_signed dance, delivering a commitment_signed, the responding
/// `revoke_and_ack` and `commitment_signed`, and then the final `revoke_and_ack` response.
///
/// If `skip_last_step` is unset, also checks for the payment failure update for the previous hop
/// on failure or that no new messages are left over on success.
pub fn do_commitment_signed_dance(
	node_a: &Node<'_, '_, '_>, node_b: &Node<'_, '_, '_>,
	commitment_signed: &Vec<msgs::CommitmentSigned>, fail_backwards: bool, skip_last_step: bool,
) {
	let node_b_id = node_b.node.get_our_node_id();

	check_added_monitors(&node_a, 0);
	assert!(node_a.node.get_and_clear_pending_msg_events().is_empty());
	node_a.node.handle_commitment_signed_batch_test(node_b_id, commitment_signed);
	check_added_monitors(&node_a, 1);

	// If this commitment signed dance was due to a claim, don't check for an RAA monitor update.
	let channel_id = commitment_signed[0].channel_id;
	let got_claim = node_a.node.test_raa_monitor_updates_held(node_b_id, channel_id);
	if fail_backwards {
		assert!(!got_claim);
	}
	assert!(
		commitment_signed_dance_through_cp_raa(node_a, node_b, fail_backwards, got_claim).is_none()
	);

	if skip_last_step {
		return;
	}

	if fail_backwards {
		expect_and_process_pending_htlcs_and_htlc_handling_failed(
			&node_a,
			&[crate::events::HTLCHandlingFailureType::Forward {
				node_id: Some(node_b_id),
				channel_id,
			}],
		);
		check_added_monitors(&node_a, 1);

		let node_a_per_peer_state = node_a.node.per_peer_state.read().unwrap();
		let mut number_of_msg_events = 0;
		for (cp_id, peer_state_mutex) in node_a_per_peer_state.iter() {
			let peer_state = peer_state_mutex.lock().unwrap();
			let cp_pending_msg_events = &peer_state.pending_msg_events;
			number_of_msg_events += cp_pending_msg_events.len();
			if cp_pending_msg_events.len() == 1 {
				if let MessageSendEvent::UpdateHTLCs { .. } = cp_pending_msg_events[0] {
					assert_ne!(*cp_id, node_b_id);
				} else {
					panic!("Unexpected event");
				}
			}
		}
		// Expecting the failure backwards event to the previous hop (not `node_b`)
		assert_eq!(number_of_msg_events, 1);
	} else {
		assert!(node_a.node.get_and_clear_pending_msg_events().is_empty());
	}
}

/// Get a payment preimage and hash.
pub fn get_payment_preimage_hash(
	recipient: &Node, min_value_msat: Option<u64>, min_final_cltv_expiry_delta: Option<u16>,
) -> (PaymentPreimage, PaymentHash, PaymentSecret) {
	let mut payment_count = recipient.network_payment_count.borrow_mut();
	let payment_preimage = PaymentPreimage([*payment_count; 32]);
	*payment_count += 1;
	let payment_hash = PaymentHash(Sha256::hash(&payment_preimage.0[..]).to_byte_array());
	let payment_secret = recipient
		.node
		.create_inbound_payment_for_hash(
			payment_hash,
			min_value_msat,
			7200,
			min_final_cltv_expiry_delta,
		)
		.unwrap();
	(payment_preimage, payment_hash, payment_secret)
}

/// Get a payment preimage and hash.
///
/// Don't use this, use the identically-named function instead.
#[macro_export]
macro_rules! get_payment_preimage_hash {
	($dest_node: expr) => {
		get_payment_preimage_hash!($dest_node, None)
	};
	($dest_node: expr, $min_value_msat: expr) => {
		$crate::get_payment_preimage_hash!($dest_node, $min_value_msat, None)
	};
	($dest_node: expr, $min_value_msat: expr, $min_final_cltv_expiry_delta: expr) => {
		$crate::ln::functional_test_utils::get_payment_preimage_hash(
			&$dest_node,
			$min_value_msat,
			$min_final_cltv_expiry_delta,
		)
	};
}

/// Gets a route from the given sender to the node described in `payment_params`.
pub fn get_route(send_node: &Node, route_params: &RouteParameters) -> Result<Route, &'static str> {
	let scorer = TestScorer::new();
	let keys_manager = TestKeysInterface::new(&[0u8; 32], Network::Testnet);
	let random_seed_bytes = keys_manager.get_secure_random_bytes();
	let first_hops = send_node.node.list_usable_channels();
	router::get_route(
		&send_node.node.get_our_node_id(),
		route_params,
		&send_node.network_graph.read_only(),
		Some(&first_hops.iter().collect::<Vec<_>>()),
		send_node.logger,
		&scorer,
		&Default::default(),
		&random_seed_bytes,
	)
}

/// Like `get_route` above, but adds a random CLTV offset to the final hop.
pub fn find_route(send_node: &Node, route_params: &RouteParameters) -> Result<Route, &'static str> {
	let scorer = TestScorer::new();
	let keys_manager = TestKeysInterface::new(&[0u8; 32], Network::Testnet);
	let random_seed_bytes = keys_manager.get_secure_random_bytes();
	router::find_route(
		&send_node.node.get_our_node_id(),
		route_params,
		&send_node.network_graph,
		Some(&send_node.node.list_usable_channels().iter().collect::<Vec<_>>()),
		send_node.logger,
		&scorer,
		&Default::default(),
		&random_seed_bytes,
	)
}

/// Gets a route from the given sender to the node described in `payment_params`.
///
/// Don't use this, use the identically-named function instead.
#[macro_export]
macro_rules! get_route {
	($send_node: expr, $payment_params: expr, $recv_value: expr) => {{
		let route_params = $crate::routing::router::RouteParameters::from_payment_params_and_value(
			$payment_params,
			$recv_value,
		);
		$crate::ln::functional_test_utils::get_route(&$send_node, &route_params)
	}};
}

#[macro_export]
macro_rules! get_route_and_payment_hash {
	($send_node: expr, $recv_node: expr, $recv_value: expr) => {{
		let payment_params = $crate::routing::router::PaymentParameters::from_node_id(
			$recv_node.node.get_our_node_id(),
			TEST_FINAL_CLTV,
		)
		.with_bolt11_features($recv_node.node.bolt11_invoice_features())
		.unwrap();
		$crate::get_route_and_payment_hash!($send_node, $recv_node, payment_params, $recv_value)
	}};
	($send_node: expr, $recv_node: expr, $payment_params: expr, $recv_value: expr) => {{
		$crate::get_route_and_payment_hash!(
			$send_node,
			$recv_node,
			$payment_params,
			$recv_value,
			None
		)
	}};
	($send_node: expr, $recv_node: expr, $payment_params: expr, $recv_value: expr, $max_total_routing_fee_msat: expr) => {{
		let mut route_params =
			$crate::routing::router::RouteParameters::from_payment_params_and_value(
				$payment_params,
				$recv_value,
			);
		route_params.max_total_routing_fee_msat = $max_total_routing_fee_msat;
		let (payment_preimage, payment_hash, payment_secret) =
			$crate::ln::functional_test_utils::get_payment_preimage_hash(
				&$recv_node,
				Some($recv_value),
				None,
			);
		let route = $crate::ln::functional_test_utils::get_route(&$send_node, &route_params);
		(route.unwrap(), payment_hash, payment_preimage, payment_secret)
	}};
}

pub fn check_payment_claimable(
	event: &Event, expected_payment_hash: PaymentHash, expected_payment_secret: PaymentSecret,
	expected_recv_value: u64, expected_payment_preimage: Option<PaymentPreimage>,
	expected_receiver_node_id: PublicKey,
) {
	match event {
		Event::PaymentClaimable {
			ref payment_hash,
			ref purpose,
			amount_msat,
			receiver_node_id,
			..
		} => {
			assert_eq!(expected_payment_hash, *payment_hash);
			assert_eq!(expected_recv_value, *amount_msat);
			assert_eq!(expected_receiver_node_id, receiver_node_id.unwrap());
			match purpose {
				PaymentPurpose::Bolt11InvoicePayment {
					payment_preimage, payment_secret, ..
				} => {
					assert_eq!(&expected_payment_preimage, payment_preimage);
					assert_eq!(expected_payment_secret, *payment_secret);
				},
				PaymentPurpose::Bolt12OfferPayment { payment_preimage, payment_secret, .. } => {
					assert_eq!(&expected_payment_preimage, payment_preimage);
					assert_eq!(expected_payment_secret, *payment_secret);
				},
				PaymentPurpose::Bolt12RefundPayment {
					payment_preimage, payment_secret, ..
				} => {
					assert_eq!(&expected_payment_preimage, payment_preimage);
					assert_eq!(expected_payment_secret, *payment_secret);
				},
				_ => {},
			}
		},
		_ => panic!("Unexpected event {event:?}"),
	}
}

#[macro_export]
#[cfg(any(test, ldk_bench, feature = "_test_utils"))]
macro_rules! expect_payment_claimable {
	($node: expr, $expected_payment_hash: expr, $expected_payment_secret: expr, $expected_recv_value: expr) => {
		expect_payment_claimable!(
			$node,
			$expected_payment_hash,
			$expected_payment_secret,
			$expected_recv_value,
			None,
			$node.node.get_our_node_id()
		)
	};
	($node: expr, $expected_payment_hash: expr, $expected_payment_secret: expr, $expected_recv_value: expr, $expected_payment_preimage: expr, $expected_receiver_node_id: expr) => {
		let events = $node.node.get_and_clear_pending_events();
		assert_eq!(events.len(), 1);
		$crate::ln::functional_test_utils::check_payment_claimable(
			&events[0],
			$expected_payment_hash,
			$expected_payment_secret,
			$expected_recv_value,
			$expected_payment_preimage,
			$expected_receiver_node_id,
		)
	};
}

#[macro_export]
#[cfg(any(test, ldk_bench, feature = "_test_utils"))]
macro_rules! expect_payment_claimed {
	($node: expr, $expected_payment_hash: expr, $expected_recv_value: expr) => {
		let events = $node.node.get_and_clear_pending_events();
		assert_eq!(events.len(), 1);
		match events[0] {
			$crate::events::Event::PaymentClaimed { ref payment_hash, amount_msat, .. } => {
				assert_eq!($expected_payment_hash, *payment_hash);
				assert_eq!($expected_recv_value, amount_msat);
			},
			_ => panic!("Unexpected event"),
		}
	};
}

/// Inspect events to assert that a payment was sent. If this was a BOLT 12 payment, the BOLT 12 invoice is returned. If
/// per-path claims are expected, the events for each path are returned as well.
pub fn expect_payment_sent<CM: AChannelManager, H: NodeHolder<CM = CM>>(
	node: &H, expected_payment_preimage: PaymentPreimage,
	expected_fee_msat_opt: Option<Option<u64>>, expect_per_path_claims: bool,
	expect_post_ev_mon_update: bool,
) -> (Option<PaidBolt12Invoice>, Vec<Event>) {
	if expect_post_ev_mon_update {
		check_added_monitors(node, 0);
	}
	let events = node.node().get_and_clear_pending_events();
	let expected_payment_hash = PaymentHash(
		bitcoin::hashes::sha256::Hash::hash(&expected_payment_preimage.0).to_byte_array(),
	);
	if expect_per_path_claims {
		assert!(events.len() > 1, "{events:?}");
	} else {
		assert_eq!(events.len(), 1, "{events:?}");
	}
	if expect_post_ev_mon_update {
		check_added_monitors(node, 1);
	}
	// We return the invoice because some test may want to check the invoice details.
	let invoice;
	let mut path_events = Vec::new();
	let expected_payment_id = match events[0] {
		Event::PaymentSent {
			ref payment_id,
			ref payment_preimage,
			ref payment_hash,
			ref amount_msat,
			ref fee_paid_msat,
			ref bolt12_invoice,
		} => {
			assert_eq!(expected_payment_preimage, *payment_preimage);
			assert_eq!(expected_payment_hash, *payment_hash);
			assert!(amount_msat.is_some());
			if let Some(expected_fee_msat) = expected_fee_msat_opt {
				assert_eq!(*fee_paid_msat, expected_fee_msat);
			} else {
				assert!(fee_paid_msat.is_some());
			}
			invoice = bolt12_invoice.clone();
			payment_id.unwrap()
		},
		_ => panic!("Unexpected event"),
	};
	if expect_per_path_claims {
		for i in 1..events.len() {
			match events[i] {
				Event::PaymentPathSuccessful { payment_id, payment_hash, .. } => {
					assert_eq!(payment_id, expected_payment_id);
					assert_eq!(payment_hash, Some(expected_payment_hash));

					path_events.push(events[i].clone());
				},
				_ => panic!("Unexpected event"),
			}
		}
	}
	(invoice, path_events)
}

#[macro_export]
macro_rules! expect_payment_sent {
	($node: expr, $expected_payment_preimage: expr) => {
		$crate::expect_payment_sent!($node, $expected_payment_preimage, None::<u64>, true)
	};
	($node: expr, $expected_payment_preimage: expr, $expected_fee_msat_opt: expr) => {
		$crate::expect_payment_sent!(
			$node,
			$expected_payment_preimage,
			$expected_fee_msat_opt,
			true
		)
	};
	($node: expr, $expected_payment_preimage: expr, $expected_fee_msat_opt: expr, $expect_paths: expr) => {
		$crate::ln::functional_test_utils::expect_payment_sent(
			&$node,
			$expected_payment_preimage,
			$expected_fee_msat_opt.map(|o| Some(o)),
			$expect_paths,
			true,
		)
	};
}

#[macro_export]
macro_rules! expect_payment_path_successful {
	($node: expr) => {
		let events = $node.node.get_and_clear_pending_events();
		assert_eq!(events.len(), 1);
		match events[0] {
			$crate::events::Event::PaymentPathSuccessful { .. } => {},
			_ => panic!("Unexpected event"),
		}
	};
}

/// Returns the total fee earned by this HTLC forward, in msat.
pub fn expect_payment_forwarded<CM: AChannelManager, H: NodeHolder<CM = CM>>(
	event: Event, node: &H, prev_node: &H, next_node: &H, expected_fee: Option<u64>,
	expected_extra_fees_msat: Option<u64>, upstream_force_closed: bool,
	downstream_force_closed: bool, allow_1_msat_fee_overpay: bool,
) -> Option<u64> {
	match event {
		Event::PaymentForwarded {
			prev_channel_id,
			next_channel_id,
			prev_user_channel_id,
			next_user_channel_id,
			prev_node_id,
			next_node_id,
			total_fee_earned_msat,
			skimmed_fee_msat,
			claim_from_onchain_tx,
			..
		} => {
			if allow_1_msat_fee_overpay {
				// Aggregating fees for blinded paths may result in a rounding error, causing slight
				// overpayment in fees.
				let actual_fee = total_fee_earned_msat.unwrap();
				let expected_fee = expected_fee.unwrap();
				assert!(actual_fee == expected_fee || actual_fee == expected_fee + 1);
			} else {
				assert_eq!(total_fee_earned_msat, expected_fee);
			}

			// Check that the (knowingly) withheld amount is always less or equal to the expected
			// overpaid amount.
			assert!(skimmed_fee_msat == expected_extra_fees_msat);
			if !upstream_force_closed {
				assert_eq!(prev_node.node().get_our_node_id(), prev_node_id.unwrap());
				// Is the event prev_channel_id in one of the channels between the two nodes?
				let node_chans = node.node().list_channels();
				assert!(node_chans.iter().any(|x| x.counterparty.node_id == prev_node_id.unwrap()
					&& x.channel_id == prev_channel_id.unwrap()
					&& x.user_channel_id == prev_user_channel_id.unwrap()));
			}
			// We check for force closures since a force closed channel is removed from the
			// node's channel list
			if !downstream_force_closed {
				// As documented, `next_user_channel_id` will only be `Some` if we didn't settle via an
				// onchain transaction, just as the `total_fee_earned_msat` field. Rather than
				// introducing yet another variable, we use the latter's state as a flag to detect
				// this and only check if it's `Some`.
				assert_eq!(next_node.node().get_our_node_id(), next_node_id.unwrap());
				let node_chans = node.node().list_channels();
				if total_fee_earned_msat.is_none() {
					assert!(node_chans
						.iter()
						.any(|x| x.counterparty.node_id == next_node_id.unwrap()
							&& x.channel_id == next_channel_id.unwrap()));
				} else {
					assert!(node_chans
						.iter()
						.any(|x| x.counterparty.node_id == next_node_id.unwrap()
							&& x.channel_id == next_channel_id.unwrap()
							&& x.user_channel_id == next_user_channel_id.unwrap()));
				}
			}
			assert_eq!(claim_from_onchain_tx, downstream_force_closed);
			total_fee_earned_msat
		},
		_ => panic!("Unexpected event"),
	}
}

#[macro_export]
macro_rules! expect_payment_forwarded {
	($node: expr, $prev_node: expr, $next_node: expr, $expected_fee: expr, $upstream_force_closed: expr, $downstream_force_closed: expr) => {
		let mut events = $node.node.get_and_clear_pending_events();
		assert_eq!(events.len(), 1);
		$crate::ln::functional_test_utils::expect_payment_forwarded(
			events.pop().unwrap(),
			&$node,
			&$prev_node,
			&$next_node,
			$expected_fee,
			None,
			$upstream_force_closed,
			$downstream_force_closed,
			false,
		);
	};
}

#[macro_export]
macro_rules! expect_channel_shutdown_state {
	($node: expr, $chan_id: expr, $state: path) => {
		let chan_details = $node
			.node
			.list_channels()
			.into_iter()
			.filter(|cd| cd.channel_id == $chan_id)
			.collect::<Vec<ChannelDetails>>();
		assert_eq!(chan_details.len(), 1);
		assert_eq!(chan_details[0].channel_shutdown_state, Some($state));
	};
}

#[cfg(any(test, ldk_bench, feature = "_test_utils"))]
pub fn expect_channel_pending_event<'a, 'b, 'c, 'd>(
	node: &'a Node<'b, 'c, 'd>, expected_counterparty_node_id: &PublicKey,
) -> ChannelId {
	let events = node.node.get_and_clear_pending_events();
	assert_eq!(events.len(), 1);
	match &events[0] {
		crate::events::Event::ChannelPending { channel_id, counterparty_node_id, .. } => {
			assert_eq!(*expected_counterparty_node_id, *counterparty_node_id);
			*channel_id
		},
		_ => panic!("Unexpected event"),
	}
}

#[cfg(any(test, ldk_bench, feature = "_test_utils"))]
pub fn expect_channel_ready_event<'a, 'b, 'c, 'd>(
	node: &'a Node<'b, 'c, 'd>, expected_counterparty_node_id: &PublicKey,
) {
	let events = node.node.get_and_clear_pending_events();
	assert_eq!(events.len(), 1);
	match events[0] {
		crate::events::Event::ChannelReady { ref counterparty_node_id, .. } => {
			assert_eq!(*expected_counterparty_node_id, *counterparty_node_id);
		},
		_ => panic!("Unexpected event"),
	}
}

#[cfg(any(test, ldk_bench, feature = "_test_utils"))]
pub fn expect_splice_pending_event<'a, 'b, 'c, 'd>(
	node: &'a Node<'b, 'c, 'd>, expected_counterparty_node_id: &PublicKey,
) -> ChannelId {
	let events = node.node.get_and_clear_pending_events();
	assert_eq!(events.len(), 1);
	match &events[0] {
		crate::events::Event::SplicePending { channel_id, counterparty_node_id, .. } => {
			assert_eq!(*expected_counterparty_node_id, *counterparty_node_id);
			*channel_id
		},
		_ => panic!("Unexpected event"),
	}
}

pub fn expect_probe_successful_events(
	node: &Node, mut probe_results: Vec<(PaymentHash, PaymentId)>,
) {
	let mut events = node.node.get_and_clear_pending_events();

	for event in events.drain(..) {
		match event {
			Event::ProbeSuccessful { payment_hash: ev_ph, payment_id: ev_pid, .. } => {
				let result_idx = probe_results.iter().position(|(payment_hash, payment_id)| {
					*payment_hash == ev_ph && *payment_id == ev_pid
				});
				assert!(result_idx.is_some());

				probe_results.remove(result_idx.unwrap());
			},
			_ => panic!(),
		}
	}

	// Ensure that we received a ProbeSuccessful event for each probe result.
	assert!(probe_results.is_empty());
}

pub struct PaymentFailedConditions<'a> {
	pub expected_htlc_error_data: Option<(LocalHTLCFailureReason, &'a [u8])>,
	pub expected_blamed_scid: Option<u64>,
	pub expected_blamed_chan_closed: Option<bool>,
	pub expected_mpp_parts_remain: bool,
	pub retry_expected: bool,
	pub from_mon_update: bool,
	pub reason: Option<PaymentFailureReason>,
}

impl<'a> PaymentFailedConditions<'a> {
	pub fn new() -> Self {
		Self {
			expected_htlc_error_data: None,
			expected_blamed_scid: None,
			expected_blamed_chan_closed: None,
			expected_mpp_parts_remain: false,
			retry_expected: false,
			from_mon_update: false,
			reason: None,
		}
	}
	pub fn mpp_parts_remain(mut self) -> Self {
		self.expected_mpp_parts_remain = true;
		self
	}
	pub fn blamed_scid(mut self, scid: u64) -> Self {
		self.expected_blamed_scid = Some(scid);
		self
	}
	pub fn blamed_chan_closed(mut self, closed: bool) -> Self {
		self.expected_blamed_chan_closed = Some(closed);
		self
	}
	pub fn expected_htlc_error_data(
		mut self, reason: LocalHTLCFailureReason, data: &'a [u8],
	) -> Self {
		self.expected_htlc_error_data = Some((reason, data));
		self
	}
	pub fn retry_expected(mut self) -> Self {
		self.retry_expected = true;
		self
	}
	pub fn from_mon_update(mut self) -> Self {
		self.from_mon_update = true;
		self
	}
}

#[cfg(any(test, feature = "_externalize_tests"))]
macro_rules! expect_payment_failed_with_update {
	($node: expr, $expected_payment_hash: expr, $payment_failed_permanently: expr, $scid: expr, $chan_closed: expr) => {
		$crate::ln::functional_test_utils::expect_payment_failed_conditions(
			&$node,
			$expected_payment_hash,
			$payment_failed_permanently,
			$crate::ln::functional_test_utils::PaymentFailedConditions::new()
				.blamed_scid($scid)
				.blamed_chan_closed($chan_closed),
		);
	};
}

#[cfg(any(test, feature = "_externalize_tests"))]
macro_rules! expect_payment_failed {
	($node: expr, $expected_payment_hash: expr, $payment_failed_permanently: expr $(, $expected_error_reason: expr, $expected_error_data: expr)*) => {
		#[allow(unused_mut)]
		let mut conditions = $crate::ln::functional_test_utils::PaymentFailedConditions::new();
		$(
			conditions = conditions.expected_htlc_error_data($expected_error_reason, &$expected_error_data);
		)*
		$crate::ln::functional_test_utils::expect_payment_failed_conditions(&$node, $expected_payment_hash, $payment_failed_permanently, conditions);
	};
}

pub fn expect_payment_failed_conditions_event<'a, 'b, 'c, 'd, 'e>(
	payment_failed_events: Vec<Event>, expected_payment_hash: PaymentHash,
	expected_payment_failed_permanently: bool, conditions: PaymentFailedConditions<'e>,
) {
	if conditions.expected_mpp_parts_remain || conditions.retry_expected {
		assert_eq!(payment_failed_events.len(), 1);
	} else {
		assert_eq!(payment_failed_events.len(), 2);
	}
	let expected_payment_id = match &payment_failed_events[0] {
		Event::PaymentPathFailed {
			payment_hash,
			payment_failed_permanently,
			payment_id,
			failure,
			error_code,
			error_data,
			..
		} => {
			assert_eq!(*payment_hash, expected_payment_hash, "unexpected payment_hash");
			assert_eq!(
				*payment_failed_permanently, expected_payment_failed_permanently,
				"unexpected payment_failed_permanently value"
			);
			match failure {
				PathFailure::OnPath { .. } => {
					assert!(error_code.is_some(), "expected error_code.is_some() = true");
					assert!(error_data.is_some(), "expected error_data.is_some() = true");
					let reason: LocalHTLCFailureReason = error_code.unwrap().into();
					if let Some((code, data)) = conditions.expected_htlc_error_data {
						assert_eq!(reason, code, "unexpected error code");
						assert_eq!(&error_data.as_ref().unwrap()[..], data);
					}
				},
				PathFailure::InitialSend { .. } => {
					assert!(error_code.is_none());
					assert!(error_data.is_none());
					assert!(conditions.expected_htlc_error_data.is_none());
				},
			}

			if let Some(chan_closed) = conditions.expected_blamed_chan_closed {
				if let PathFailure::OnPath { network_update: Some(upd) } = failure {
					match upd {
						NetworkUpdate::ChannelFailure { short_channel_id, is_permanent } => {
							if let Some(scid) = conditions.expected_blamed_scid {
								assert_eq!(*short_channel_id, scid);
							}
							assert_eq!(*is_permanent, chan_closed);
						},
						_ => panic!("Unexpected update type"),
					}
				} else {
					panic!("Expected network update");
				}
			}

			payment_id.unwrap()
		},
		_ => panic!("Unexpected event"),
	};
	if !conditions.expected_mpp_parts_remain && !conditions.retry_expected {
		match &payment_failed_events[1] {
			Event::PaymentFailed { ref payment_hash, ref payment_id, ref reason } => {
				assert_eq!(
					*payment_hash,
					Some(expected_payment_hash),
					"unexpected second payment_hash"
				);
				assert_eq!(*payment_id, expected_payment_id);
				assert_eq!(
					reason.unwrap(),
					if let Some(expected_reason) = conditions.reason {
						expected_reason
					} else if expected_payment_failed_permanently {
						PaymentFailureReason::RecipientRejected
					} else {
						PaymentFailureReason::RetriesExhausted
					}
				);
			},
			_ => panic!("Unexpected second event"),
		}
	}
}

pub fn expect_payment_failed_conditions<'a, 'b, 'c, 'd, 'e>(
	node: &'a Node<'b, 'c, 'd>, expected_payment_hash: PaymentHash,
	expected_payment_failed_permanently: bool, conditions: PaymentFailedConditions<'e>,
) {
	if conditions.from_mon_update {
		check_added_monitors(node, 0);
	}
	let events = node.node.get_and_clear_pending_events();
	if conditions.from_mon_update {
		check_added_monitors(node, 1);
	}
	expect_payment_failed_conditions_event(
		events,
		expected_payment_hash,
		expected_payment_failed_permanently,
		conditions,
	);
}

pub fn send_along_route_with_secret<'a, 'b, 'c>(
	origin_node: &Node<'a, 'b, 'c>, route: Route, expected_paths: &[&[&Node<'a, 'b, 'c>]],
	recv_value: u64, our_payment_hash: PaymentHash, our_payment_secret: PaymentSecret,
) -> PaymentId {
	let payment_id = PaymentId(origin_node.keys_manager.backing.get_secure_random_bytes());
	origin_node.router.expect_find_route(route.route_params.clone().unwrap(), Ok(route.clone()));
	origin_node
		.node
		.send_payment(
			our_payment_hash,
			RecipientOnionFields::secret_only(our_payment_secret),
			payment_id,
			route.route_params.unwrap(),
			Retry::Attempts(0),
		)
		.unwrap();
	check_added_monitors(&origin_node, expected_paths.len());
	pass_along_route(origin_node, expected_paths, recv_value, our_payment_hash, our_payment_secret);
	payment_id
}

pub fn fail_payment_along_path<'a, 'b, 'c>(expected_path: &[&Node<'a, 'b, 'c>]) {
	let origin_node_id = expected_path[0].node.get_our_node_id();

	// iterate from the receiving node to the origin node and handle update fail htlc.
	for (&node, &prev_node) in expected_path.iter().rev().zip(expected_path.iter().rev().skip(1)) {
		let updates = get_htlc_update_msgs(node, &prev_node.node.get_our_node_id());
		prev_node
			.node
			.handle_update_fail_htlc(node.node.get_our_node_id(), &updates.update_fail_htlcs[0]);
		check_added_monitors(&prev_node, 0);

		let is_first_hop = origin_node_id == prev_node.node.get_our_node_id();
		// We do not want to fail backwards on the first hop. All other hops should fail backwards.
		let commitment = &updates.commitment_signed;
		do_commitment_signed_dance(prev_node, node, commitment, !is_first_hop, false);
	}
}

pub struct PassAlongPathArgs<'a, 'b, 'c, 'd> {
	pub origin_node: &'a Node<'b, 'c, 'd>,
	pub expected_path: &'a [&'a Node<'b, 'c, 'd>],
	pub dummy_tlvs: Vec<DummyTlvs>,
	pub recv_value: u64,
	pub payment_hash: PaymentHash,
	pub payment_secret: Option<PaymentSecret>,
	pub event: MessageSendEvent,
	pub payment_claimable_expected: bool,
	pub clear_recipient_events: bool,
	pub expected_preimage: Option<PaymentPreimage>,
	pub is_probe: bool,
	pub custom_tlvs: Vec<(u64, Vec<u8>)>,
	pub payment_metadata: Option<Vec<u8>>,
	pub expected_failure: Option<HTLCHandlingFailureType>,
}

impl<'a, 'b, 'c, 'd> PassAlongPathArgs<'a, 'b, 'c, 'd> {
	pub fn new(
		origin_node: &'a Node<'b, 'c, 'd>, expected_path: &'a [&'a Node<'b, 'c, 'd>],
		recv_value: u64, payment_hash: PaymentHash, event: MessageSendEvent,
	) -> Self {
		Self {
			origin_node,
			expected_path,
			dummy_tlvs: vec![],
			recv_value,
			payment_hash,
			payment_secret: None,
			event,
			payment_claimable_expected: true,
			clear_recipient_events: true,
			expected_preimage: None,
			is_probe: false,
			custom_tlvs: Vec::new(),
			payment_metadata: None,
			expected_failure: None,
		}
	}
	pub fn without_clearing_recipient_events(mut self) -> Self {
		self.clear_recipient_events = false;
		self
	}
	pub fn is_probe(mut self) -> Self {
		self.payment_claimable_expected = false;
		self.is_probe = true;
		self
	}
	pub fn without_claimable_event(mut self) -> Self {
		self.payment_claimable_expected = false;
		self
	}
	pub fn with_payment_secret(mut self, payment_secret: PaymentSecret) -> Self {
		self.payment_secret = Some(payment_secret);
		self
	}
	pub fn with_payment_preimage(mut self, payment_preimage: PaymentPreimage) -> Self {
		self.expected_preimage = Some(payment_preimage);
		self
	}
	pub fn with_custom_tlvs(mut self, custom_tlvs: Vec<(u64, Vec<u8>)>) -> Self {
		self.custom_tlvs = custom_tlvs;
		self
	}
	pub fn with_payment_metadata(mut self, payment_metadata: Vec<u8>) -> Self {
		self.payment_metadata = Some(payment_metadata);
		self
	}
	pub fn expect_failure(mut self, failure: HTLCHandlingFailureType) -> Self {
		self.payment_claimable_expected = false;
		self.expected_failure = Some(failure);
		self
	}
	pub fn with_dummy_tlvs(mut self, dummy_tlvs: &[DummyTlvs]) -> Self {
		self.dummy_tlvs = dummy_tlvs.to_vec();
		self
	}
}

pub fn do_pass_along_path<'a, 'b, 'c>(args: PassAlongPathArgs) -> Option<Event> {
	let PassAlongPathArgs {
		origin_node,
		expected_path,
		dummy_tlvs,
		recv_value,
		payment_hash: our_payment_hash,
		payment_secret: our_payment_secret,
		event: ev,
		payment_claimable_expected,
		clear_recipient_events,
		expected_preimage,
		is_probe,
		custom_tlvs,
		payment_metadata,
		expected_failure,
	} = args;

	let mut payment_event = SendEvent::from_event(ev);
	let mut prev_node = origin_node;
	let mut event = None;

	for (idx, &node) in expected_path.iter().enumerate() {
		let is_last_hop = idx == expected_path.len() - 1;
		assert_eq!(node.node.get_our_node_id(), payment_event.node_id);

		node.node.handle_update_add_htlc(prev_node.node.get_our_node_id(), &payment_event.msgs[0]);
		check_added_monitors(&node, 0);

		if is_last_hop && is_probe {
			do_commitment_signed_dance(node, prev_node, &payment_event.commitment_msg, true, true);
			node.node.process_pending_htlc_forwards();
			check_added_monitors(node, 1);
		} else {
			let commitment = &payment_event.commitment_msg;
			do_commitment_signed_dance(node, prev_node, commitment, false, false);
			node.node.process_pending_htlc_forwards();
		}

		if is_last_hop {
			// At the final hop, the incoming packet contains N dummy-hop layers
			// before the real HTLC. Each call to `process_pending_htlc_forwards`
			// strips exactly one dummy layer, so we call it N times.
			for _ in 0..dummy_tlvs.len() {
				assert!(node.node.needs_pending_htlc_processing());
				node.node.process_pending_htlc_forwards();
			}
		}

		if is_last_hop && clear_recipient_events {
			let events_2 = node.node.get_and_clear_pending_events();
			if payment_claimable_expected {
				assert_eq!(events_2.len(), 1);
				match &events_2[0] {
					Event::PaymentClaimable {
						ref payment_hash,
						ref purpose,
						amount_msat,
						receiver_node_id,
						ref receiving_channel_ids,
						claim_deadline,
						onion_fields,
						..
					} => {
						assert_eq!(our_payment_hash, *payment_hash);
						assert_eq!(node.node.get_our_node_id(), receiver_node_id.unwrap());
						assert!(onion_fields.is_some());
						assert_eq!(onion_fields.as_ref().unwrap().custom_tlvs, custom_tlvs);
						assert_eq!(
							onion_fields.as_ref().unwrap().payment_metadata,
							payment_metadata
						);
						match &purpose {
							PaymentPurpose::Bolt11InvoicePayment {
								payment_preimage,
								payment_secret,
								..
							} => {
								assert_eq!(expected_preimage, *payment_preimage);
								assert_eq!(our_payment_secret.unwrap(), *payment_secret);
								assert_eq!(
									Some(*payment_secret),
									onion_fields.as_ref().unwrap().payment_secret
								);
							},
							PaymentPurpose::Bolt12OfferPayment {
								payment_preimage,
								payment_secret,
								..
							} => {
								if let Some(preimage) = expected_preimage {
									assert_eq!(preimage, payment_preimage.unwrap());
								}
								if let Some(secret) = our_payment_secret {
									assert_eq!(secret, *payment_secret);
								}
								assert_eq!(
									Some(*payment_secret),
									onion_fields.as_ref().unwrap().payment_secret
								);
							},
							PaymentPurpose::Bolt12RefundPayment {
								payment_preimage,
								payment_secret,
								..
							} => {
								assert_eq!(expected_preimage, *payment_preimage);
								assert_eq!(our_payment_secret.unwrap(), *payment_secret);
								assert_eq!(
									Some(*payment_secret),
									onion_fields.as_ref().unwrap().payment_secret
								);
							},
							PaymentPurpose::SpontaneousPayment(payment_preimage) => {
								assert_eq!(expected_preimage.unwrap(), *payment_preimage);
								assert_eq!(
									our_payment_secret,
									onion_fields.as_ref().unwrap().payment_secret
								);
							},
						}
						assert_eq!(*amount_msat, recv_value);
						let channels = node.node.list_channels();
						for (chan_id, user_chan_id) in receiving_channel_ids {
							let chan = channels
								.iter()
								.find(|details| &details.channel_id == chan_id)
								.unwrap();
							assert_eq!(*user_chan_id, Some(chan.user_channel_id));
						}
						assert!(claim_deadline.unwrap() > node.best_block_info().1);
					},
					_ => panic!("Unexpected event"),
				}
				event = Some(events_2[0].clone());
			} else if let Some(ref failure) = expected_failure {
				assert!(events_2.len() == 1);
				expect_htlc_handling_failed_destinations!(events_2, &[failure]);
				node.node.process_pending_htlc_forwards();
				check_added_monitors(&node, 1);
			} else {
				assert!(events_2.is_empty());
			}
		} else if !is_last_hop {
			let mut events_2 = node.node.get_and_clear_pending_msg_events();
			assert_eq!(events_2.len(), 1);
			check_added_monitors(&node, 1);
			payment_event = SendEvent::from_event(events_2.remove(0));
			assert_eq!(payment_event.msgs.len(), 1);
		}

		prev_node = node;
	}
	event
}

pub fn pass_along_path<'a, 'b, 'c>(
	origin_node: &Node<'a, 'b, 'c>, expected_path: &[&Node<'a, 'b, 'c>], recv_value: u64,
	our_payment_hash: PaymentHash, our_payment_secret: Option<PaymentSecret>, ev: MessageSendEvent,
	payment_claimable_expected: bool, expected_preimage: Option<PaymentPreimage>,
) -> Option<Event> {
	let mut args =
		PassAlongPathArgs::new(origin_node, expected_path, recv_value, our_payment_hash, ev);
	if !payment_claimable_expected {
		args = args.without_claimable_event();
	}
	if let Some(payment_secret) = our_payment_secret {
		args = args.with_payment_secret(payment_secret);
	}
	if let Some(payment_preimage) = expected_preimage {
		args = args.with_payment_preimage(payment_preimage);
	}
	do_pass_along_path(args)
}

pub fn send_probe_along_route<'a, 'b, 'c>(
	origin_node: &Node<'a, 'b, 'c>, expected_route: &[(&[&Node<'a, 'b, 'c>], PaymentHash)],
) {
	let mut events = origin_node.node.get_and_clear_pending_msg_events();
	assert_eq!(events.len(), expected_route.len());

	check_added_monitors(&origin_node, expected_route.len());

	for (path, payment_hash) in expected_route.iter() {
		let ev = remove_first_msg_event_to_node(&path[0].node.get_our_node_id(), &mut events);

		do_pass_along_path(
			PassAlongPathArgs::new(origin_node, path, 0, *payment_hash, ev)
				.is_probe()
				.without_clearing_recipient_events(),
		);

		let nodes_to_fail_payment: Vec<_> =
			vec![origin_node].into_iter().chain(path.iter().cloned()).collect();

		fail_payment_along_path(nodes_to_fail_payment.as_slice());
		expect_htlc_handling_failed_destinations!(
			path.last().unwrap().node.get_and_clear_pending_events(),
			&[HTLCHandlingFailureType::Receive { payment_hash: *payment_hash }]
		);
	}
}

pub fn pass_along_route<'a, 'b, 'c>(
	origin_node: &Node<'a, 'b, 'c>, expected_route: &[&[&Node<'a, 'b, 'c>]], recv_value: u64,
	our_payment_hash: PaymentHash, our_payment_secret: PaymentSecret,
) {
	let mut events = origin_node.node.get_and_clear_pending_msg_events();
	assert_eq!(events.len(), expected_route.len());

	for (path_idx, expected_path) in expected_route.iter().enumerate() {
		let ev =
			remove_first_msg_event_to_node(&expected_path[0].node.get_our_node_id(), &mut events);
		// Once we've gotten through all the HTLCs, the last one should result in a
		// PaymentClaimable (but each previous one should not!).
		let expect_payment = path_idx == expected_route.len() - 1;
		pass_along_path(
			origin_node,
			expected_path,
			recv_value,
			our_payment_hash.clone(),
			Some(our_payment_secret),
			ev,
			expect_payment,
			None,
		);
	}
}

pub fn send_along_route<'a, 'b, 'c>(
	origin_node: &Node<'a, 'b, 'c>, route: Route, expected_route: &[&Node<'a, 'b, 'c>],
	recv_value: u64,
) -> (PaymentPreimage, PaymentHash, PaymentSecret, PaymentId) {
	let (our_payment_preimage, our_payment_hash, our_payment_secret) =
		get_payment_preimage_hash!(expected_route.last().unwrap());
	let payment_id = send_along_route_with_secret(
		origin_node,
		route,
		&[expected_route],
		recv_value,
		our_payment_hash,
		our_payment_secret,
	);
	(our_payment_preimage, our_payment_hash, our_payment_secret, payment_id)
}

pub fn do_claim_payment_along_route(args: ClaimAlongRouteArgs) -> u64 {
	for path in args.expected_paths.iter() {
		assert_eq!(
			path.last().unwrap().node.get_our_node_id(),
			args.expected_paths[0].last().unwrap().node.get_our_node_id()
		);
	}
	args.expected_paths[0].last().unwrap().node.claim_funds(args.payment_preimage);
	pass_claimed_payment_along_route(args)
}

pub struct ClaimAlongRouteArgs<'a, 'b, 'c, 'd> {
	pub origin_node: &'a Node<'b, 'c, 'd>,
	pub expected_paths: &'a [&'a [&'a Node<'b, 'c, 'd>]],
	pub expected_extra_fees: Vec<u32>,
	/// A one-off adjustment used only in tests to account for an existing
	/// fee-handling trade-off in LDK.
	///
	/// When the payer is the introduction node of a blinded path, LDK does not
	/// subtract the forward fee for the `payer -> next_hop` channel
	/// (see [`BlindedPaymentPath::advance_path_by_one`]). This keeps the fee
	/// logic simpler at the cost of a small, intentional overpayment.
	///
	/// In the simple two-hop case (payer as introduction node  payee),
	/// this overpayment has historically been avoided by simply not charging
	/// the payer the forward fee, since the payer knows there is only
	/// a single hop after them.
	///
	/// However, with the introduction of dummy hops in LDK v0.3, even a
	/// two-node real path (payer as introduction node  payee) may appear as a
	/// multi-hop blinded path. This makes the existing overpayment surface in
	/// tests.
	///
	/// Until the fee-handling trade-off is revisited, this field allows tests
	/// to compensate for that expected difference.
	///
	/// [`BlindedPaymentPath::advance_path_by_one`]: crate::blinded_path::payment::BlindedPaymentPath::advance_path_by_one
	pub expected_extra_total_fees_msat: u64,
	pub expected_min_htlc_overpay: Vec<u32>,
	pub skip_last: bool,
	pub payment_preimage: PaymentPreimage,
	pub custom_tlvs: Vec<(u64, Vec<u8>)>,
	// Allow forwarding nodes to have taken 1 msat more fee than expected based on the downstream
	// fulfill amount.
	//
	// Necessary because our test utils calculate the expected fee for an intermediate node based on
	// the amount was claimed in their downstream peer's fulfill, but blinded intermediate nodes
	// calculate their fee based on the inbound amount from their upstream peer, causing a difference
	// in rounding.
	pub allow_1_msat_fee_overpay: bool,
}

impl<'a, 'b, 'c, 'd> ClaimAlongRouteArgs<'a, 'b, 'c, 'd> {
	pub fn new(
		origin_node: &'a Node<'b, 'c, 'd>, expected_paths: &'a [&'a [&'a Node<'b, 'c, 'd>]],
		payment_preimage: PaymentPreimage,
	) -> Self {
		Self {
			origin_node,
			expected_paths,
			expected_extra_fees: vec![0; expected_paths.len()],
			expected_extra_total_fees_msat: 0,
			expected_min_htlc_overpay: vec![0; expected_paths.len()],
			skip_last: false,
			payment_preimage,
			allow_1_msat_fee_overpay: false,
			custom_tlvs: vec![],
		}
	}
	pub fn skip_last(mut self, skip_last: bool) -> Self {
		self.skip_last = skip_last;
		self
	}
	pub fn with_expected_extra_fees(mut self, extra_fees: Vec<u32>) -> Self {
		self.expected_extra_fees = extra_fees;
		self
	}
	pub fn with_expected_extra_total_fees_msat(mut self, extra_total_fees: u64) -> Self {
		self.expected_extra_total_fees_msat = extra_total_fees;
		self
	}
	pub fn with_expected_min_htlc_overpay(mut self, extra_fees: Vec<u32>) -> Self {
		self.expected_min_htlc_overpay = extra_fees;
		self
	}
	pub fn allow_1_msat_fee_overpay(mut self) -> Self {
		self.allow_1_msat_fee_overpay = true;
		self
	}
	pub fn with_custom_tlvs(mut self, custom_tlvs: Vec<(u64, Vec<u8>)>) -> Self {
		self.custom_tlvs = custom_tlvs;
		self
	}
}

macro_rules! single_fulfill_commit_from_ev {
	($ev: expr) => {
		match $ev {
			&MessageSendEvent::UpdateHTLCs {
				ref node_id,
				ref channel_id,
				updates:
					msgs::CommitmentUpdate {
						ref update_add_htlcs,
						ref update_fulfill_htlcs,
						ref update_fail_htlcs,
						ref update_fail_malformed_htlcs,
						ref update_fee,
						ref commitment_signed,
					},
			} => {
				assert!(update_add_htlcs.is_empty());
				assert_eq!(update_fulfill_htlcs.len(), 1);
				assert!(update_fail_htlcs.is_empty());
				assert!(update_fail_malformed_htlcs.is_empty());
				assert!(update_fee.is_none());
				assert!(commitment_signed.iter().all(|cs| cs.channel_id == *channel_id));
				((update_fulfill_htlcs[0].clone(), commitment_signed.clone()), node_id.clone())
			},
			_ => panic!("Unexpected event"),
		}
	};
}

pub fn pass_claimed_payment_along_route(args: ClaimAlongRouteArgs) -> u64 {
	let claim_event = args.expected_paths[0].last().unwrap().node.get_and_clear_pending_events();
	assert_eq!(claim_event.len(), 1, "{claim_event:?}");
	#[allow(unused)]
	let mut fwd_amt_msat = 0;
	match claim_event[0] {
		Event::PaymentClaimed {
			purpose:
				PaymentPurpose::SpontaneousPayment(preimage)
				| PaymentPurpose::Bolt11InvoicePayment { payment_preimage: Some(preimage), .. }
				| PaymentPurpose::Bolt12OfferPayment { payment_preimage: Some(preimage), .. }
				| PaymentPurpose::Bolt12RefundPayment { payment_preimage: Some(preimage), .. },
			amount_msat,
			ref htlcs,
			ref onion_fields,
			..
		} => {
			assert_eq!(preimage, args.payment_preimage);
			assert_eq!(htlcs.len(), args.expected_paths.len()); // One per path.
			assert_eq!(htlcs.iter().map(|h| h.value_msat).sum::<u64>(), amount_msat);
			assert_eq!(onion_fields.as_ref().unwrap().custom_tlvs, args.custom_tlvs);
			check_claimed_htlcs_match_route(args.origin_node, args.expected_paths, htlcs);
			fwd_amt_msat = amount_msat;
		},
		Event::PaymentClaimed {
			purpose:
				PaymentPurpose::Bolt11InvoicePayment { .. }
				| PaymentPurpose::Bolt12OfferPayment { .. }
				| PaymentPurpose::Bolt12RefundPayment { .. },
			payment_hash,
			amount_msat,
			ref htlcs,
			ref onion_fields,
			..
		} => {
			assert_eq!(&payment_hash.0, &Sha256::hash(&args.payment_preimage.0)[..]);
			assert_eq!(htlcs.len(), args.expected_paths.len()); // One per path.
			assert_eq!(htlcs.iter().map(|h| h.value_msat).sum::<u64>(), amount_msat);
			assert_eq!(onion_fields.as_ref().unwrap().custom_tlvs, args.custom_tlvs);
			check_claimed_htlcs_match_route(args.origin_node, args.expected_paths, htlcs);
			fwd_amt_msat = amount_msat;
		},
		_ => panic!(),
	}

	check_added_monitors(args.expected_paths[0].last().unwrap(), args.expected_paths.len());

	let mut per_path_msgs: Vec<(
		(msgs::UpdateFulfillHTLC, Vec<msgs::CommitmentSigned>),
		PublicKey,
	)> = Vec::with_capacity(args.expected_paths.len());
	let mut events = args.expected_paths[0].last().unwrap().node.get_and_clear_pending_msg_events();
	assert_eq!(events.len(), args.expected_paths.len());

	if events.len() == 1 {
		per_path_msgs.push(single_fulfill_commit_from_ev!(&events[0]));
	} else {
		for expected_path in args.expected_paths.iter() {
			// For MPP payments, we want the fulfill message from the payee to the penultimate hop in the
			// path.
			let penultimate_hop_node_id = expected_path
				.iter()
				.rev()
				.skip(1)
				.next()
				.map(|n| n.node.get_our_node_id())
				.unwrap_or(args.origin_node.node.get_our_node_id());
			let ev = remove_first_msg_event_to_node(&penultimate_hop_node_id, &mut events);
			per_path_msgs.push(single_fulfill_commit_from_ev!(&ev));
		}
	}

	pass_claimed_payment_along_route_from_ev(fwd_amt_msat, per_path_msgs, args)
}

pub fn pass_claimed_payment_along_route_from_ev(
	each_htlc_claim_amt_msat: u64,
	mut per_path_msgs: Vec<((msgs::UpdateFulfillHTLC, Vec<msgs::CommitmentSigned>), PublicKey)>,
	args: ClaimAlongRouteArgs,
) -> u64 {
	let ClaimAlongRouteArgs {
		origin_node,
		expected_paths,
		expected_extra_fees,
		expected_min_htlc_overpay,
		skip_last,
		payment_preimage: our_payment_preimage,
		allow_1_msat_fee_overpay,
		..
	} = args;

	let mut fwd_amt_msat = each_htlc_claim_amt_msat;
	let mut expected_total_fee_msat = 0;

	for (i, (expected_route, (path_msgs, next_hop))) in
		expected_paths.iter().zip(per_path_msgs.drain(..)).enumerate()
	{
		let mut next_msgs = Some(path_msgs);
		let mut expected_next_node = next_hop;

		macro_rules! last_update_fulfill_dance {
			($node: expr, $prev_node: expr) => {{
				$node.node.handle_update_fulfill_htlc(
					$prev_node.node.get_our_node_id(),
					next_msgs.as_ref().unwrap().0.clone(),
				);
				check_added_monitors(&$node, 0);
				assert!($node.node.get_and_clear_pending_msg_events().is_empty());
				let commitment = &next_msgs.as_ref().unwrap().1;
				do_commitment_signed_dance($node, $prev_node, commitment, false, false);
			}};
		}
		macro_rules! mid_update_fulfill_dance {
			($idx: expr, $node: expr, $prev_node: expr, $next_node: expr, $new_msgs: expr) => {{
				$node.node.handle_update_fulfill_htlc(
					$prev_node.node.get_our_node_id(),
					next_msgs.as_ref().unwrap().0.clone(),
				);
				let mut fee = {
					let (base_fee, prop_fee) = {
						let per_peer_state = $node.node.per_peer_state.read().unwrap();
						let peer_state = per_peer_state
							.get(&$prev_node.node.get_our_node_id())
							.unwrap()
							.lock()
							.unwrap();
						let channel = peer_state
							.channel_by_id
							.get(&next_msgs.as_ref().unwrap().0.channel_id)
							.unwrap();
						if let Some(prev_config) = channel.context().prev_config() {
							(
								prev_config.forwarding_fee_base_msat as u64,
								prev_config.forwarding_fee_proportional_millionths as u64,
							)
						} else {
							(
								channel.context().config().forwarding_fee_base_msat as u64,
								channel.context().config().forwarding_fee_proportional_millionths
									as u64,
							)
						}
					};
					((fwd_amt_msat * prop_fee / 1_000_000) + base_fee) as u32
				};

				let mut expected_extra_fee = None;
				if $idx == 1 {
					fee += expected_extra_fees[i];
					fee += expected_min_htlc_overpay[i];
					expected_extra_fee = if expected_extra_fees[i] > 0 {
						Some(expected_extra_fees[i] as u64)
					} else {
						None
					};
				}
				let mut events = $node.node.get_and_clear_pending_events();
				assert_eq!(events.len(), 1);
				let actual_fee = expect_payment_forwarded(
					events.pop().unwrap(),
					*$node,
					$next_node,
					$prev_node,
					Some(fee as u64),
					expected_extra_fee,
					false,
					false,
					allow_1_msat_fee_overpay,
				);
				expected_total_fee_msat += actual_fee.unwrap();
				fwd_amt_msat += actual_fee.unwrap();
				check_added_monitors(&$node, 1);
				let new_next_msgs = if $new_msgs {
					let events = $node.node.get_and_clear_pending_msg_events();
					assert_eq!(events.len(), 1);
					let (res, nexthop) = single_fulfill_commit_from_ev!(&events[0]);
					expected_next_node = nexthop;
					Some(res)
				} else {
					assert!($node.node.get_and_clear_pending_msg_events().is_empty());
					None
				};
				let commitment = &next_msgs.as_ref().unwrap().1;
				do_commitment_signed_dance($node, $prev_node, commitment, false, false);
				next_msgs = new_next_msgs;
			}};
		}

		let mut prev_node = expected_route.last().unwrap();
		for (idx, node) in expected_route.iter().rev().enumerate().skip(1) {
			assert_eq!(expected_next_node, node.node.get_our_node_id());
			let update_next_msgs = !skip_last || idx != expected_route.len() - 1;
			if next_msgs.is_some() {
				// Since we are traversing in reverse, next_node is actually the previous node
				let next_node: &Node;
				if idx == expected_route.len() - 1 {
					next_node = origin_node;
				} else {
					next_node = expected_route[expected_route.len() - 1 - idx - 1];
				}
				mid_update_fulfill_dance!(idx, node, prev_node, next_node, update_next_msgs);
			} else {
				assert!(!update_next_msgs);
				assert!(node.node.get_and_clear_pending_msg_events().is_empty());
			}
			if !skip_last && idx == expected_route.len() - 1 {
				assert_eq!(expected_next_node, origin_node.node.get_our_node_id());
			}

			prev_node = node;
		}

		if !skip_last {
			last_update_fulfill_dance!(origin_node, expected_route.first().unwrap());
		}
	}

	// Ensure that claim_funds is idempotent.
	expected_paths[0].last().unwrap().node.claim_funds(our_payment_preimage);
	assert!(expected_paths[0].last().unwrap().node.get_and_clear_pending_msg_events().is_empty());
	check_added_monitors(&expected_paths[0].last().unwrap(), 0);

	expected_total_fee_msat
}

pub fn claim_payment_along_route(
	args: ClaimAlongRouteArgs,
) -> (Option<PaidBolt12Invoice>, Vec<Event>) {
	let ClaimAlongRouteArgs {
		origin_node,
		payment_preimage,
		skip_last,
		expected_extra_total_fees_msat,
		..
	} = args;

	let expected_total_fee_msat =
		do_claim_payment_along_route(args) + expected_extra_total_fees_msat;

	if !skip_last {
		expect_payment_sent!(origin_node, payment_preimage, Some(expected_total_fee_msat))
	} else {
		(None, Vec::new())
	}
}

pub fn claim_payment<'a, 'b, 'c>(
	origin_node: &Node<'a, 'b, 'c>, expected_route: &[&Node<'a, 'b, 'c>],
	our_payment_preimage: PaymentPreimage,
) -> Option<PaidBolt12Invoice> {
	claim_payment_along_route(ClaimAlongRouteArgs::new(
		origin_node,
		&[expected_route],
		our_payment_preimage,
	))
	.0
}

pub const TEST_FINAL_CLTV: u32 = 70;

pub fn route_payment<'a, 'b, 'c>(
	origin_node: &Node<'a, 'b, 'c>, expected_route: &[&Node<'a, 'b, 'c>], recv_value: u64,
) -> (PaymentPreimage, PaymentHash, PaymentSecret, PaymentId) {
	let payment_params = PaymentParameters::from_node_id(
		expected_route.last().unwrap().node.get_our_node_id(),
		TEST_FINAL_CLTV,
	)
	.with_bolt11_features(expected_route.last().unwrap().node.bolt11_invoice_features())
	.unwrap();
	let route_params = RouteParameters::from_payment_params_and_value(payment_params, recv_value);
	let route = get_route(origin_node, &route_params).unwrap();
	assert_eq!(route.paths.len(), 1);
	assert_eq!(route.paths[0].hops.len(), expected_route.len());
	for (node, hop) in expected_route.iter().zip(route.paths[0].hops.iter()) {
		assert_eq!(hop.pubkey, node.node.get_our_node_id());
	}

	let res = send_along_route(origin_node, route, expected_route, recv_value);
	(res.0, res.1, res.2, res.3)
}

pub fn send_payment<'a, 'b, 'c>(
	origin: &Node<'a, 'b, 'c>, expected_route: &[&Node<'a, 'b, 'c>], recv_value: u64,
) -> (PaymentPreimage, PaymentHash, PaymentSecret, PaymentId) {
	let res = route_payment(&origin, expected_route, recv_value);
	claim_payment(&origin, expected_route, res.0);
	res
}

pub fn fail_payment_along_route<'a, 'b, 'c>(
	origin_node: &Node<'a, 'b, 'c>, expected_paths: &[&[&Node<'a, 'b, 'c>]], skip_last: bool,
	our_payment_hash: PaymentHash,
) {
	for path in expected_paths.iter() {
		assert_eq!(
			path.last().unwrap().node.get_our_node_id(),
			expected_paths[0].last().unwrap().node.get_our_node_id()
		);
	}
	expected_paths[0].last().unwrap().node.fail_htlc_backwards(&our_payment_hash);
	let expected_destinations: Vec<HTLCHandlingFailureType> =
		repeat(HTLCHandlingFailureType::Receive { payment_hash: our_payment_hash })
			.take(expected_paths.len())
			.collect();
	expect_and_process_pending_htlcs_and_htlc_handling_failed(
		&expected_paths[0].last().unwrap(),
		&expected_destinations,
	);

	pass_failed_payment_back(
		origin_node,
		expected_paths,
		skip_last,
		our_payment_hash,
		PaymentFailureReason::RecipientRejected,
	);
}

pub fn pass_failed_payment_back<'a, 'b, 'c>(
	origin_node: &Node<'a, 'b, 'c>, expected_paths_slice: &[&[&Node<'a, 'b, 'c>]], skip_last: bool,
	our_payment_hash: PaymentHash, expected_fail_reason: PaymentFailureReason,
) {
	let mut expected_paths: Vec<_> = expected_paths_slice.iter().collect();
	check_added_monitors(&expected_paths[0].last().unwrap(), expected_paths.len());

	let mut per_path_msgs: Vec<((msgs::UpdateFailHTLC, Vec<msgs::CommitmentSigned>), PublicKey)> =
		Vec::with_capacity(expected_paths.len());
	let events = expected_paths[0].last().unwrap().node.get_and_clear_pending_msg_events();
	assert_eq!(events.len(), expected_paths.len());
	for ev in events.iter() {
		let (update_fail, commitment_signed, node_id) = match ev {
			&MessageSendEvent::UpdateHTLCs {
				ref node_id,
				ref channel_id,
				updates:
					msgs::CommitmentUpdate {
						ref update_add_htlcs,
						ref update_fulfill_htlcs,
						ref update_fail_htlcs,
						ref update_fail_malformed_htlcs,
						ref update_fee,
						ref commitment_signed,
					},
			} => {
				assert!(update_add_htlcs.is_empty());
				assert!(update_fulfill_htlcs.is_empty());
				assert_eq!(update_fail_htlcs.len(), 1);
				assert!(update_fail_malformed_htlcs.is_empty());
				assert!(update_fee.is_none());
				assert!(commitment_signed.iter().all(|cs| cs.channel_id == *channel_id));
				(update_fail_htlcs[0].clone(), commitment_signed.clone(), node_id.clone())
			},
			_ => panic!("Unexpected event"),
		};
		per_path_msgs.push(((update_fail, commitment_signed), node_id));
	}
	per_path_msgs.sort_unstable_by(|(_, node_id_a), (_, node_id_b)| node_id_a.cmp(node_id_b));
	expected_paths.sort_unstable_by(|path_a, path_b| {
		path_a[path_a.len() - 2]
			.node
			.get_our_node_id()
			.cmp(&path_b[path_b.len() - 2].node.get_our_node_id())
	});

	for (i, (expected_route, (path_msgs, next_hop))) in
		expected_paths.iter().zip(per_path_msgs.drain(..)).enumerate()
	{
		let mut next_msgs = Some(path_msgs);
		let mut expected_next_node = next_hop;
		let mut prev_node = expected_route.last().unwrap();

		for (idx, node) in expected_route.iter().rev().enumerate().skip(1) {
			assert_eq!(expected_next_node, node.node.get_our_node_id());
			let update_next_node = !skip_last || idx != expected_route.len() - 1;
			if next_msgs.is_some() {
				node.node.handle_update_fail_htlc(
					prev_node.node.get_our_node_id(),
					&next_msgs.as_ref().unwrap().0,
				);
				let commitment = &next_msgs.as_ref().unwrap().1;
				do_commitment_signed_dance(node, prev_node, commitment, update_next_node, false);
				if !update_next_node {
					expect_and_process_pending_htlcs_and_htlc_handling_failed(
						&node,
						&[HTLCHandlingFailureType::Forward {
							node_id: Some(prev_node.node.get_our_node_id()),
							channel_id: next_msgs.as_ref().unwrap().0.channel_id,
						}],
					);
				}
			}
			let events = node.node.get_and_clear_pending_msg_events();
			if update_next_node {
				assert_eq!(events.len(), 1);
				match events[0] {
					MessageSendEvent::UpdateHTLCs {
						ref node_id,
						ref channel_id,
						updates:
							msgs::CommitmentUpdate {
								ref update_add_htlcs,
								ref update_fulfill_htlcs,
								ref update_fail_htlcs,
								ref update_fail_malformed_htlcs,
								ref update_fee,
								ref commitment_signed,
							},
					} => {
						assert!(update_add_htlcs.is_empty());
						assert!(update_fulfill_htlcs.is_empty());
						assert_eq!(update_fail_htlcs.len(), 1);
						assert!(update_fail_malformed_htlcs.is_empty());
						assert!(update_fee.is_none());
						assert!(commitment_signed.iter().all(|cs| cs.channel_id == *channel_id));
						expected_next_node = node_id.clone();
						next_msgs = Some((update_fail_htlcs[0].clone(), commitment_signed.clone()));
					},
					_ => panic!("Unexpected event"),
				}
			} else {
				assert!(events.is_empty());
			}
			if !skip_last && idx == expected_route.len() - 1 {
				assert_eq!(expected_next_node, origin_node.node.get_our_node_id());
			}

			prev_node = node;
		}

		if !skip_last {
			let prev_node = expected_route.first().unwrap();
			origin_node.node.handle_update_fail_htlc(
				prev_node.node.get_our_node_id(),
				&next_msgs.as_ref().unwrap().0,
			);
			check_added_monitors(&origin_node, 0);
			assert!(origin_node.node.get_and_clear_pending_msg_events().is_empty());
			let commitment = &next_msgs.as_ref().unwrap().1;
			do_commitment_signed_dance(origin_node, prev_node, commitment, false, false);
			let events = origin_node.node.get_and_clear_pending_events();
			if i == expected_paths.len() - 1 {
				assert_eq!(events.len(), 2);
			} else {
				assert_eq!(events.len(), 1);
			}

			let expected_payment_id = match events[0] {
				Event::PaymentPathFailed {
					payment_hash,
					payment_failed_permanently,
					ref path,
					ref payment_id,
					..
				} => {
					assert_eq!(payment_hash, our_payment_hash);
					let expected_payment_failed_permanently = match expected_fail_reason {
						PaymentFailureReason::RecipientRejected => true,
						_ => false,
					};
					assert!(
						payment_failed_permanently == expected_payment_failed_permanently,
						"expected payment_failed_permanently of {}, got {}",
						expected_payment_failed_permanently,
						payment_failed_permanently
					);
					for (idx, hop) in expected_route.iter().enumerate() {
						assert_eq!(hop.node.get_our_node_id(), path.hops[idx].pubkey);
					}
					payment_id.unwrap()
				},
				_ => panic!("Unexpected event"),
			};
			if i == expected_paths.len() - 1 {
				match events[1] {
					Event::PaymentFailed { ref payment_hash, ref payment_id, ref reason } => {
						assert_eq!(
							*payment_hash,
							Some(our_payment_hash),
							"unexpected second payment_hash"
						);
						assert_eq!(*payment_id, expected_payment_id);
						assert_eq!(reason.unwrap(), expected_fail_reason);
					},
					_ => panic!("Unexpected second event"),
				}
			}
		}
	}

	// Ensure that fail_htlc_backwards is idempotent.
	expected_paths[0].last().unwrap().node.fail_htlc_backwards(&our_payment_hash);
	let pending_events = expected_paths[0].last().unwrap().node.get_and_clear_pending_events();
	assert!(
		pending_events.is_empty(),
		"expected empty pending_events on redundant call to fail_htlc_backwards, got {:?}",
		pending_events
	);
	assert!(expected_paths[0].last().unwrap().node.get_and_clear_pending_msg_events().is_empty());
	check_added_monitors(&expected_paths[0].last().unwrap(), 0);
}

pub fn fail_payment<'a, 'b, 'c>(
	origin_node: &Node<'a, 'b, 'c>, expected_path: &[&Node<'a, 'b, 'c>],
	our_payment_hash: PaymentHash,
) {
	fail_payment_along_route(origin_node, &[&expected_path[..]], false, our_payment_hash);
}

pub fn create_chanmon_cfgs(node_count: usize) -> Vec<TestChanMonCfg> {
	create_chanmon_cfgs_with_legacy_keys(node_count, None)
}

pub fn create_chanmon_cfgs_with_legacy_keys(
	node_count: usize, predefined_keys_ids: Option<Vec<[u8; 32]>>,
) -> Vec<TestChanMonCfg> {
	let mut chan_mon_cfgs = Vec::new();
	for i in 0..node_count {
		let tx_broadcaster = test_utils::TestBroadcaster::new(Network::Testnet);
		let fee_estimator = test_utils::TestFeeEstimator::new(253);
		let chain_source = test_utils::TestChainSource::new(Network::Testnet);
		let logger = test_utils::TestLogger::with_id(format!("node {}", i));
		let persister = test_utils::TestPersister::new();
		let seed = [i as u8; 32];
		let keys_manager = if predefined_keys_ids.is_some() {
			// Use legacy (V1) remote_key derivation for tests using legacy key sets.
			test_utils::TestKeysInterface::with_v1_remote_key_derivation(&seed, Network::Testnet)
		} else {
			test_utils::TestKeysInterface::new(&seed, Network::Testnet)
		};
		let scorer = RwLock::new(test_utils::TestScorer::new());

		// Set predefined keys_id if provided
		if let Some(keys_ids) = &predefined_keys_ids {
			if let Some(keys_id) = keys_ids.get(i) {
				keys_manager.set_next_keys_id(*keys_id);
			}
		}

		chan_mon_cfgs.push(TestChanMonCfg {
			tx_broadcaster,
			fee_estimator,
			chain_source,
			logger,
			persister,
			keys_manager,
			scorer,
		});
	}

	chan_mon_cfgs
}

fn create_node_cfgs_internal<'a, F>(
	node_count: usize, chanmon_cfgs: &'a Vec<TestChanMonCfg>,
	persisters: Vec<&'a impl test_utils::SyncPersist>, message_router_constructor: F,
) -> Vec<NodeCfg<'a>>
where
	F: Fn(
		Arc<NetworkGraph<&'a TestLogger>>,
		&'a TestKeysInterface,
	) -> test_utils::TestMessageRouter<'a>,
{
	create_node_cfgs_internal_deferred(
		node_count,
		chanmon_cfgs,
		persisters,
		message_router_constructor,
		false,
	)
}

fn create_node_cfgs_internal_deferred<'a, F>(
	node_count: usize, chanmon_cfgs: &'a Vec<TestChanMonCfg>,
	persisters: Vec<&'a impl test_utils::SyncPersist>, message_router_constructor: F,
	deferred: bool,
) -> Vec<NodeCfg<'a>>
where
	F: Fn(
		Arc<NetworkGraph<&'a TestLogger>>,
		&'a TestKeysInterface,
	) -> test_utils::TestMessageRouter<'a>,
{
	let mut nodes = Vec::new();

	for i in 0..node_count {
		let cfg = &chanmon_cfgs[i];
		let network_graph = Arc::new(NetworkGraph::new(Network::Testnet, &cfg.logger));
		let chain_monitor = if deferred {
			test_utils::TestChainMonitor::new_deferred(
				Some(&cfg.chain_source),
				&cfg.tx_broadcaster,
				&cfg.logger,
				&cfg.fee_estimator,
				persisters[i],
				&cfg.keys_manager,
			)
		} else {
			test_utils::TestChainMonitor::new(
				Some(&cfg.chain_source),
				&cfg.tx_broadcaster,
				&cfg.logger,
				&cfg.fee_estimator,
				persisters[i],
				&cfg.keys_manager,
			)
		};

		let seed = [i as u8; 32];
		nodes.push(NodeCfg {
			chain_source: &cfg.chain_source,
			logger: &cfg.logger,
			tx_broadcaster: &cfg.tx_broadcaster,
			fee_estimator: &cfg.fee_estimator,
			router: test_utils::TestRouter::new(
				Arc::clone(&network_graph),
				&cfg.logger,
				&cfg.scorer,
			),
			message_router: message_router_constructor(
				Arc::clone(&network_graph),
				&cfg.keys_manager,
			),
			chain_monitor,
			keys_manager: &cfg.keys_manager,
			node_seed: seed,
			network_graph,
			override_init_features: Rc::new(RefCell::new(None)),
		});
	}

	nodes
}

pub fn create_node_cfgs<'a>(
	node_count: usize, chanmon_cfgs: &'a Vec<TestChanMonCfg>,
) -> Vec<NodeCfg<'a>> {
	let persisters = chanmon_cfgs.iter().map(|c| &c.persister).collect();
	create_node_cfgs_internal(
		node_count,
		chanmon_cfgs,
		persisters,
		test_utils::TestMessageRouter::new_default,
	)
}

pub fn create_node_cfgs_deferred<'a>(
	node_count: usize, chanmon_cfgs: &'a Vec<TestChanMonCfg>,
) -> Vec<NodeCfg<'a>> {
	let persisters = chanmon_cfgs.iter().map(|c| &c.persister).collect();
	create_node_cfgs_internal_deferred(
		node_count,
		chanmon_cfgs,
		persisters,
		test_utils::TestMessageRouter::new_default,
		true,
	)
}

pub fn create_node_cfgs_with_persisters<'a>(
	node_count: usize, chanmon_cfgs: &'a Vec<TestChanMonCfg>,
	persisters: Vec<&'a impl test_utils::SyncPersist>,
) -> Vec<NodeCfg<'a>> {
	create_node_cfgs_internal(
		node_count,
		chanmon_cfgs,
		persisters,
		test_utils::TestMessageRouter::new_default,
	)
}

pub fn create_node_cfgs_with_node_id_message_router<'a>(
	node_count: usize, chanmon_cfgs: &'a Vec<TestChanMonCfg>,
) -> Vec<NodeCfg<'a>> {
	let persisters = chanmon_cfgs.iter().map(|c| &c.persister).collect();
	create_node_cfgs_internal(
		node_count,
		chanmon_cfgs,
		persisters,
		test_utils::TestMessageRouter::new_node_id_router,
	)
}

pub fn test_legacy_channel_config() -> UserConfig {
	let mut default_config = UserConfig::default();
	default_config.channel_handshake_config.negotiate_anchors_zero_fee_htlc_tx = false;
	// Set cltv_expiry_delta slightly lower to keep the final CLTV values inside one byte in our
	// tests so that our script-length checks don't fail (see ACCEPTED_HTLC_SCRIPT_WEIGHT).
	default_config.channel_config.cltv_expiry_delta = MIN_CLTV_EXPIRY_DELTA;
	default_config.channel_handshake_config.announce_for_forwarding = true;
	default_config.channel_handshake_limits.force_announced_channel_preference = false;
	// When most of our tests were written, the default HTLC minimum was fixed at 1000.
	// It now defaults to 1, so we simply set it to the expected value here.
	default_config.channel_handshake_config.our_htlc_minimum_msat = 1000;
	// When most of our tests were written, we didn't have the notion of a `max_dust_htlc_exposure_msat`,
	// to avoid interfering with tests we bump it to 50_000_000 msat (assuming the default test
	// feerate of 253).
	default_config.channel_config.max_dust_htlc_exposure =
		MaxDustHTLCExposure::FeeRateMultiplier(50_000_000 / 253);
	default_config.reject_inbound_splices = false;
	default_config
}

pub fn test_default_channel_config() -> UserConfig {
	let mut config = test_legacy_channel_config();
	config.channel_handshake_config.negotiate_anchors_zero_fee_htlc_tx = true;
	config
}

pub fn create_node_chanmgrs<'a, 'b>(
	node_count: usize, cfgs: &'a Vec<NodeCfg<'b>>, node_config: &[Option<UserConfig>],
) -> Vec<
	ChannelManager<
		&'a TestChainMonitor<'b>,
		&'b test_utils::TestBroadcaster,
		&'a test_utils::TestKeysInterface,
		&'a test_utils::TestKeysInterface,
		&'a test_utils::TestKeysInterface,
		&'b test_utils::TestFeeEstimator,
		&'a test_utils::TestRouter<'b>,
		&'a test_utils::TestMessageRouter<'b>,
		&'b test_utils::TestLogger,
	>,
> {
	let mut chanmgrs = Vec::new();
	for i in 0..node_count {
		let network = Network::Testnet;
		let genesis_block = bitcoin::constants::genesis_block(network);
		let params = ChainParameters { network, best_block: BestBlock::from_network(network) };
		let node = ChannelManager::new(
			cfgs[i].fee_estimator,
			&cfgs[i].chain_monitor,
			cfgs[i].tx_broadcaster,
			&cfgs[i].router,
			&cfgs[i].message_router,
			cfgs[i].logger,
			cfgs[i].keys_manager,
			cfgs[i].keys_manager,
			cfgs[i].keys_manager,
			if node_config[i].is_some() {
				node_config[i].clone().unwrap()
			} else {
				test_default_channel_config()
			},
			params,
			genesis_block.header.time,
		);
		chanmgrs.push(node);
	}

	chanmgrs
}

pub fn create_network<'a, 'b: 'a, 'c: 'b>(
	node_count: usize, cfgs: &'b Vec<NodeCfg<'c>>,
	chan_mgrs: &'a Vec<
		ChannelManager<
			&'b TestChainMonitor<'c>,
			&'c test_utils::TestBroadcaster,
			&'b test_utils::TestKeysInterface,
			&'b test_utils::TestKeysInterface,
			&'b test_utils::TestKeysInterface,
			&'c test_utils::TestFeeEstimator,
			&'c test_utils::TestRouter,
			&'c test_utils::TestMessageRouter,
			&'c test_utils::TestLogger,
		>,
	>,
) -> Vec<Node<'a, 'b, 'c>> {
	let mut nodes = Vec::new();
	let chan_count = Rc::new(RefCell::new(0));
	let payment_count = Rc::new(RefCell::new(0));

	let connect_style = Rc::new(RefCell::new(match std::env::var("LDK_TEST_CONNECT_STYLE") {
		Ok(val) => match val.as_str() {
			"BEST_BLOCK_FIRST" => ConnectStyle::BestBlockFirst,
			"BEST_BLOCK_FIRST_SKIPPING_BLOCKS" => ConnectStyle::BestBlockFirstSkippingBlocks,
			"BEST_BLOCK_FIRST_REORGS_ONLY_TIP" => ConnectStyle::BestBlockFirstReorgsOnlyTip,
			"TRANSACTIONS_FIRST" => ConnectStyle::TransactionsFirst,
			"TRANSACTIONS_FIRST_SKIPPING_BLOCKS" => ConnectStyle::TransactionsFirstSkippingBlocks,
			"TRANSACTIONS_DUPLICATIVELY_FIRST_SKIPPING_BLOCKS" => {
				ConnectStyle::TransactionsDuplicativelyFirstSkippingBlocks
			},
			"HIGHLY_REDUNDANT_TRANSACTIONS_FIRST_SKIPPING_BLOCKS" => {
				ConnectStyle::HighlyRedundantTransactionsFirstSkippingBlocks
			},
			"TRANSACTIONS_FIRST_REORGS_ONLY_TIP" => ConnectStyle::TransactionsFirstReorgsOnlyTip,
			"FULL_BLOCK_VIA_LISTEN" => ConnectStyle::FullBlockViaListen,
			"FULL_BLOCK_DISCONNECTIONS_SKIPPING_VIA_LISTEN" => {
				ConnectStyle::FullBlockDisconnectionsSkippingViaListen
			},
			_ => panic!("Unknown ConnectStyle '{}'", val),
		},
		Err(_) => ConnectStyle::random_style(),
	}));

	for i in 0..node_count {
		let dedicated_entropy = DedicatedEntropy(RandomBytes::new([i as u8; 32]));
		#[cfg(feature = "dnssec")]
		let onion_messenger = OnionMessenger::new_with_offline_peer_interception(
			dedicated_entropy,
			cfgs[i].keys_manager,
			cfgs[i].logger,
			&chan_mgrs[i],
			&cfgs[i].message_router,
			&chan_mgrs[i],
			&chan_mgrs[i],
			&chan_mgrs[i],
			IgnoringMessageHandler {},
		);
		#[cfg(not(feature = "dnssec"))]
		let onion_messenger = OnionMessenger::new_with_offline_peer_interception(
			dedicated_entropy,
			cfgs[i].keys_manager,
			cfgs[i].logger,
			&chan_mgrs[i],
			&cfgs[i].message_router,
			&chan_mgrs[i],
			&chan_mgrs[i],
			IgnoringMessageHandler {},
			IgnoringMessageHandler {},
		);
		let gossip_sync = P2PGossipSync::new(cfgs[i].network_graph.as_ref(), None, cfgs[i].logger);
		let wallet_source = Arc::new(test_utils::TestWalletSource::new(
			SecretKey::from_slice(&[i as u8 + 1; 32]).unwrap(),
		));
		let wallet = Arc::new(WalletSync::new(Arc::clone(&wallet_source), cfgs[i].logger));
		nodes.push(Node {
			chain_source: cfgs[i].chain_source,
			tx_broadcaster: cfgs[i].tx_broadcaster,
			fee_estimator: cfgs[i].fee_estimator,
			router: &cfgs[i].router,
			message_router: &cfgs[i].message_router,
			chain_monitor: &cfgs[i].chain_monitor,
			keys_manager: &cfgs[i].keys_manager,
			node: &chan_mgrs[i],
			network_graph: cfgs[i].network_graph.as_ref(),
			gossip_sync,
			node_seed: cfgs[i].node_seed,
			onion_messenger,
			network_chan_count: Rc::clone(&chan_count),
			network_payment_count: Rc::clone(&payment_count),
			logger: cfgs[i].logger,
			blocks: Arc::clone(&cfgs[i].tx_broadcaster.blocks),
			connect_style: Rc::clone(&connect_style),
			override_init_features: Rc::clone(&cfgs[i].override_init_features),
			wallet_source: Arc::clone(&wallet_source),
			bump_tx_handler: BumpTransactionEventHandlerSync::new(
				cfgs[i].tx_broadcaster,
				wallet,
				&cfgs[i].keys_manager,
				cfgs[i].logger,
			),
		})
	}

	for i in 0..node_count {
		for j in (i + 1)..node_count {
			connect_nodes(&nodes[i], &nodes[j]);
		}
	}

	nodes
}

pub fn connect_nodes<'a, 'b: 'a, 'c: 'b>(node_a: &Node<'a, 'b, 'c>, node_b: &Node<'a, 'b, 'c>) {
	let node_id_a = node_a.node.get_our_node_id();
	let node_id_b = node_b.node.get_our_node_id();

	let init_a = msgs::Init {
		features: node_a.init_features(node_id_b),
		networks: None,
		remote_network_address: None,
	};
	let init_b = msgs::Init {
		features: node_b.init_features(node_id_a),
		networks: None,
		remote_network_address: None,
	};

	node_a.node.peer_connected(node_id_b, &init_b, true).unwrap();
	node_b.node.peer_connected(node_id_a, &init_a, false).unwrap();
	node_a.onion_messenger.peer_connected(node_id_b, &init_b, true).unwrap();
	node_b.onion_messenger.peer_connected(node_id_a, &init_a, false).unwrap();
}

pub fn connect_dummy_node<'a, 'b: 'a, 'c: 'b>(node: &Node<'a, 'b, 'c>) {
	let node_id_dummy = PublicKey::from_slice(&[2; 33]).unwrap();

	let mut dummy_init_features = InitFeatures::empty();
	dummy_init_features.set_static_remote_key_required();

	let init_dummy =
		msgs::Init { features: dummy_init_features, networks: None, remote_network_address: None };

	node.node.peer_connected(node_id_dummy, &init_dummy, true).unwrap();
	node.onion_messenger.peer_connected(node_id_dummy, &init_dummy, true).unwrap();
}

pub fn disconnect_dummy_node<'a, 'b: 'a, 'c: 'b>(node: &Node<'a, 'b, 'c>) {
	let node_id_dummy = PublicKey::from_slice(&[2; 33]).unwrap();
	node.node.peer_disconnected(node_id_dummy);
	node.onion_messenger.peer_disconnected(node_id_dummy);
}

// Note that the following only works for CLTV values up to 128
pub const ACCEPTED_HTLC_SCRIPT_WEIGHT: usize = 137; // Here we have a diff due to HTLC CLTV expiry being < 2^15 in test
pub const ACCEPTED_HTLC_SCRIPT_WEIGHT_ANCHORS: usize = 140; // Here we have a diff due to HTLC CLTV expiry being < 2^15 in test

#[derive(PartialEq)]
pub enum HTLCType {
	NONE,
	TIMEOUT,
	SUCCESS,
}
/// Tests that the given node has broadcast transactions for the given Channel
///
/// First checks that the latest holder commitment tx has been broadcast, unless an explicit
/// commitment_tx is provided, which may be used to test that a remote commitment tx was
/// broadcast and the revoked outputs were claimed.
///
/// Next tests that there is (or is not) a transaction that spends the commitment transaction
/// that appears to be the type of HTLC transaction specified in has_htlc_tx.
///
/// All broadcast transactions must be accounted for in one of the above three types of we'll
/// also fail.
pub fn test_txn_broadcast<'a, 'b, 'c>(
	node: &Node<'a, 'b, 'c>,
	chan: &(msgs::ChannelUpdate, msgs::ChannelUpdate, ChannelId, Transaction),
	commitment_tx: Option<Transaction>, has_htlc_tx: HTLCType,
) -> Vec<Transaction> {
	let mut node_txn = node.tx_broadcaster.txn_broadcasted.lock().unwrap();
	let mut txn_seen = new_hash_set();
	node_txn.retain(|tx| txn_seen.insert(tx.compute_txid()));
	assert!(
		node_txn.len()
			>= if commitment_tx.is_some() { 0 } else { 1 }
				+ if has_htlc_tx == HTLCType::NONE { 0 } else { 1 }
	);

	let mut res = Vec::with_capacity(2);
	node_txn.retain(|tx| {
		if tx.input.len() == 1 && tx.input[0].previous_output.txid == chan.3.compute_txid() {
			check_spends!(tx, chan.3);
			if commitment_tx.is_none() {
				res.push(tx.clone());
			}
			false
		} else {
			true
		}
	});
	if let Some(explicit_tx) = commitment_tx {
		res.push(explicit_tx.clone());
	}

	assert_eq!(res.len(), 1);

	if has_htlc_tx != HTLCType::NONE {
		node_txn.retain(|tx| {
			if tx.input.len() == 1 && tx.input[0].previous_output.txid == res[0].compute_txid() {
				check_spends!(tx, res[0]);
				if has_htlc_tx == HTLCType::TIMEOUT {
					assert_ne!(tx.lock_time, LockTime::ZERO);
				} else {
					assert_eq!(tx.lock_time, LockTime::ZERO);
				}
				res.push(tx.clone());
				false
			} else {
				true
			}
		});
		assert!(res.len() == 2 || res.len() == 3);
		if res.len() == 3 {
			assert_eq!(res[1], res[2]);
		}
	}

	assert!(node_txn.is_empty());
	res
}

/// Tests that the given node has broadcast a claim transaction against the provided revoked
/// HTLC transaction.
pub fn test_revoked_htlc_claim_txn_broadcast<'a, 'b, 'c>(
	node: &Node<'a, 'b, 'c>, revoked_tx: Transaction, commitment_revoked_tx: Transaction,
) {
	let mut node_txn = node.tx_broadcaster.txn_broadcasted.lock().unwrap();
	// We may issue multiple claiming transaction on revoked outputs due to block rescan
	// for revoked htlc outputs
	if node_txn.len() != 1 && node_txn.len() != 2 && node_txn.len() != 3 {
		assert!(false);
	}
	node_txn.retain(|tx| {
		if tx.input.len() == 1 && tx.input[0].previous_output.txid == revoked_tx.compute_txid() {
			check_spends!(tx, revoked_tx);
			false
		} else {
			true
		}
	});
	node_txn.retain(|tx| {
		check_spends!(tx, commitment_revoked_tx);
		false
	});
	assert!(node_txn.is_empty());
}

pub fn check_preimage_claim<'a, 'b, 'c>(
	node: &Node<'a, 'b, 'c>, prev_txn: &Vec<Transaction>,
) -> Vec<Transaction> {
	let mut node_txn = node.tx_broadcaster.txn_broadcasted.lock().unwrap();
	let mut txn_seen = new_hash_set();
	node_txn.retain(|tx| txn_seen.insert(tx.compute_txid()));

	let mut found_prev = false;
	for prev_tx in prev_txn {
		for tx in &*node_txn {
			if tx.input[0].previous_output.txid == prev_tx.compute_txid() {
				check_spends!(tx, prev_tx);
				let mut iter = tx.input[0].witness.iter();
				iter.next().expect("expected 3 witness items");
				iter.next().expect("expected 3 witness items");
				assert!(iter.next().expect("expected 3 witness items").len() > 106); // must spend an htlc output
				assert_eq!(tx.input.len(), 1); // must spend a commitment tx

				found_prev = true;
				break;
			}
		}
	}
	assert!(found_prev);

	let mut res = Vec::new();
	mem::swap(&mut *node_txn, &mut res);
	res
}

pub fn handle_announce_close_broadcast_events<'a, 'b, 'c>(
	nodes: &Vec<Node<'a, 'b, 'c>>, a: usize, b: usize, needs_err_handle: bool, expected_error: &str,
) {
	let mut dummy_connected = false;
	if !is_any_peer_connected(&nodes[a]) {
		connect_dummy_node(&nodes[a]);
		dummy_connected = true
	}

	let node_a_id = nodes[a].node.get_our_node_id();
	let node_b_id = nodes[b].node.get_our_node_id();

	let events_1 = nodes[a].node.get_and_clear_pending_msg_events();
	assert_eq!(events_1.len(), 2);
	let as_update = match events_1[1] {
		MessageSendEvent::BroadcastChannelUpdate { ref msg, .. } => msg.clone(),
		_ => panic!("Unexpected event"),
	};
	match events_1[0] {
		MessageSendEvent::HandleError {
			node_id,
			action: msgs::ErrorAction::SendErrorMessage { ref msg },
		} => {
			assert_eq!(node_id, node_b_id);
			assert_eq!(msg.data, expected_error);
			if needs_err_handle {
				nodes[b].node.handle_error(node_a_id, msg);
			}
		},
		MessageSendEvent::HandleError {
			node_id,
			action: msgs::ErrorAction::DisconnectPeer { ref msg },
		} => {
			assert_eq!(node_id, node_b_id);
			assert_eq!(msg.as_ref().unwrap().data, expected_error);
			if needs_err_handle {
				nodes[b].node.handle_error(node_a_id, msg.as_ref().unwrap());
			}
		},
		_ => panic!("Unexpected event"),
	}
	if dummy_connected {
		disconnect_dummy_node(&nodes[a]);
		dummy_connected = false;
	}
	if !is_any_peer_connected(&nodes[b]) {
		connect_dummy_node(&nodes[b]);
		dummy_connected = true;
	}
	let events_2 = nodes[b].node.get_and_clear_pending_msg_events();
	assert_eq!(events_2.len(), if needs_err_handle { 1 } else { 2 });
	let bs_update = match events_2.last().unwrap() {
		MessageSendEvent::BroadcastChannelUpdate { ref msg, .. } => msg.clone(),
		_ => panic!("Unexpected event"),
	};
	if !needs_err_handle {
		match events_2[0] {
			MessageSendEvent::HandleError {
				node_id,
				action: msgs::ErrorAction::SendErrorMessage { ref msg },
			} => {
				assert_eq!(node_id, node_a_id);
				assert_eq!(msg.data, expected_error);
			},
			MessageSendEvent::HandleError {
				node_id,
				action: msgs::ErrorAction::DisconnectPeer { ref msg },
			} => {
				assert_eq!(node_id, node_a_id);
				assert_eq!(msg.as_ref().unwrap().data, expected_error);
			},
			_ => panic!("Unexpected event"),
		}
	}
	if dummy_connected {
		disconnect_dummy_node(&nodes[b]);
	}
	for node in nodes {
		node.gossip_sync.handle_channel_update(Some(node_a_id), &as_update).unwrap();
		node.gossip_sync.handle_channel_update(Some(node_a_id), &bs_update).unwrap();
	}
}

pub fn get_announce_close_broadcast_events<'a, 'b, 'c>(
	nodes: &Vec<Node<'a, 'b, 'c>>, a: usize, b: usize,
) {
	handle_announce_close_broadcast_events(
		nodes,
		a,
		b,
		false,
		"Channel closed because commitment or closing transaction was confirmed on chain.",
	);
}

#[cfg(any(test, feature = "_externalize_tests"))]
macro_rules! get_channel_value_stat {
	($node: expr, $counterparty_node: expr, $channel_id: expr) => {{
		let peer_state_lock = $node.node.per_peer_state.read().unwrap();
		let chan_lock = peer_state_lock
			.get(&$counterparty_node.node.get_our_node_id())
			.unwrap()
			.lock()
			.unwrap();
		let chan = chan_lock.channel_by_id.get(&$channel_id).and_then(Channel::as_funded).unwrap();
		chan.get_value_stat()
	}};
}

macro_rules! get_chan_reestablish_msgs {
	($src_node: expr, $dst_node: expr) => {{
		let mut announcements = $crate::prelude::new_hash_set();
		let mut res = Vec::with_capacity(1);
		for msg in $src_node.node.get_and_clear_pending_msg_events() {
			if let MessageSendEvent::SendChannelReestablish { ref node_id, ref msg } = msg {
				assert_eq!(*node_id, $dst_node.node.get_our_node_id());
				res.push(msg.clone());
			} else if let MessageSendEvent::SendChannelAnnouncement {
				ref node_id, ref msg, ..
			} = msg
			{
				assert_eq!(*node_id, $dst_node.node.get_our_node_id());
				announcements.insert(msg.contents.short_channel_id);
			} else {
				panic!("Unexpected event")
			}
		}
		assert!(announcements.is_empty());
		res
	}};
}

macro_rules! handle_chan_reestablish_msgs {
	($src_node: expr, $dst_node: expr) => {{
		let msg_events = $src_node.node.get_and_clear_pending_msg_events();
		let mut idx = 0;

		let mut tx_abort = None;
		if let Some(&MessageSendEvent::SendTxAbort { ref node_id, ref msg }) = msg_events.get(idx) {
			idx += 1;
			assert_eq!(*node_id, $dst_node.node.get_our_node_id());
			tx_abort = Some(msg.clone());
		}

		let channel_ready =
			if let Some(&MessageSendEvent::SendChannelReady { ref node_id, ref msg }) =
				msg_events.get(idx)
			{
				idx += 1;
				assert_eq!(*node_id, $dst_node.node.get_our_node_id());
				Some(msg.clone())
			} else {
				None
			};

		let mut announcement_sigs = None; // May be now or later
		if let Some(&MessageSendEvent::SendAnnouncementSignatures { ref node_id, ref msg }) =
			msg_events.get(idx)
		{
			idx += 1;
			assert_eq!(*node_id, $dst_node.node.get_our_node_id());
			assert!(announcement_sigs.is_none());
			announcement_sigs = Some(msg.clone());
		}

		let mut had_channel_update = false; // ChannelUpdate may be now or later, but not both
		if let Some(&MessageSendEvent::SendChannelUpdate { ref node_id, .. }) = msg_events.get(idx)
		{
			assert_eq!(*node_id, $dst_node.node.get_our_node_id());
			idx += 1;
			had_channel_update = true;
		}

		let mut stfu = None;
		if let Some(&MessageSendEvent::SendStfu { ref node_id, ref msg }) = msg_events.get(idx) {
			idx += 1;
			assert_eq!(*node_id, $dst_node.node.get_our_node_id());
			stfu = Some(msg.clone());
		}

		let mut revoke_and_ack = None;
		let mut commitment_update = None;
		let order = if let Some(ev) = msg_events.get(idx) {
			match ev {
				&MessageSendEvent::SendRevokeAndACK { ref node_id, ref msg } => {
					assert_eq!(*node_id, $dst_node.node.get_our_node_id());
					revoke_and_ack = Some(msg.clone());
					idx += 1;
					RAACommitmentOrder::RevokeAndACKFirst
				},
				&MessageSendEvent::UpdateHTLCs { ref node_id, ref channel_id, ref updates } => {
					assert_eq!(*node_id, $dst_node.node.get_our_node_id());
					assert!(updates
						.commitment_signed
						.iter()
						.all(|cs| cs.channel_id == *channel_id));
					commitment_update = Some(updates.clone());
					idx += 1;
					RAACommitmentOrder::CommitmentFirst
				},
				_ => RAACommitmentOrder::CommitmentFirst,
			}
		} else {
			RAACommitmentOrder::CommitmentFirst
		};

		if let Some(ev) = msg_events.get(idx) {
			match ev {
				&MessageSendEvent::SendRevokeAndACK { ref node_id, ref msg } => {
					assert_eq!(*node_id, $dst_node.node.get_our_node_id());
					assert!(revoke_and_ack.is_none());
					revoke_and_ack = Some(msg.clone());
					idx += 1;
				},
				&MessageSendEvent::UpdateHTLCs { ref node_id, ref channel_id, ref updates } => {
					assert_eq!(*node_id, $dst_node.node.get_our_node_id());
					assert!(commitment_update.is_none());
					assert!(updates
						.commitment_signed
						.iter()
						.all(|cs| cs.channel_id == *channel_id));
					commitment_update = Some(updates.clone());
					idx += 1;
				},
				_ => {},
			}
		}

		let mut tx_signatures = None;
		if let Some(&MessageSendEvent::SendTxSignatures { ref node_id, ref msg }) =
			msg_events.get(idx)
		{
			assert_eq!(*node_id, $dst_node.node.get_our_node_id());
			tx_signatures = Some(msg.clone());
			idx += 1;
		}

		if let Some(&MessageSendEvent::SendAnnouncementSignatures { ref node_id, ref msg }) =
			msg_events.get(idx)
		{
			idx += 1;
			assert_eq!(*node_id, $dst_node.node.get_our_node_id());
			assert!(announcement_sigs.is_none());
			announcement_sigs = Some(msg.clone());
		}

		if let Some(&MessageSendEvent::SendChannelUpdate { ref node_id, .. }) = msg_events.get(idx)
		{
			assert_eq!(*node_id, $dst_node.node.get_our_node_id());
			idx += 1;
			assert!(!had_channel_update);
		}

		assert_eq!(msg_events.len(), idx, "{msg_events:?}");

		(
			channel_ready,
			revoke_and_ack,
			commitment_update,
			order,
			announcement_sigs,
			tx_signatures,
			stfu,
			tx_abort,
		)
	}};
}

pub struct ReconnectArgs<'a, 'b, 'c, 'd> {
	pub node_a: &'a Node<'b, 'c, 'd>,
	pub node_b: &'a Node<'b, 'c, 'd>,
	pub send_channel_ready: (bool, bool),
	pub send_announcement_sigs: (bool, bool),
	pub send_stfu: (bool, bool),
	pub send_interactive_tx_commit_sig: (bool, bool),
	pub send_interactive_tx_sigs: (bool, bool),
	pub send_tx_abort: (bool, bool),
	pub expect_renegotiated_funding_locked_monitor_update: (bool, bool),
	pub pending_responding_commitment_signed: (bool, bool),
	/// Indicates that the pending responding commitment signed will be a dup for the recipient,
	/// and no monitor update is expected
	pub pending_responding_commitment_signed_dup_monitor: (bool, bool),
	pub pending_htlc_adds: (usize, usize),
	pub pending_htlc_claims: (usize, usize),
	pub pending_htlc_fails: (usize, usize),
	pub pending_cell_htlc_claims: (usize, usize),
	pub pending_cell_htlc_fails: (usize, usize),
	pub pending_raa: (bool, bool),
}

impl<'a, 'b, 'c, 'd> ReconnectArgs<'a, 'b, 'c, 'd> {
	pub fn new(node_a: &'a Node<'b, 'c, 'd>, node_b: &'a Node<'b, 'c, 'd>) -> Self {
		Self {
			node_a,
			node_b,
			send_channel_ready: (false, false),
			send_announcement_sigs: (false, false),
			send_stfu: (false, false),
			send_interactive_tx_commit_sig: (false, false),
			send_interactive_tx_sigs: (false, false),
			send_tx_abort: (false, false),
			expect_renegotiated_funding_locked_monitor_update: (false, false),
			pending_responding_commitment_signed: (false, false),
			pending_responding_commitment_signed_dup_monitor: (false, false),
			pending_htlc_adds: (0, 0),
			pending_htlc_claims: (0, 0),
			pending_htlc_fails: (0, 0),
			pending_cell_htlc_claims: (0, 0),
			pending_cell_htlc_fails: (0, 0),
			pending_raa: (false, false),
		}
	}
}

/// pending_htlc_adds includes both the holding cell and in-flight update_add_htlcs, whereas
/// for claims/fails they are separated out.
pub fn reconnect_nodes<'a, 'b, 'c, 'd>(args: ReconnectArgs<'a, 'b, 'c, 'd>) {
	let ReconnectArgs {
		node_a,
		node_b,
		send_channel_ready,
		send_announcement_sigs,
		send_stfu,
		send_interactive_tx_commit_sig,
		send_interactive_tx_sigs,
		send_tx_abort,
		expect_renegotiated_funding_locked_monitor_update,
		pending_htlc_adds,
		pending_htlc_claims,
		pending_htlc_fails,
		pending_cell_htlc_claims,
		pending_cell_htlc_fails,
		pending_raa,
		pending_responding_commitment_signed,
		pending_responding_commitment_signed_dup_monitor,
	} = args;
	connect_nodes(node_a, node_b);
	let reestablish_1 = get_chan_reestablish_msgs!(node_a, node_b);
	let reestablish_2 = get_chan_reestablish_msgs!(node_b, node_a);

	let node_a_id = node_a.node.get_our_node_id();
	let node_b_id = node_b.node.get_our_node_id();

	if send_channel_ready.0 {
		// If a expects a channel_ready, it better not think it has received a revoke_and_ack
		// from b
		for reestablish in reestablish_1.iter() {
			let n = reestablish.next_remote_commitment_number;
			assert_eq!(n, 0, "expected a->b next_remote_commitment_number to be 0, got {}", n);
		}
	}
	if send_channel_ready.1 {
		// If b expects a channel_ready, it better not think it has received a revoke_and_ack
		// from a
		for reestablish in reestablish_2.iter() {
			let n = reestablish.next_remote_commitment_number;
			assert_eq!(n, 0, "expected b->a next_remote_commitment_number to be 0, got {}", n);
		}
	}
	if send_channel_ready.0 || send_channel_ready.1 {
		// If we expect any channel_ready's, both sides better have set
		// next_holder_commitment_number to 1
		for reestablish in reestablish_1.iter() {
			let n = reestablish.next_local_commitment_number;
			assert_eq!(n, 1, "expected a->b next_local_commitment_number to be 1, got {}", n);
		}
		for reestablish in reestablish_2.iter() {
			let n = reestablish.next_local_commitment_number;
			assert_eq!(n, 1, "expected b->a next_local_commitment_number to be 1, got {}", n);
		}
	}

	let mut resp_1 = Vec::new();
	for msg in reestablish_1 {
		node_b.node.handle_channel_reestablish(node_a_id, &msg);
		resp_1.push(handle_chan_reestablish_msgs!(node_b, node_a));
	}

	if pending_cell_htlc_claims.0 != 0
		|| pending_cell_htlc_fails.0 != 0
		|| expect_renegotiated_funding_locked_monitor_update.1
	{
		check_added_monitors(&node_b, 1);
	} else {
		check_added_monitors(&node_b, 0);
	}

	let mut resp_2 = Vec::new();
	for msg in reestablish_2 {
		node_a.node.handle_channel_reestablish(node_b_id, &msg);
		resp_2.push(handle_chan_reestablish_msgs!(node_a, node_b));
	}
	if pending_cell_htlc_claims.1 != 0
		|| pending_cell_htlc_fails.1 != 0
		|| expect_renegotiated_funding_locked_monitor_update.0
	{
		check_added_monitors(&node_a, 1);
	} else {
		check_added_monitors(&node_a, 0);
	}

	// We don't yet support both needing updates, as that would require a different commitment dance:
	assert!(
		(pending_htlc_adds.0 == 0
			&& pending_htlc_claims.0 == 0
			&& pending_htlc_fails.0 == 0
			&& pending_cell_htlc_claims.0 == 0
			&& pending_cell_htlc_fails.0 == 0)
			|| (pending_htlc_adds.1 == 0
				&& pending_htlc_claims.1 == 0
				&& pending_htlc_fails.1 == 0
				&& pending_cell_htlc_claims.1 == 0
				&& pending_cell_htlc_fails.1 == 0)
	);

	for mut chan_msgs in resp_1.drain(..) {
		if send_channel_ready.0 {
			node_a.node.handle_channel_ready(node_b_id, &chan_msgs.0.unwrap());
			let announcement_event = node_a.node.get_and_clear_pending_msg_events();
			if !announcement_event.is_empty() {
				assert_eq!(announcement_event.len(), 1);
				if let MessageSendEvent::SendChannelUpdate { .. } = announcement_event[0] {
					//TODO: Test announcement_sigs re-sending
				} else {
					panic!("Unexpected event! {:?}", announcement_event[0]);
				}
			}
		} else {
			assert!(chan_msgs.0.is_none());
		}
		if send_announcement_sigs.0 {
			let announcement_sigs = chan_msgs.4.take().unwrap();
			node_a.node.handle_announcement_signatures(node_b_id, &announcement_sigs);
			let msg_events = node_a.node.get_and_clear_pending_msg_events();
			assert_eq!(msg_events.len(), 1, "{msg_events:?}");
			if let MessageSendEvent::BroadcastChannelAnnouncement { .. } = msg_events[0] {
			} else {
				panic!("Unexpected event! {:?}", msg_events[0]);
			}
		} else {
			assert!(chan_msgs.4.is_none());
		}
		if send_stfu.0 {
			let stfu = chan_msgs.6.take().unwrap();
			node_a.node.handle_stfu(node_b_id, &stfu);
		} else {
			assert!(chan_msgs.6.is_none());
		}
		if send_interactive_tx_commit_sig.0 {
			assert!(chan_msgs.1.is_none());
			let commitment_update = chan_msgs.2.take().unwrap();
			assert_eq!(commitment_update.commitment_signed.len(), 1);
			node_a.node.handle_commitment_signed_batch_test(
				node_b_id,
				&commitment_update.commitment_signed,
			)
		}
		if send_tx_abort.0 {
			let tx_abort = chan_msgs.7.take().unwrap();
			node_a.node.handle_tx_abort(node_b_id, &tx_abort);
		} else {
			assert!(chan_msgs.7.is_none());
		}
		if send_interactive_tx_sigs.0 {
			let tx_signatures = chan_msgs.5.take().unwrap();
			node_a.node.handle_tx_signatures(node_b_id, &tx_signatures);
		} else {
			assert!(chan_msgs.5.is_none());
		}
		if pending_raa.0 {
			assert!(chan_msgs.3 == RAACommitmentOrder::RevokeAndACKFirst);
			node_a.node.handle_revoke_and_ack(node_b_id, &chan_msgs.1.unwrap());
			assert!(node_a.node.get_and_clear_pending_msg_events().is_empty());
			check_added_monitors(&node_a, 1);
		} else {
			assert!(chan_msgs.1.is_none());
		}
		if pending_htlc_adds.0 != 0
			|| pending_htlc_claims.0 != 0
			|| pending_htlc_fails.0 != 0
			|| pending_cell_htlc_claims.0 != 0
			|| pending_cell_htlc_fails.0 != 0
			|| pending_responding_commitment_signed.0
		{
			let commitment_update = chan_msgs.2.unwrap();
			assert_eq!(commitment_update.update_add_htlcs.len(), pending_htlc_adds.0);
			assert_eq!(
				commitment_update.update_fulfill_htlcs.len(),
				pending_htlc_claims.0 + pending_cell_htlc_claims.0
			);
			assert_eq!(
				commitment_update.update_fail_htlcs.len(),
				pending_htlc_fails.0 + pending_cell_htlc_fails.0
			);
			assert!(commitment_update.update_fail_malformed_htlcs.is_empty());
			for update_add in commitment_update.update_add_htlcs {
				node_a.node.handle_update_add_htlc(node_b_id, &update_add);
			}
			for update_fulfill in commitment_update.update_fulfill_htlcs {
				node_a.node.handle_update_fulfill_htlc(node_b_id, update_fulfill);
			}
			for update_fail in commitment_update.update_fail_htlcs {
				node_a.node.handle_update_fail_htlc(node_b_id, &update_fail);
			}

			if !pending_responding_commitment_signed.0 {
				let commitment = &commitment_update.commitment_signed;
				do_commitment_signed_dance(node_a, node_b, commitment, false, false);
			} else {
				node_a.node.handle_commitment_signed_batch_test(
					node_b_id,
					&commitment_update.commitment_signed,
				);
				check_added_monitors(&node_a, 1);
				let as_revoke_and_ack =
					get_event_msg!(node_a, MessageSendEvent::SendRevokeAndACK, node_b_id);
				// No commitment_signed so get_event_msg's assert(len == 1) passes
				node_b.node.handle_revoke_and_ack(node_a_id, &as_revoke_and_ack);
				assert!(node_b.node.get_and_clear_pending_msg_events().is_empty());
				check_added_monitors(
					&node_b,
					if pending_responding_commitment_signed_dup_monitor.0 { 0 } else { 1 },
				);
			}
		} else {
			assert!(chan_msgs.2.is_none());
		}
	}

	for mut chan_msgs in resp_2.drain(..) {
		if send_channel_ready.1 {
			node_b.node.handle_channel_ready(node_a_id, &chan_msgs.0.unwrap());
			let announcement_event = node_b.node.get_and_clear_pending_msg_events();
			if !announcement_event.is_empty() {
				assert_eq!(announcement_event.len(), 1);
				match announcement_event[0] {
					MessageSendEvent::SendChannelUpdate { .. } => {},
					MessageSendEvent::SendAnnouncementSignatures { .. } => {},
					_ => panic!("Unexpected event {:?}!", announcement_event[0]),
				}
			}
		} else {
			assert!(chan_msgs.0.is_none());
		}
		if send_announcement_sigs.1 {
			let announcement_sigs = chan_msgs.4.take().unwrap();
			node_b.node.handle_announcement_signatures(node_a_id, &announcement_sigs);
			let mut msg_events = node_b.node.get_and_clear_pending_msg_events();
			assert_eq!(msg_events.len(), 1, "{msg_events:?}");
			if let MessageSendEvent::BroadcastChannelAnnouncement { .. } = msg_events.remove(0) {
			} else {
				panic!();
			}
		} else {
			assert!(chan_msgs.4.is_none());
		}
		if send_stfu.1 {
			let stfu = chan_msgs.6.take().unwrap();
			node_b.node.handle_stfu(node_a_id, &stfu);
		} else {
			assert!(chan_msgs.6.is_none());
		}
		if send_interactive_tx_commit_sig.1 {
			assert!(chan_msgs.1.is_none());
			let commitment_update = chan_msgs.2.take().unwrap();
			assert_eq!(commitment_update.commitment_signed.len(), 1);
			node_b.node.handle_commitment_signed_batch_test(
				node_a_id,
				&commitment_update.commitment_signed,
			)
		}
		if send_tx_abort.1 {
			let tx_abort = chan_msgs.7.take().unwrap();
			node_a.node.handle_tx_abort(node_b_id, &tx_abort);
		} else {
			assert!(chan_msgs.7.is_none());
		}
		if send_interactive_tx_sigs.1 {
			let tx_signatures = chan_msgs.5.take().unwrap();
			node_b.node.handle_tx_signatures(node_a_id, &tx_signatures);
		} else {
			assert!(chan_msgs.5.is_none());
		}
		if pending_raa.1 {
			assert!(chan_msgs.3 == RAACommitmentOrder::RevokeAndACKFirst);
			node_b.node.handle_revoke_and_ack(node_a_id, &chan_msgs.1.unwrap());
			assert!(node_b.node.get_and_clear_pending_msg_events().is_empty());
			check_added_monitors(&node_b, 1);
		} else {
			assert!(chan_msgs.1.is_none());
		}
		if pending_htlc_adds.1 != 0
			|| pending_htlc_claims.1 != 0
			|| pending_htlc_fails.1 != 0
			|| pending_cell_htlc_claims.1 != 0
			|| pending_cell_htlc_fails.1 != 0
			|| pending_responding_commitment_signed.1
		{
			let commitment_update = chan_msgs.2.unwrap();
			assert_eq!(commitment_update.update_add_htlcs.len(), pending_htlc_adds.1);
			assert_eq!(
				commitment_update.update_fulfill_htlcs.len(),
				pending_htlc_claims.1 + pending_cell_htlc_claims.1
			);
			assert_eq!(
				commitment_update.update_fail_htlcs.len(),
				pending_htlc_fails.1 + pending_cell_htlc_fails.1
			);
			assert!(commitment_update.update_fail_malformed_htlcs.is_empty());
			for update_add in commitment_update.update_add_htlcs {
				node_b.node.handle_update_add_htlc(node_a_id, &update_add);
			}
			for update_fulfill in commitment_update.update_fulfill_htlcs {
				node_b.node.handle_update_fulfill_htlc(node_a_id, update_fulfill);
			}
			for update_fail in commitment_update.update_fail_htlcs {
				node_b.node.handle_update_fail_htlc(node_a_id, &update_fail);
			}

			if !pending_responding_commitment_signed.1 {
				let commitment = &commitment_update.commitment_signed;
				do_commitment_signed_dance(node_b, node_a, commitment, false, false);
			} else {
				node_b.node.handle_commitment_signed_batch_test(
					node_a_id,
					&commitment_update.commitment_signed,
				);
				check_added_monitors(&node_b, 1);
				let bs_revoke_and_ack =
					get_event_msg!(node_b, MessageSendEvent::SendRevokeAndACK, node_a_id);
				// No commitment_signed so get_event_msg's assert(len == 1) passes
				node_a.node.handle_revoke_and_ack(node_b_id, &bs_revoke_and_ack);
				assert!(node_a.node.get_and_clear_pending_msg_events().is_empty());
				check_added_monitors(
					&node_a,
					if pending_responding_commitment_signed_dup_monitor.1 { 0 } else { 1 },
				);
			}
		} else {
			assert!(chan_msgs.2.is_none());
		}
	}
}

/// Initiates channel opening and creates a single batch funding transaction.
/// This will go through the open_channel / accept_channel flow, and return the batch funding
/// transaction with corresponding funding_created messages.
pub fn create_batch_channel_funding<'a, 'b, 'c>(
	funding_node: &Node<'a, 'b, 'c>,
	params: &[(&Node<'a, 'b, 'c>, u64, u64, u128, Option<UserConfig>)],
) -> (Transaction, Vec<msgs::FundingCreated>) {
	let mut tx_outs = Vec::new();
	let mut temp_chan_ids = Vec::new();
	let mut funding_created_msgs = Vec::new();

	for (other_node, channel_value_satoshis, push_msat, user_channel_id, override_config) in params
	{
		let funding_node_id = funding_node.node.get_our_node_id();
		let other_node_id = other_node.node.get_our_node_id();

		// Initialize channel opening.
		let temp_chan_id = funding_node
			.node
			.create_channel(
				other_node_id,
				*channel_value_satoshis,
				*push_msat,
				*user_channel_id,
				None,
				override_config.clone(),
			)
			.unwrap();
		let open_channel_msg =
			get_event_msg!(funding_node, MessageSendEvent::SendOpenChannel, other_node_id);
		handle_and_accept_open_channel(other_node, funding_node_id, &open_channel_msg);

		let accept_channel_msg =
			get_event_msg!(other_node, MessageSendEvent::SendAcceptChannel, funding_node_id);
		funding_node.node.handle_accept_channel(other_node_id, &accept_channel_msg);

		// Create the corresponding funding output.
		let events = funding_node.node.get_and_clear_pending_events();
		assert_eq!(events.len(), 1);
		match events[0] {
			Event::FundingGenerationReady {
				ref temporary_channel_id,
				ref counterparty_node_id,
				channel_value_satoshis: ref event_channel_value_satoshis,
				ref output_script,
				user_channel_id: ref event_user_channel_id,
			} => {
				assert_eq!(temporary_channel_id, &temp_chan_id);
				assert_eq!(counterparty_node_id, &other_node_id);
				assert_eq!(channel_value_satoshis, event_channel_value_satoshis);
				assert_eq!(user_channel_id, event_user_channel_id);
				tx_outs.push(TxOut {
					value: Amount::from_sat(*channel_value_satoshis),
					script_pubkey: output_script.clone(),
				});
			},
			_ => panic!("Unexpected event"),
		};
		temp_chan_ids.push((temp_chan_id, other_node_id));
	}

	// Compose the batch funding transaction and give it to the ChannelManager.
	let tx = Transaction {
		version: transaction::Version::TWO,
		lock_time: LockTime::ZERO,
		input: Vec::new(),
		output: tx_outs,
	};
	assert!(funding_node
		.node
		.batch_funding_transaction_generated(
			temp_chan_ids.iter().map(|(a, b)| (a, b)).collect::<Vec<_>>().as_slice(),
			tx.clone(),
		)
		.is_ok());
	check_added_monitors(&funding_node, 0);
	let events = funding_node.node.get_and_clear_pending_msg_events();
	assert_eq!(events.len(), params.len());
	for (other_node, ..) in params {
		let funding_created = events
			.iter()
			.find_map(|event| match event {
				MessageSendEvent::SendFundingCreated { node_id, msg }
					if node_id == &other_node.node.get_our_node_id() =>
				{
					Some(msg.clone())
				},
				_ => None,
			})
			.unwrap();
		funding_created_msgs.push(funding_created);
	}
	return (tx, funding_created_msgs);
}

pub fn get_scid_from_channel_id<'a, 'b, 'c>(node: &Node<'a, 'b, 'c>, channel_id: ChannelId) -> u64 {
	node.node()
		.list_channels()
		.iter()
		.find(|c| c.channel_id == channel_id)
		.unwrap()
		.short_channel_id
		.unwrap()
}
